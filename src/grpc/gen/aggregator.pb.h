// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: aggregator.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_aggregator_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_aggregator_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_aggregator_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_aggregator_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_aggregator_2eproto;
namespace aggregator {
namespace v1 {
class AggregatorMessage;
struct AggregatorMessageDefaultTypeInternal;
extern AggregatorMessageDefaultTypeInternal _AggregatorMessage_default_instance_;
class CancelRequest;
struct CancelRequestDefaultTypeInternal;
extern CancelRequestDefaultTypeInternal _CancelRequest_default_instance_;
class CancelResponse;
struct CancelResponseDefaultTypeInternal;
extern CancelResponseDefaultTypeInternal _CancelResponse_default_instance_;
class FinalProof;
struct FinalProofDefaultTypeInternal;
extern FinalProofDefaultTypeInternal _FinalProof_default_instance_;
class GenAggregatedProofRequest;
struct GenAggregatedProofRequestDefaultTypeInternal;
extern GenAggregatedProofRequestDefaultTypeInternal _GenAggregatedProofRequest_default_instance_;
class GenAggregatedProofResponse;
struct GenAggregatedProofResponseDefaultTypeInternal;
extern GenAggregatedProofResponseDefaultTypeInternal _GenAggregatedProofResponse_default_instance_;
class GenBatchProofRequest;
struct GenBatchProofRequestDefaultTypeInternal;
extern GenBatchProofRequestDefaultTypeInternal _GenBatchProofRequest_default_instance_;
class GenBatchProofResponse;
struct GenBatchProofResponseDefaultTypeInternal;
extern GenBatchProofResponseDefaultTypeInternal _GenBatchProofResponse_default_instance_;
class GenFinalProofRequest;
struct GenFinalProofRequestDefaultTypeInternal;
extern GenFinalProofRequestDefaultTypeInternal _GenFinalProofRequest_default_instance_;
class GenFinalProofResponse;
struct GenFinalProofResponseDefaultTypeInternal;
extern GenFinalProofResponseDefaultTypeInternal _GenFinalProofResponse_default_instance_;
class GenStatelessBatchProofRequest;
struct GenStatelessBatchProofRequestDefaultTypeInternal;
extern GenStatelessBatchProofRequestDefaultTypeInternal _GenStatelessBatchProofRequest_default_instance_;
class GetProofRequest;
struct GetProofRequestDefaultTypeInternal;
extern GetProofRequestDefaultTypeInternal _GetProofRequest_default_instance_;
class GetProofResponse;
struct GetProofResponseDefaultTypeInternal;
extern GetProofResponseDefaultTypeInternal _GetProofResponse_default_instance_;
class GetStatusRequest;
struct GetStatusRequestDefaultTypeInternal;
extern GetStatusRequestDefaultTypeInternal _GetStatusRequest_default_instance_;
class GetStatusResponse;
struct GetStatusResponseDefaultTypeInternal;
extern GetStatusResponseDefaultTypeInternal _GetStatusResponse_default_instance_;
class InputProver;
struct InputProverDefaultTypeInternal;
extern InputProverDefaultTypeInternal _InputProver_default_instance_;
class InputProver_ContractsBytecodeEntry_DoNotUse;
struct InputProver_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal;
extern InputProver_ContractsBytecodeEntry_DoNotUseDefaultTypeInternal _InputProver_ContractsBytecodeEntry_DoNotUse_default_instance_;
class InputProver_DbEntry_DoNotUse;
struct InputProver_DbEntry_DoNotUseDefaultTypeInternal;
extern InputProver_DbEntry_DoNotUseDefaultTypeInternal _InputProver_DbEntry_DoNotUse_default_instance_;
class L1Data;
struct L1DataDefaultTypeInternal;
extern L1DataDefaultTypeInternal _L1Data_default_instance_;
class ProverMessage;
struct ProverMessageDefaultTypeInternal;
extern ProverMessageDefaultTypeInternal _ProverMessage_default_instance_;
class PublicInputs;
struct PublicInputsDefaultTypeInternal;
extern PublicInputsDefaultTypeInternal _PublicInputs_default_instance_;
class PublicInputsExtended;
struct PublicInputsExtendedDefaultTypeInternal;
extern PublicInputsExtendedDefaultTypeInternal _PublicInputsExtended_default_instance_;
class PublicInputs_L1InfoTreeDataEntry_DoNotUse;
struct PublicInputs_L1InfoTreeDataEntry_DoNotUseDefaultTypeInternal;
extern PublicInputs_L1InfoTreeDataEntry_DoNotUseDefaultTypeInternal _PublicInputs_L1InfoTreeDataEntry_DoNotUse_default_instance_;
class StatelessInputProver;
struct StatelessInputProverDefaultTypeInternal;
extern StatelessInputProverDefaultTypeInternal _StatelessInputProver_default_instance_;
class StatelessPublicInputs;
struct StatelessPublicInputsDefaultTypeInternal;
extern StatelessPublicInputsDefaultTypeInternal _StatelessPublicInputs_default_instance_;
class StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse;
struct StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUseDefaultTypeInternal;
extern StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUseDefaultTypeInternal _StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace v1
}  // namespace aggregator
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace aggregator {
namespace v1 {
enum GetStatusResponse_Status : int {
  GetStatusResponse_Status_STATUS_UNSPECIFIED = 0,
  GetStatusResponse_Status_STATUS_BOOTING = 1,
  GetStatusResponse_Status_STATUS_COMPUTING = 2,
  GetStatusResponse_Status_STATUS_IDLE = 3,
  GetStatusResponse_Status_STATUS_HALT = 4,
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GetStatusResponse_Status_IsValid(int value);
extern const uint32_t GetStatusResponse_Status_internal_data_[];
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MIN = static_cast<GetStatusResponse_Status>(0);
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MAX = static_cast<GetStatusResponse_Status>(4);
constexpr int GetStatusResponse_Status_Status_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
GetStatusResponse_Status_descriptor();
template <typename T>
const std::string& GetStatusResponse_Status_Name(T value) {
  static_assert(std::is_same<T, GetStatusResponse_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return GetStatusResponse_Status_Name(static_cast<GetStatusResponse_Status>(value));
}
template <>
inline const std::string& GetStatusResponse_Status_Name(GetStatusResponse_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GetStatusResponse_Status_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool GetStatusResponse_Status_Parse(absl::string_view name, GetStatusResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetStatusResponse_Status>(
      GetStatusResponse_Status_descriptor(), name, value);
}
enum GetProofResponse_Result : int {
  GetProofResponse_Result_RESULT_UNSPECIFIED = 0,
  GetProofResponse_Result_RESULT_COMPLETED_OK = 1,
  GetProofResponse_Result_RESULT_ERROR = 2,
  GetProofResponse_Result_RESULT_COMPLETED_ERROR = 3,
  GetProofResponse_Result_RESULT_PENDING = 4,
  GetProofResponse_Result_RESULT_INTERNAL_ERROR = 5,
  GetProofResponse_Result_RESULT_CANCEL = 6,
  GetProofResponse_Result_GetProofResponse_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GetProofResponse_Result_GetProofResponse_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GetProofResponse_Result_IsValid(int value);
extern const uint32_t GetProofResponse_Result_internal_data_[];
constexpr GetProofResponse_Result GetProofResponse_Result_Result_MIN = static_cast<GetProofResponse_Result>(0);
constexpr GetProofResponse_Result GetProofResponse_Result_Result_MAX = static_cast<GetProofResponse_Result>(6);
constexpr int GetProofResponse_Result_Result_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
GetProofResponse_Result_descriptor();
template <typename T>
const std::string& GetProofResponse_Result_Name(T value) {
  static_assert(std::is_same<T, GetProofResponse_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return GetProofResponse_Result_Name(static_cast<GetProofResponse_Result>(value));
}
template <>
inline const std::string& GetProofResponse_Result_Name(GetProofResponse_Result value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GetProofResponse_Result_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool GetProofResponse_Result_Parse(absl::string_view name, GetProofResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetProofResponse_Result>(
      GetProofResponse_Result_descriptor(), name, value);
}
enum Result : int {
  RESULT_UNSPECIFIED = 0,
  RESULT_OK = 1,
  RESULT_ERROR = 2,
  RESULT_INTERNAL_ERROR = 3,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Result_IsValid(int value);
extern const uint32_t Result_internal_data_[];
constexpr Result Result_MIN = static_cast<Result>(0);
constexpr Result Result_MAX = static_cast<Result>(3);
constexpr int Result_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Result_descriptor();
template <typename T>
const std::string& Result_Name(T value) {
  static_assert(std::is_same<T, Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return Result_Name(static_cast<Result>(value));
}
template <>
inline const std::string& Result_Name(Result value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Result_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Result_Parse(absl::string_view name, Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result>(
      Result_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Version final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Version(
      ::google::protobuf::internal::ConstantInitialized);

  inline Version(const Version& from) : Version(nullptr, from) {}
  inline Version(Version&& from) noexcept
      : Version(nullptr, std::move(from)) {}
  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
        &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Version& a, Version& b) { a.Swap(&b); }
  inline void Swap(Version* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Version>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Version& from) { Version::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Version* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.Version"; }

 protected:
  explicit Version(::google::protobuf::Arena* arena);
  Version(::google::protobuf::Arena* arena, const Version& from);
  Version(::google::protobuf::Arena* arena, Version&& from) noexcept
      : Version(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kV001FieldNumber = 1,
  };
  // string v0_0_1 = 1;
  void clear_v0_0_1() ;
  const std::string& v0_0_1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_v0_0_1(Arg_&& arg, Args_... args);
  std::string* mutable_v0_0_1();
  PROTOBUF_NODISCARD std::string* release_v0_0_1();
  void set_allocated_v0_0_1(std::string* value);

  private:
  const std::string& _internal_v0_0_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v0_0_1(
      const std::string& value);
  std::string* _internal_mutable_v0_0_1();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.Version)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Version_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Version& from_msg);
    ::google::protobuf::internal::ArenaStringPtr v0_0_1_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class L1Data final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.L1Data) */ {
 public:
  inline L1Data() : L1Data(nullptr) {}
  ~L1Data() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR L1Data(
      ::google::protobuf::internal::ConstantInitialized);

  inline L1Data(const L1Data& from) : L1Data(nullptr, from) {}
  inline L1Data(L1Data&& from) noexcept
      : L1Data(nullptr, std::move(from)) {}
  inline L1Data& operator=(const L1Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline L1Data& operator=(L1Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L1Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const L1Data* internal_default_instance() {
    return reinterpret_cast<const L1Data*>(
        &_L1Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(L1Data& a, L1Data& b) { a.Swap(&b); }
  inline void Swap(L1Data* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L1Data* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L1Data* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<L1Data>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const L1Data& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const L1Data& from) { L1Data::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(L1Data* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.L1Data"; }

 protected:
  explicit L1Data(::google::protobuf::Arena* arena);
  L1Data(::google::protobuf::Arena* arena, const L1Data& from);
  L1Data(::google::protobuf::Arena* arena, L1Data&& from) noexcept
      : L1Data(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSmtProofFieldNumber = 4,
    kGlobalExitRootFieldNumber = 1,
    kBlockhashL1FieldNumber = 2,
    kMinTimestampFieldNumber = 3,
  };
  // repeated bytes smt_proof = 4;
  int smt_proof_size() const;
  private:
  int _internal_smt_proof_size() const;

  public:
  void clear_smt_proof() ;
  const std::string& smt_proof(int index) const;
  std::string* mutable_smt_proof(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_smt_proof(int index, Arg_&& value, Args_... args);
  std::string* add_smt_proof();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_smt_proof(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& smt_proof() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_smt_proof();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_smt_proof() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_smt_proof();

  public:
  // bytes global_exit_root = 1;
  void clear_global_exit_root() ;
  const std::string& global_exit_root() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_global_exit_root(Arg_&& arg, Args_... args);
  std::string* mutable_global_exit_root();
  PROTOBUF_NODISCARD std::string* release_global_exit_root();
  void set_allocated_global_exit_root(std::string* value);

  private:
  const std::string& _internal_global_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_exit_root(
      const std::string& value);
  std::string* _internal_mutable_global_exit_root();

  public:
  // bytes blockhash_l1 = 2;
  void clear_blockhash_l1() ;
  const std::string& blockhash_l1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_blockhash_l1(Arg_&& arg, Args_... args);
  std::string* mutable_blockhash_l1();
  PROTOBUF_NODISCARD std::string* release_blockhash_l1();
  void set_allocated_blockhash_l1(std::string* value);

  private:
  const std::string& _internal_blockhash_l1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash_l1(
      const std::string& value);
  std::string* _internal_mutable_blockhash_l1();

  public:
  // uint32 min_timestamp = 3;
  void clear_min_timestamp() ;
  ::uint32_t min_timestamp() const;
  void set_min_timestamp(::uint32_t value);

  private:
  ::uint32_t _internal_min_timestamp() const;
  void _internal_set_min_timestamp(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.L1Data)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_L1Data_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const L1Data& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> smt_proof_;
    ::google::protobuf::internal::ArenaStringPtr global_exit_root_;
    ::google::protobuf::internal::ArenaStringPtr blockhash_l1_;
    ::uint32_t min_timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class InputProver_DbEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          InputProver_DbEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      InputProver_DbEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  InputProver_DbEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputProver_DbEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit InputProver_DbEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const InputProver_DbEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const InputProver_DbEntry_DoNotUse*>(
        &_InputProver_DbEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class InputProver_ContractsBytecodeEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          InputProver_ContractsBytecodeEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      InputProver_ContractsBytecodeEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  InputProver_ContractsBytecodeEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputProver_ContractsBytecodeEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit InputProver_ContractsBytecodeEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const InputProver_ContractsBytecodeEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const InputProver_ContractsBytecodeEntry_DoNotUse*>(
        &_InputProver_ContractsBytecodeEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetStatusResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GetStatusResponse) */ {
 public:
  inline GetStatusResponse() : GetStatusResponse(nullptr) {}
  ~GetStatusResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetStatusResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetStatusResponse(const GetStatusResponse& from) : GetStatusResponse(nullptr, from) {}
  inline GetStatusResponse(GetStatusResponse&& from) noexcept
      : GetStatusResponse(nullptr, std::move(from)) {}
  inline GetStatusResponse& operator=(const GetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusResponse& operator=(GetStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatusResponse*>(
        &_GetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GetStatusResponse& a, GetStatusResponse& b) { a.Swap(&b); }
  inline void Swap(GetStatusResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetStatusResponse& from) { GetStatusResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetStatusResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GetStatusResponse"; }

 protected:
  explicit GetStatusResponse(::google::protobuf::Arena* arena);
  GetStatusResponse(::google::protobuf::Arena* arena, const GetStatusResponse& from);
  GetStatusResponse(::google::protobuf::Arena* arena, GetStatusResponse&& from) noexcept
      : GetStatusResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Status = GetStatusResponse_Status;
  static constexpr Status STATUS_UNSPECIFIED = GetStatusResponse_Status_STATUS_UNSPECIFIED;
  static constexpr Status STATUS_BOOTING = GetStatusResponse_Status_STATUS_BOOTING;
  static constexpr Status STATUS_COMPUTING = GetStatusResponse_Status_STATUS_COMPUTING;
  static constexpr Status STATUS_IDLE = GetStatusResponse_Status_STATUS_IDLE;
  static constexpr Status STATUS_HALT = GetStatusResponse_Status_STATUS_HALT;
  static inline bool Status_IsValid(int value) {
    return GetStatusResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = GetStatusResponse_Status_Status_MIN;
  static constexpr Status Status_MAX = GetStatusResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = GetStatusResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return GetStatusResponse_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return GetStatusResponse_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return GetStatusResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPendingRequestQueueIdsFieldNumber = 8,
    kLastComputedRequestIdFieldNumber = 2,
    kCurrentComputingRequestIdFieldNumber = 4,
    kVersionProtoFieldNumber = 6,
    kVersionServerFieldNumber = 7,
    kProverNameFieldNumber = 9,
    kProverIdFieldNumber = 10,
    kLastComputedEndTimeFieldNumber = 3,
    kCurrentComputingStartTimeFieldNumber = 5,
    kNumberOfCoresFieldNumber = 11,
    kTotalMemoryFieldNumber = 12,
    kFreeMemoryFieldNumber = 13,
    kForkIdFieldNumber = 14,
    kStatusFieldNumber = 1,
  };
  // repeated string pending_request_queue_ids = 8;
  int pending_request_queue_ids_size() const;
  private:
  int _internal_pending_request_queue_ids_size() const;

  public:
  void clear_pending_request_queue_ids() ;
  const std::string& pending_request_queue_ids(int index) const;
  std::string* mutable_pending_request_queue_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pending_request_queue_ids(int index, Arg_&& value, Args_... args);
  std::string* add_pending_request_queue_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_pending_request_queue_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& pending_request_queue_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_pending_request_queue_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_pending_request_queue_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_pending_request_queue_ids();

  public:
  // string last_computed_request_id = 2;
  void clear_last_computed_request_id() ;
  const std::string& last_computed_request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_computed_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_last_computed_request_id();
  PROTOBUF_NODISCARD std::string* release_last_computed_request_id();
  void set_allocated_last_computed_request_id(std::string* value);

  private:
  const std::string& _internal_last_computed_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_computed_request_id(
      const std::string& value);
  std::string* _internal_mutable_last_computed_request_id();

  public:
  // string current_computing_request_id = 4;
  void clear_current_computing_request_id() ;
  const std::string& current_computing_request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_computing_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_current_computing_request_id();
  PROTOBUF_NODISCARD std::string* release_current_computing_request_id();
  void set_allocated_current_computing_request_id(std::string* value);

  private:
  const std::string& _internal_current_computing_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_computing_request_id(
      const std::string& value);
  std::string* _internal_mutable_current_computing_request_id();

  public:
  // string version_proto = 6;
  void clear_version_proto() ;
  const std::string& version_proto() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version_proto(Arg_&& arg, Args_... args);
  std::string* mutable_version_proto();
  PROTOBUF_NODISCARD std::string* release_version_proto();
  void set_allocated_version_proto(std::string* value);

  private:
  const std::string& _internal_version_proto() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_proto(
      const std::string& value);
  std::string* _internal_mutable_version_proto();

  public:
  // string version_server = 7;
  void clear_version_server() ;
  const std::string& version_server() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version_server(Arg_&& arg, Args_... args);
  std::string* mutable_version_server();
  PROTOBUF_NODISCARD std::string* release_version_server();
  void set_allocated_version_server(std::string* value);

  private:
  const std::string& _internal_version_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_server(
      const std::string& value);
  std::string* _internal_mutable_version_server();

  public:
  // string prover_name = 9;
  void clear_prover_name() ;
  const std::string& prover_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prover_name(Arg_&& arg, Args_... args);
  std::string* mutable_prover_name();
  PROTOBUF_NODISCARD std::string* release_prover_name();
  void set_allocated_prover_name(std::string* value);

  private:
  const std::string& _internal_prover_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_name(
      const std::string& value);
  std::string* _internal_mutable_prover_name();

  public:
  // string prover_id = 10;
  void clear_prover_id() ;
  const std::string& prover_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prover_id(Arg_&& arg, Args_... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* value);

  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(
      const std::string& value);
  std::string* _internal_mutable_prover_id();

  public:
  // uint64 last_computed_end_time = 3;
  void clear_last_computed_end_time() ;
  ::uint64_t last_computed_end_time() const;
  void set_last_computed_end_time(::uint64_t value);

  private:
  ::uint64_t _internal_last_computed_end_time() const;
  void _internal_set_last_computed_end_time(::uint64_t value);

  public:
  // uint64 current_computing_start_time = 5;
  void clear_current_computing_start_time() ;
  ::uint64_t current_computing_start_time() const;
  void set_current_computing_start_time(::uint64_t value);

  private:
  ::uint64_t _internal_current_computing_start_time() const;
  void _internal_set_current_computing_start_time(::uint64_t value);

  public:
  // uint64 number_of_cores = 11;
  void clear_number_of_cores() ;
  ::uint64_t number_of_cores() const;
  void set_number_of_cores(::uint64_t value);

  private:
  ::uint64_t _internal_number_of_cores() const;
  void _internal_set_number_of_cores(::uint64_t value);

  public:
  // uint64 total_memory = 12;
  void clear_total_memory() ;
  ::uint64_t total_memory() const;
  void set_total_memory(::uint64_t value);

  private:
  ::uint64_t _internal_total_memory() const;
  void _internal_set_total_memory(::uint64_t value);

  public:
  // uint64 free_memory = 13;
  void clear_free_memory() ;
  ::uint64_t free_memory() const;
  void set_free_memory(::uint64_t value);

  private:
  ::uint64_t _internal_free_memory() const;
  void _internal_set_free_memory(::uint64_t value);

  public:
  // uint64 fork_id = 14;
  void clear_fork_id() ;
  ::uint64_t fork_id() const;
  void set_fork_id(::uint64_t value);

  private:
  ::uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(::uint64_t value);

  public:
  // .aggregator.v1.GetStatusResponse.Status status = 1;
  void clear_status() ;
  ::aggregator::v1::GetStatusResponse_Status status() const;
  void set_status(::aggregator::v1::GetStatusResponse_Status value);

  private:
  ::aggregator::v1::GetStatusResponse_Status _internal_status() const;
  void _internal_set_status(::aggregator::v1::GetStatusResponse_Status value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GetStatusResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 0,
      172, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetStatusResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetStatusResponse& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> pending_request_queue_ids_;
    ::google::protobuf::internal::ArenaStringPtr last_computed_request_id_;
    ::google::protobuf::internal::ArenaStringPtr current_computing_request_id_;
    ::google::protobuf::internal::ArenaStringPtr version_proto_;
    ::google::protobuf::internal::ArenaStringPtr version_server_;
    ::google::protobuf::internal::ArenaStringPtr prover_name_;
    ::google::protobuf::internal::ArenaStringPtr prover_id_;
    ::uint64_t last_computed_end_time_;
    ::uint64_t current_computing_start_time_;
    ::uint64_t number_of_cores_;
    ::uint64_t total_memory_;
    ::uint64_t free_memory_;
    ::uint64_t fork_id_;
    int status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:aggregator.v1.GetStatusRequest) */ {
 public:
  inline GetStatusRequest() : GetStatusRequest(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetStatusRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetStatusRequest(const GetStatusRequest& from) : GetStatusRequest(nullptr, from) {}
  inline GetStatusRequest(GetStatusRequest&& from) noexcept
      : GetStatusRequest(nullptr, std::move(from)) {}
  inline GetStatusRequest& operator=(const GetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRequest& operator=(GetStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatusRequest*>(
        &_GetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(GetStatusRequest& a, GetStatusRequest& b) { a.Swap(&b); }
  inline void Swap(GetStatusRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetStatusRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetStatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetStatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GetStatusRequest"; }

 protected:
  explicit GetStatusRequest(::google::protobuf::Arena* arena);
  GetStatusRequest(::google::protobuf::Arena* arena, const GetStatusRequest& from);
  GetStatusRequest(::google::protobuf::Arena* arena, GetStatusRequest&& from) noexcept
      : GetStatusRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:aggregator.v1.GetStatusRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetStatusRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetStatusRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetProofRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GetProofRequest) */ {
 public:
  inline GetProofRequest() : GetProofRequest(nullptr) {}
  ~GetProofRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetProofRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetProofRequest(const GetProofRequest& from) : GetProofRequest(nullptr, from) {}
  inline GetProofRequest(GetProofRequest&& from) noexcept
      : GetProofRequest(nullptr, std::move(from)) {}
  inline GetProofRequest& operator=(const GetProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProofRequest& operator=(GetProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProofRequest* internal_default_instance() {
    return reinterpret_cast<const GetProofRequest*>(
        &_GetProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GetProofRequest& a, GetProofRequest& b) { a.Swap(&b); }
  inline void Swap(GetProofRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProofRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProofRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetProofRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProofRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetProofRequest& from) { GetProofRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetProofRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GetProofRequest"; }

 protected:
  explicit GetProofRequest(::google::protobuf::Arena* arena);
  GetProofRequest(::google::protobuf::Arena* arena, const GetProofRequest& from);
  GetProofRequest(::google::protobuf::Arena* arena, GetProofRequest&& from) noexcept
      : GetProofRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kTimeoutFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // uint64 timeout = 2;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GetProofRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      40, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetProofRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetProofRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::uint64_t timeout_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenFinalProofResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GenFinalProofResponse) */ {
 public:
  inline GenFinalProofResponse() : GenFinalProofResponse(nullptr) {}
  ~GenFinalProofResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenFinalProofResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenFinalProofResponse(const GenFinalProofResponse& from) : GenFinalProofResponse(nullptr, from) {}
  inline GenFinalProofResponse(GenFinalProofResponse&& from) noexcept
      : GenFinalProofResponse(nullptr, std::move(from)) {}
  inline GenFinalProofResponse& operator=(const GenFinalProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenFinalProofResponse& operator=(GenFinalProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenFinalProofResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenFinalProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenFinalProofResponse*>(
        &_GenFinalProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(GenFinalProofResponse& a, GenFinalProofResponse& b) { a.Swap(&b); }
  inline void Swap(GenFinalProofResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenFinalProofResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenFinalProofResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenFinalProofResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenFinalProofResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenFinalProofResponse& from) { GenFinalProofResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenFinalProofResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GenFinalProofResponse"; }

 protected:
  explicit GenFinalProofResponse(::google::protobuf::Arena* arena);
  GenFinalProofResponse(::google::protobuf::Arena* arena, const GenFinalProofResponse& from);
  GenFinalProofResponse(::google::protobuf::Arena* arena, GenFinalProofResponse&& from) noexcept
      : GenFinalProofResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .aggregator.v1.Result result = 2;
  void clear_result() ;
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);

  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GenFinalProofResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenFinalProofResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenFinalProofResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    int result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenFinalProofRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GenFinalProofRequest) */ {
 public:
  inline GenFinalProofRequest() : GenFinalProofRequest(nullptr) {}
  ~GenFinalProofRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenFinalProofRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenFinalProofRequest(const GenFinalProofRequest& from) : GenFinalProofRequest(nullptr, from) {}
  inline GenFinalProofRequest(GenFinalProofRequest&& from) noexcept
      : GenFinalProofRequest(nullptr, std::move(from)) {}
  inline GenFinalProofRequest& operator=(const GenFinalProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenFinalProofRequest& operator=(GenFinalProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenFinalProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenFinalProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenFinalProofRequest*>(
        &_GenFinalProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(GenFinalProofRequest& a, GenFinalProofRequest& b) { a.Swap(&b); }
  inline void Swap(GenFinalProofRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenFinalProofRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenFinalProofRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenFinalProofRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenFinalProofRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenFinalProofRequest& from) { GenFinalProofRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenFinalProofRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GenFinalProofRequest"; }

 protected:
  explicit GenFinalProofRequest(::google::protobuf::Arena* arena);
  GenFinalProofRequest(::google::protobuf::Arena* arena, const GenFinalProofRequest& from);
  GenFinalProofRequest(::google::protobuf::Arena* arena, GenFinalProofRequest&& from) noexcept
      : GenFinalProofRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRecursiveProofFieldNumber = 1,
    kAggregatorAddrFieldNumber = 2,
  };
  // string recursive_proof = 1;
  void clear_recursive_proof() ;
  const std::string& recursive_proof() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recursive_proof(Arg_&& arg, Args_... args);
  std::string* mutable_recursive_proof();
  PROTOBUF_NODISCARD std::string* release_recursive_proof();
  void set_allocated_recursive_proof(std::string* value);

  private:
  const std::string& _internal_recursive_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof(
      const std::string& value);
  std::string* _internal_mutable_recursive_proof();

  public:
  // string aggregator_addr = 2;
  void clear_aggregator_addr() ;
  const std::string& aggregator_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aggregator_addr(Arg_&& arg, Args_... args);
  std::string* mutable_aggregator_addr();
  PROTOBUF_NODISCARD std::string* release_aggregator_addr();
  void set_allocated_aggregator_addr(std::string* value);

  private:
  const std::string& _internal_aggregator_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregator_addr(
      const std::string& value);
  std::string* _internal_mutable_aggregator_addr();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GenFinalProofRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenFinalProofRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenFinalProofRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr recursive_proof_;
    ::google::protobuf::internal::ArenaStringPtr aggregator_addr_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenBatchProofResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GenBatchProofResponse) */ {
 public:
  inline GenBatchProofResponse() : GenBatchProofResponse(nullptr) {}
  ~GenBatchProofResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenBatchProofResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenBatchProofResponse(const GenBatchProofResponse& from) : GenBatchProofResponse(nullptr, from) {}
  inline GenBatchProofResponse(GenBatchProofResponse&& from) noexcept
      : GenBatchProofResponse(nullptr, std::move(from)) {}
  inline GenBatchProofResponse& operator=(const GenBatchProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenBatchProofResponse& operator=(GenBatchProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenBatchProofResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenBatchProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenBatchProofResponse*>(
        &_GenBatchProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(GenBatchProofResponse& a, GenBatchProofResponse& b) { a.Swap(&b); }
  inline void Swap(GenBatchProofResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenBatchProofResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenBatchProofResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenBatchProofResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenBatchProofResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenBatchProofResponse& from) { GenBatchProofResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenBatchProofResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GenBatchProofResponse"; }

 protected:
  explicit GenBatchProofResponse(::google::protobuf::Arena* arena);
  GenBatchProofResponse(::google::protobuf::Arena* arena, const GenBatchProofResponse& from);
  GenBatchProofResponse(::google::protobuf::Arena* arena, GenBatchProofResponse&& from) noexcept
      : GenBatchProofResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .aggregator.v1.Result result = 2;
  void clear_result() ;
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);

  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GenBatchProofResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenBatchProofResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenBatchProofResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    int result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenAggregatedProofResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GenAggregatedProofResponse) */ {
 public:
  inline GenAggregatedProofResponse() : GenAggregatedProofResponse(nullptr) {}
  ~GenAggregatedProofResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenAggregatedProofResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenAggregatedProofResponse(const GenAggregatedProofResponse& from) : GenAggregatedProofResponse(nullptr, from) {}
  inline GenAggregatedProofResponse(GenAggregatedProofResponse&& from) noexcept
      : GenAggregatedProofResponse(nullptr, std::move(from)) {}
  inline GenAggregatedProofResponse& operator=(const GenAggregatedProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenAggregatedProofResponse& operator=(GenAggregatedProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenAggregatedProofResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenAggregatedProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenAggregatedProofResponse*>(
        &_GenAggregatedProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(GenAggregatedProofResponse& a, GenAggregatedProofResponse& b) { a.Swap(&b); }
  inline void Swap(GenAggregatedProofResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenAggregatedProofResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenAggregatedProofResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenAggregatedProofResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenAggregatedProofResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenAggregatedProofResponse& from) { GenAggregatedProofResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenAggregatedProofResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GenAggregatedProofResponse"; }

 protected:
  explicit GenAggregatedProofResponse(::google::protobuf::Arena* arena);
  GenAggregatedProofResponse(::google::protobuf::Arena* arena, const GenAggregatedProofResponse& from);
  GenAggregatedProofResponse(::google::protobuf::Arena* arena, GenAggregatedProofResponse&& from) noexcept
      : GenAggregatedProofResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .aggregator.v1.Result result = 2;
  void clear_result() ;
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);

  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GenAggregatedProofResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenAggregatedProofResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenAggregatedProofResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    int result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenAggregatedProofRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GenAggregatedProofRequest) */ {
 public:
  inline GenAggregatedProofRequest() : GenAggregatedProofRequest(nullptr) {}
  ~GenAggregatedProofRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenAggregatedProofRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenAggregatedProofRequest(const GenAggregatedProofRequest& from) : GenAggregatedProofRequest(nullptr, from) {}
  inline GenAggregatedProofRequest(GenAggregatedProofRequest&& from) noexcept
      : GenAggregatedProofRequest(nullptr, std::move(from)) {}
  inline GenAggregatedProofRequest& operator=(const GenAggregatedProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenAggregatedProofRequest& operator=(GenAggregatedProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenAggregatedProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenAggregatedProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenAggregatedProofRequest*>(
        &_GenAggregatedProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GenAggregatedProofRequest& a, GenAggregatedProofRequest& b) { a.Swap(&b); }
  inline void Swap(GenAggregatedProofRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenAggregatedProofRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenAggregatedProofRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenAggregatedProofRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenAggregatedProofRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenAggregatedProofRequest& from) { GenAggregatedProofRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenAggregatedProofRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GenAggregatedProofRequest"; }

 protected:
  explicit GenAggregatedProofRequest(::google::protobuf::Arena* arena);
  GenAggregatedProofRequest(::google::protobuf::Arena* arena, const GenAggregatedProofRequest& from);
  GenAggregatedProofRequest(::google::protobuf::Arena* arena, GenAggregatedProofRequest&& from) noexcept
      : GenAggregatedProofRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRecursiveProof1FieldNumber = 1,
    kRecursiveProof2FieldNumber = 2,
  };
  // string recursive_proof_1 = 1;
  void clear_recursive_proof_1() ;
  const std::string& recursive_proof_1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recursive_proof_1(Arg_&& arg, Args_... args);
  std::string* mutable_recursive_proof_1();
  PROTOBUF_NODISCARD std::string* release_recursive_proof_1();
  void set_allocated_recursive_proof_1(std::string* value);

  private:
  const std::string& _internal_recursive_proof_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof_1(
      const std::string& value);
  std::string* _internal_mutable_recursive_proof_1();

  public:
  // string recursive_proof_2 = 2;
  void clear_recursive_proof_2() ;
  const std::string& recursive_proof_2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recursive_proof_2(Arg_&& arg, Args_... args);
  std::string* mutable_recursive_proof_2();
  PROTOBUF_NODISCARD std::string* release_recursive_proof_2();
  void set_allocated_recursive_proof_2(std::string* value);

  private:
  const std::string& _internal_recursive_proof_2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof_2(
      const std::string& value);
  std::string* _internal_mutable_recursive_proof_2();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GenAggregatedProofRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      82, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenAggregatedProofRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenAggregatedProofRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr recursive_proof_1_;
    ::google::protobuf::internal::ArenaStringPtr recursive_proof_2_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class CancelResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.CancelResponse) */ {
 public:
  inline CancelResponse() : CancelResponse(nullptr) {}
  ~CancelResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelResponse(const CancelResponse& from) : CancelResponse(nullptr, from) {}
  inline CancelResponse(CancelResponse&& from) noexcept
      : CancelResponse(nullptr, std::move(from)) {}
  inline CancelResponse& operator=(const CancelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponse& operator=(CancelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelResponse* internal_default_instance() {
    return reinterpret_cast<const CancelResponse*>(
        &_CancelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(CancelResponse& a, CancelResponse& b) { a.Swap(&b); }
  inline void Swap(CancelResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CancelResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelResponse& from) { CancelResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CancelResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.CancelResponse"; }

 protected:
  explicit CancelResponse(::google::protobuf::Arena* arena);
  CancelResponse(::google::protobuf::Arena* arena, const CancelResponse& from);
  CancelResponse(::google::protobuf::Arena* arena, CancelResponse&& from) noexcept
      : CancelResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // .aggregator.v1.Result result = 1;
  void clear_result() ;
  ::aggregator::v1::Result result() const;
  void set_result(::aggregator::v1::Result value);

  private:
  ::aggregator::v1::Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::Result value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.CancelResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CancelResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelResponse& from_msg);
    int result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class CancelRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.CancelRequest) */ {
 public:
  inline CancelRequest() : CancelRequest(nullptr) {}
  ~CancelRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelRequest(const CancelRequest& from) : CancelRequest(nullptr, from) {}
  inline CancelRequest(CancelRequest&& from) noexcept
      : CancelRequest(nullptr, std::move(from)) {}
  inline CancelRequest& operator=(const CancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelRequest& operator=(CancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelRequest* internal_default_instance() {
    return reinterpret_cast<const CancelRequest*>(
        &_CancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CancelRequest& a, CancelRequest& b) { a.Swap(&b); }
  inline void Swap(CancelRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CancelRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelRequest& from) { CancelRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CancelRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.CancelRequest"; }

 protected:
  explicit CancelRequest(::google::protobuf::Arena* arena);
  CancelRequest(::google::protobuf::Arena* arena, const CancelRequest& from);
  CancelRequest(::google::protobuf::Arena* arena, CancelRequest&& from) noexcept
      : CancelRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.CancelRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CancelRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse, ::uint32_t, ::aggregator::v1::L1Data,
          ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse, ::uint32_t, ::aggregator::v1::L1Data,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse*>(
        &_StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class PublicInputs_L1InfoTreeDataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          PublicInputs_L1InfoTreeDataEntry_DoNotUse, ::uint32_t, ::aggregator::v1::L1Data,
          ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      PublicInputs_L1InfoTreeDataEntry_DoNotUse, ::uint32_t, ::aggregator::v1::L1Data,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  PublicInputs_L1InfoTreeDataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PublicInputs_L1InfoTreeDataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PublicInputs_L1InfoTreeDataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PublicInputs_L1InfoTreeDataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PublicInputs_L1InfoTreeDataEntry_DoNotUse*>(
        &_PublicInputs_L1InfoTreeDataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class StatelessPublicInputs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.StatelessPublicInputs) */ {
 public:
  inline StatelessPublicInputs() : StatelessPublicInputs(nullptr) {}
  ~StatelessPublicInputs() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatelessPublicInputs(
      ::google::protobuf::internal::ConstantInitialized);

  inline StatelessPublicInputs(const StatelessPublicInputs& from) : StatelessPublicInputs(nullptr, from) {}
  inline StatelessPublicInputs(StatelessPublicInputs&& from) noexcept
      : StatelessPublicInputs(nullptr, std::move(from)) {}
  inline StatelessPublicInputs& operator=(const StatelessPublicInputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatelessPublicInputs& operator=(StatelessPublicInputs&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatelessPublicInputs& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatelessPublicInputs* internal_default_instance() {
    return reinterpret_cast<const StatelessPublicInputs*>(
        &_StatelessPublicInputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(StatelessPublicInputs& a, StatelessPublicInputs& b) { a.Swap(&b); }
  inline void Swap(StatelessPublicInputs* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatelessPublicInputs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatelessPublicInputs* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<StatelessPublicInputs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatelessPublicInputs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StatelessPublicInputs& from) { StatelessPublicInputs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatelessPublicInputs* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.StatelessPublicInputs"; }

 protected:
  explicit StatelessPublicInputs(::google::protobuf::Arena* arena);
  StatelessPublicInputs(::google::protobuf::Arena* arena, const StatelessPublicInputs& from);
  StatelessPublicInputs(::google::protobuf::Arena* arena, StatelessPublicInputs&& from) noexcept
      : StatelessPublicInputs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kL1InfoTreeDataFieldNumber = 12,
    kWitnessFieldNumber = 1,
    kOldAccInputHashFieldNumber = 2,
    kBatchL2DataFieldNumber = 6,
    kL1InfoRootFieldNumber = 7,
    kSequencerAddrFieldNumber = 9,
    kForcedBlockhashL1FieldNumber = 10,
    kAggregatorAddrFieldNumber = 11,
    kOldBatchNumFieldNumber = 3,
    kChainIdFieldNumber = 4,
    kForkIdFieldNumber = 5,
    kTimestampLimitFieldNumber = 8,
  };
  // map<uint32, .aggregator.v1.L1Data> l1_info_tree_data = 12;
  int l1_info_tree_data_size() const;
  private:
  int _internal_l1_info_tree_data_size() const;

  public:
  void clear_l1_info_tree_data() ;
  const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& l1_info_tree_data() const;
  ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* mutable_l1_info_tree_data();

  private:
  const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& _internal_l1_info_tree_data() const;
  ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* _internal_mutable_l1_info_tree_data();

  public:
  // bytes witness = 1;
  void clear_witness() ;
  const std::string& witness() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_witness(Arg_&& arg, Args_... args);
  std::string* mutable_witness();
  PROTOBUF_NODISCARD std::string* release_witness();
  void set_allocated_witness(std::string* value);

  private:
  const std::string& _internal_witness() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness(
      const std::string& value);
  std::string* _internal_mutable_witness();

  public:
  // bytes old_acc_input_hash = 2;
  void clear_old_acc_input_hash() ;
  const std::string& old_acc_input_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_old_acc_input_hash(Arg_&& arg, Args_... args);
  std::string* mutable_old_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_old_acc_input_hash();
  void set_allocated_old_acc_input_hash(std::string* value);

  private:
  const std::string& _internal_old_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_acc_input_hash(
      const std::string& value);
  std::string* _internal_mutable_old_acc_input_hash();

  public:
  // bytes batch_l2_data = 6;
  void clear_batch_l2_data() ;
  const std::string& batch_l2_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_batch_l2_data(Arg_&& arg, Args_... args);
  std::string* mutable_batch_l2_data();
  PROTOBUF_NODISCARD std::string* release_batch_l2_data();
  void set_allocated_batch_l2_data(std::string* value);

  private:
  const std::string& _internal_batch_l2_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_l2_data(
      const std::string& value);
  std::string* _internal_mutable_batch_l2_data();

  public:
  // bytes l1_info_root = 7;
  void clear_l1_info_root() ;
  const std::string& l1_info_root() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_l1_info_root(Arg_&& arg, Args_... args);
  std::string* mutable_l1_info_root();
  PROTOBUF_NODISCARD std::string* release_l1_info_root();
  void set_allocated_l1_info_root(std::string* value);

  private:
  const std::string& _internal_l1_info_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_l1_info_root(
      const std::string& value);
  std::string* _internal_mutable_l1_info_root();

  public:
  // string sequencer_addr = 9;
  void clear_sequencer_addr() ;
  const std::string& sequencer_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sequencer_addr(Arg_&& arg, Args_... args);
  std::string* mutable_sequencer_addr();
  PROTOBUF_NODISCARD std::string* release_sequencer_addr();
  void set_allocated_sequencer_addr(std::string* value);

  private:
  const std::string& _internal_sequencer_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequencer_addr(
      const std::string& value);
  std::string* _internal_mutable_sequencer_addr();

  public:
  // bytes forced_blockhash_l1 = 10;
  void clear_forced_blockhash_l1() ;
  const std::string& forced_blockhash_l1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_forced_blockhash_l1(Arg_&& arg, Args_... args);
  std::string* mutable_forced_blockhash_l1();
  PROTOBUF_NODISCARD std::string* release_forced_blockhash_l1();
  void set_allocated_forced_blockhash_l1(std::string* value);

  private:
  const std::string& _internal_forced_blockhash_l1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_forced_blockhash_l1(
      const std::string& value);
  std::string* _internal_mutable_forced_blockhash_l1();

  public:
  // string aggregator_addr = 11;
  void clear_aggregator_addr() ;
  const std::string& aggregator_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aggregator_addr(Arg_&& arg, Args_... args);
  std::string* mutable_aggregator_addr();
  PROTOBUF_NODISCARD std::string* release_aggregator_addr();
  void set_allocated_aggregator_addr(std::string* value);

  private:
  const std::string& _internal_aggregator_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregator_addr(
      const std::string& value);
  std::string* _internal_mutable_aggregator_addr();

  public:
  // uint64 old_batch_num = 3;
  void clear_old_batch_num() ;
  ::uint64_t old_batch_num() const;
  void set_old_batch_num(::uint64_t value);

  private:
  ::uint64_t _internal_old_batch_num() const;
  void _internal_set_old_batch_num(::uint64_t value);

  public:
  // uint64 chain_id = 4;
  void clear_chain_id() ;
  ::uint64_t chain_id() const;
  void set_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(::uint64_t value);

  public:
  // uint64 fork_id = 5;
  void clear_fork_id() ;
  ::uint64_t fork_id() const;
  void set_fork_id(::uint64_t value);

  private:
  ::uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(::uint64_t value);

  public:
  // uint64 timestamp_limit = 8;
  void clear_timestamp_limit() ;
  ::uint64_t timestamp_limit() const;
  void set_timestamp_limit(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp_limit() const;
  void _internal_set_timestamp_limit(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.StatelessPublicInputs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 2,
      81, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StatelessPublicInputs_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StatelessPublicInputs& from_msg);
    ::google::protobuf::internal::MapField<StatelessPublicInputs_L1InfoTreeDataEntry_DoNotUse, ::uint32_t, ::aggregator::v1::L1Data,
                      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        l1_info_tree_data_;
    ::google::protobuf::internal::ArenaStringPtr witness_;
    ::google::protobuf::internal::ArenaStringPtr old_acc_input_hash_;
    ::google::protobuf::internal::ArenaStringPtr batch_l2_data_;
    ::google::protobuf::internal::ArenaStringPtr l1_info_root_;
    ::google::protobuf::internal::ArenaStringPtr sequencer_addr_;
    ::google::protobuf::internal::ArenaStringPtr forced_blockhash_l1_;
    ::google::protobuf::internal::ArenaStringPtr aggregator_addr_;
    ::uint64_t old_batch_num_;
    ::uint64_t chain_id_;
    ::uint64_t fork_id_;
    ::uint64_t timestamp_limit_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class PublicInputs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.PublicInputs) */ {
 public:
  inline PublicInputs() : PublicInputs(nullptr) {}
  ~PublicInputs() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PublicInputs(
      ::google::protobuf::internal::ConstantInitialized);

  inline PublicInputs(const PublicInputs& from) : PublicInputs(nullptr, from) {}
  inline PublicInputs(PublicInputs&& from) noexcept
      : PublicInputs(nullptr, std::move(from)) {}
  inline PublicInputs& operator=(const PublicInputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicInputs& operator=(PublicInputs&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicInputs& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicInputs* internal_default_instance() {
    return reinterpret_cast<const PublicInputs*>(
        &_PublicInputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(PublicInputs& a, PublicInputs& b) { a.Swap(&b); }
  inline void Swap(PublicInputs* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicInputs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicInputs* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PublicInputs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PublicInputs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PublicInputs& from) { PublicInputs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PublicInputs* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.PublicInputs"; }

 protected:
  explicit PublicInputs(::google::protobuf::Arena* arena);
  PublicInputs(::google::protobuf::Arena* arena, const PublicInputs& from);
  PublicInputs(::google::protobuf::Arena* arena, PublicInputs&& from) noexcept
      : PublicInputs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kL1InfoTreeDataFieldNumber = 16,
    kOldStateRootFieldNumber = 1,
    kOldAccInputHashFieldNumber = 2,
    kBatchL2DataFieldNumber = 6,
    kL1InfoRootFieldNumber = 7,
    kSequencerAddrFieldNumber = 9,
    kForcedBlockhashL1FieldNumber = 10,
    kAggregatorAddrFieldNumber = 12,
    kOldBatchNumFieldNumber = 3,
    kChainIdFieldNumber = 4,
    kForkIdFieldNumber = 5,
    kTimestampLimitFieldNumber = 8,
  };
  // map<uint32, .aggregator.v1.L1Data> l1_info_tree_data = 16;
  int l1_info_tree_data_size() const;
  private:
  int _internal_l1_info_tree_data_size() const;

  public:
  void clear_l1_info_tree_data() ;
  const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& l1_info_tree_data() const;
  ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* mutable_l1_info_tree_data();

  private:
  const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& _internal_l1_info_tree_data() const;
  ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* _internal_mutable_l1_info_tree_data();

  public:
  // bytes old_state_root = 1;
  void clear_old_state_root() ;
  const std::string& old_state_root() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_old_state_root(Arg_&& arg, Args_... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* value);

  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(
      const std::string& value);
  std::string* _internal_mutable_old_state_root();

  public:
  // bytes old_acc_input_hash = 2;
  void clear_old_acc_input_hash() ;
  const std::string& old_acc_input_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_old_acc_input_hash(Arg_&& arg, Args_... args);
  std::string* mutable_old_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_old_acc_input_hash();
  void set_allocated_old_acc_input_hash(std::string* value);

  private:
  const std::string& _internal_old_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_acc_input_hash(
      const std::string& value);
  std::string* _internal_mutable_old_acc_input_hash();

  public:
  // bytes batch_l2_data = 6;
  void clear_batch_l2_data() ;
  const std::string& batch_l2_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_batch_l2_data(Arg_&& arg, Args_... args);
  std::string* mutable_batch_l2_data();
  PROTOBUF_NODISCARD std::string* release_batch_l2_data();
  void set_allocated_batch_l2_data(std::string* value);

  private:
  const std::string& _internal_batch_l2_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_l2_data(
      const std::string& value);
  std::string* _internal_mutable_batch_l2_data();

  public:
  // bytes l1_info_root = 7;
  void clear_l1_info_root() ;
  const std::string& l1_info_root() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_l1_info_root(Arg_&& arg, Args_... args);
  std::string* mutable_l1_info_root();
  PROTOBUF_NODISCARD std::string* release_l1_info_root();
  void set_allocated_l1_info_root(std::string* value);

  private:
  const std::string& _internal_l1_info_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_l1_info_root(
      const std::string& value);
  std::string* _internal_mutable_l1_info_root();

  public:
  // string sequencer_addr = 9;
  void clear_sequencer_addr() ;
  const std::string& sequencer_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sequencer_addr(Arg_&& arg, Args_... args);
  std::string* mutable_sequencer_addr();
  PROTOBUF_NODISCARD std::string* release_sequencer_addr();
  void set_allocated_sequencer_addr(std::string* value);

  private:
  const std::string& _internal_sequencer_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequencer_addr(
      const std::string& value);
  std::string* _internal_mutable_sequencer_addr();

  public:
  // bytes forced_blockhash_l1 = 10;
  void clear_forced_blockhash_l1() ;
  const std::string& forced_blockhash_l1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_forced_blockhash_l1(Arg_&& arg, Args_... args);
  std::string* mutable_forced_blockhash_l1();
  PROTOBUF_NODISCARD std::string* release_forced_blockhash_l1();
  void set_allocated_forced_blockhash_l1(std::string* value);

  private:
  const std::string& _internal_forced_blockhash_l1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_forced_blockhash_l1(
      const std::string& value);
  std::string* _internal_mutable_forced_blockhash_l1();

  public:
  // string aggregator_addr = 12;
  void clear_aggregator_addr() ;
  const std::string& aggregator_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aggregator_addr(Arg_&& arg, Args_... args);
  std::string* mutable_aggregator_addr();
  PROTOBUF_NODISCARD std::string* release_aggregator_addr();
  void set_allocated_aggregator_addr(std::string* value);

  private:
  const std::string& _internal_aggregator_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregator_addr(
      const std::string& value);
  std::string* _internal_mutable_aggregator_addr();

  public:
  // uint64 old_batch_num = 3;
  void clear_old_batch_num() ;
  ::uint64_t old_batch_num() const;
  void set_old_batch_num(::uint64_t value);

  private:
  ::uint64_t _internal_old_batch_num() const;
  void _internal_set_old_batch_num(::uint64_t value);

  public:
  // uint64 chain_id = 4;
  void clear_chain_id() ;
  ::uint64_t chain_id() const;
  void set_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(::uint64_t value);

  public:
  // uint64 fork_id = 5;
  void clear_fork_id() ;
  ::uint64_t fork_id() const;
  void set_fork_id(::uint64_t value);

  private:
  ::uint64_t _internal_fork_id() const;
  void _internal_set_fork_id(::uint64_t value);

  public:
  // uint64 timestamp_limit = 8;
  void clear_timestamp_limit() ;
  ::uint64_t timestamp_limit() const;
  void set_timestamp_limit(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp_limit() const;
  void _internal_set_timestamp_limit(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.PublicInputs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 2,
      72, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PublicInputs_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PublicInputs& from_msg);
    ::google::protobuf::internal::MapField<PublicInputs_L1InfoTreeDataEntry_DoNotUse, ::uint32_t, ::aggregator::v1::L1Data,
                      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        l1_info_tree_data_;
    ::google::protobuf::internal::ArenaStringPtr old_state_root_;
    ::google::protobuf::internal::ArenaStringPtr old_acc_input_hash_;
    ::google::protobuf::internal::ArenaStringPtr batch_l2_data_;
    ::google::protobuf::internal::ArenaStringPtr l1_info_root_;
    ::google::protobuf::internal::ArenaStringPtr sequencer_addr_;
    ::google::protobuf::internal::ArenaStringPtr forced_blockhash_l1_;
    ::google::protobuf::internal::ArenaStringPtr aggregator_addr_;
    ::uint64_t old_batch_num_;
    ::uint64_t chain_id_;
    ::uint64_t fork_id_;
    ::uint64_t timestamp_limit_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class StatelessInputProver final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.StatelessInputProver) */ {
 public:
  inline StatelessInputProver() : StatelessInputProver(nullptr) {}
  ~StatelessInputProver() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatelessInputProver(
      ::google::protobuf::internal::ConstantInitialized);

  inline StatelessInputProver(const StatelessInputProver& from) : StatelessInputProver(nullptr, from) {}
  inline StatelessInputProver(StatelessInputProver&& from) noexcept
      : StatelessInputProver(nullptr, std::move(from)) {}
  inline StatelessInputProver& operator=(const StatelessInputProver& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatelessInputProver& operator=(StatelessInputProver&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatelessInputProver& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatelessInputProver* internal_default_instance() {
    return reinterpret_cast<const StatelessInputProver*>(
        &_StatelessInputProver_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(StatelessInputProver& a, StatelessInputProver& b) { a.Swap(&b); }
  inline void Swap(StatelessInputProver* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatelessInputProver* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatelessInputProver* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<StatelessInputProver>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatelessInputProver& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StatelessInputProver& from) { StatelessInputProver::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatelessInputProver* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.StatelessInputProver"; }

 protected:
  explicit StatelessInputProver(::google::protobuf::Arena* arena);
  StatelessInputProver(::google::protobuf::Arena* arena, const StatelessInputProver& from);
  StatelessInputProver(::google::protobuf::Arena* arena, StatelessInputProver&& from) noexcept
      : StatelessInputProver(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPublicInputsFieldNumber = 1,
  };
  // .aggregator.v1.StatelessPublicInputs public_inputs = 1;
  bool has_public_inputs() const;
  void clear_public_inputs() ;
  const ::aggregator::v1::StatelessPublicInputs& public_inputs() const;
  PROTOBUF_NODISCARD ::aggregator::v1::StatelessPublicInputs* release_public_inputs();
  ::aggregator::v1::StatelessPublicInputs* mutable_public_inputs();
  void set_allocated_public_inputs(::aggregator::v1::StatelessPublicInputs* value);
  void unsafe_arena_set_allocated_public_inputs(::aggregator::v1::StatelessPublicInputs* value);
  ::aggregator::v1::StatelessPublicInputs* unsafe_arena_release_public_inputs();

  private:
  const ::aggregator::v1::StatelessPublicInputs& _internal_public_inputs() const;
  ::aggregator::v1::StatelessPublicInputs* _internal_mutable_public_inputs();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.StatelessInputProver)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StatelessInputProver_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StatelessInputProver& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::aggregator::v1::StatelessPublicInputs* public_inputs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class PublicInputsExtended final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.PublicInputsExtended) */ {
 public:
  inline PublicInputsExtended() : PublicInputsExtended(nullptr) {}
  ~PublicInputsExtended() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PublicInputsExtended(
      ::google::protobuf::internal::ConstantInitialized);

  inline PublicInputsExtended(const PublicInputsExtended& from) : PublicInputsExtended(nullptr, from) {}
  inline PublicInputsExtended(PublicInputsExtended&& from) noexcept
      : PublicInputsExtended(nullptr, std::move(from)) {}
  inline PublicInputsExtended& operator=(const PublicInputsExtended& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicInputsExtended& operator=(PublicInputsExtended&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicInputsExtended& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicInputsExtended* internal_default_instance() {
    return reinterpret_cast<const PublicInputsExtended*>(
        &_PublicInputsExtended_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(PublicInputsExtended& a, PublicInputsExtended& b) { a.Swap(&b); }
  inline void Swap(PublicInputsExtended* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicInputsExtended* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicInputsExtended* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PublicInputsExtended>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PublicInputsExtended& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PublicInputsExtended& from) { PublicInputsExtended::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PublicInputsExtended* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.PublicInputsExtended"; }

 protected:
  explicit PublicInputsExtended(::google::protobuf::Arena* arena);
  PublicInputsExtended(::google::protobuf::Arena* arena, const PublicInputsExtended& from);
  PublicInputsExtended(::google::protobuf::Arena* arena, PublicInputsExtended&& from) noexcept
      : PublicInputsExtended(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewStateRootFieldNumber = 2,
    kNewAccInputHashFieldNumber = 3,
    kNewLocalExitRootFieldNumber = 4,
    kPublicInputsFieldNumber = 1,
    kNewBatchNumFieldNumber = 5,
  };
  // bytes new_state_root = 2;
  void clear_new_state_root() ;
  const std::string& new_state_root() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_state_root(Arg_&& arg, Args_... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* value);

  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(
      const std::string& value);
  std::string* _internal_mutable_new_state_root();

  public:
  // bytes new_acc_input_hash = 3;
  void clear_new_acc_input_hash() ;
  const std::string& new_acc_input_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_acc_input_hash(Arg_&& arg, Args_... args);
  std::string* mutable_new_acc_input_hash();
  PROTOBUF_NODISCARD std::string* release_new_acc_input_hash();
  void set_allocated_new_acc_input_hash(std::string* value);

  private:
  const std::string& _internal_new_acc_input_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_acc_input_hash(
      const std::string& value);
  std::string* _internal_mutable_new_acc_input_hash();

  public:
  // bytes new_local_exit_root = 4;
  void clear_new_local_exit_root() ;
  const std::string& new_local_exit_root() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_local_exit_root(Arg_&& arg, Args_... args);
  std::string* mutable_new_local_exit_root();
  PROTOBUF_NODISCARD std::string* release_new_local_exit_root();
  void set_allocated_new_local_exit_root(std::string* value);

  private:
  const std::string& _internal_new_local_exit_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_local_exit_root(
      const std::string& value);
  std::string* _internal_mutable_new_local_exit_root();

  public:
  // .aggregator.v1.PublicInputs public_inputs = 1;
  bool has_public_inputs() const;
  void clear_public_inputs() ;
  const ::aggregator::v1::PublicInputs& public_inputs() const;
  PROTOBUF_NODISCARD ::aggregator::v1::PublicInputs* release_public_inputs();
  ::aggregator::v1::PublicInputs* mutable_public_inputs();
  void set_allocated_public_inputs(::aggregator::v1::PublicInputs* value);
  void unsafe_arena_set_allocated_public_inputs(::aggregator::v1::PublicInputs* value);
  ::aggregator::v1::PublicInputs* unsafe_arena_release_public_inputs();

  private:
  const ::aggregator::v1::PublicInputs& _internal_public_inputs() const;
  ::aggregator::v1::PublicInputs* _internal_mutable_public_inputs();

  public:
  // uint64 new_batch_num = 5;
  void clear_new_batch_num() ;
  ::uint64_t new_batch_num() const;
  void set_new_batch_num(::uint64_t value);

  private:
  ::uint64_t _internal_new_batch_num() const;
  void _internal_set_new_batch_num(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.PublicInputsExtended)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PublicInputsExtended_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PublicInputsExtended& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_state_root_;
    ::google::protobuf::internal::ArenaStringPtr new_acc_input_hash_;
    ::google::protobuf::internal::ArenaStringPtr new_local_exit_root_;
    ::aggregator::v1::PublicInputs* public_inputs_;
    ::uint64_t new_batch_num_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class InputProver final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.InputProver) */ {
 public:
  inline InputProver() : InputProver(nullptr) {}
  ~InputProver() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputProver(
      ::google::protobuf::internal::ConstantInitialized);

  inline InputProver(const InputProver& from) : InputProver(nullptr, from) {}
  inline InputProver(InputProver&& from) noexcept
      : InputProver(nullptr, std::move(from)) {}
  inline InputProver& operator=(const InputProver& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputProver& operator=(InputProver&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputProver& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputProver* internal_default_instance() {
    return reinterpret_cast<const InputProver*>(
        &_InputProver_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(InputProver& a, InputProver& b) { a.Swap(&b); }
  inline void Swap(InputProver* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputProver* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputProver* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InputProver>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputProver& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputProver& from) { InputProver::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InputProver* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.InputProver"; }

 protected:
  explicit InputProver(::google::protobuf::Arena* arena);
  InputProver(::google::protobuf::Arena* arena, const InputProver& from);
  InputProver(::google::protobuf::Arena* arena, InputProver&& from) noexcept
      : InputProver(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDbFieldNumber = 4,
    kContractsBytecodeFieldNumber = 5,
    kPublicInputsFieldNumber = 1,
  };
  // map<string, string> db = 4;
  int db_size() const;
  private:
  int _internal_db_size() const;

  public:
  void clear_db() ;
  const ::google::protobuf::Map<std::string, std::string>& db() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_db();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_db() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_db();

  public:
  // map<string, string> contracts_bytecode = 5;
  int contracts_bytecode_size() const;
  private:
  int _internal_contracts_bytecode_size() const;

  public:
  void clear_contracts_bytecode() ;
  const ::google::protobuf::Map<std::string, std::string>& contracts_bytecode() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_contracts_bytecode();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_contracts_bytecode() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_contracts_bytecode();

  public:
  // .aggregator.v1.PublicInputs public_inputs = 1;
  bool has_public_inputs() const;
  void clear_public_inputs() ;
  const ::aggregator::v1::PublicInputs& public_inputs() const;
  PROTOBUF_NODISCARD ::aggregator::v1::PublicInputs* release_public_inputs();
  ::aggregator::v1::PublicInputs* mutable_public_inputs();
  void set_allocated_public_inputs(::aggregator::v1::PublicInputs* value);
  void unsafe_arena_set_allocated_public_inputs(::aggregator::v1::PublicInputs* value);
  ::aggregator::v1::PublicInputs* unsafe_arena_release_public_inputs();

  private:
  const ::aggregator::v1::PublicInputs& _internal_public_inputs() const;
  ::aggregator::v1::PublicInputs* _internal_mutable_public_inputs();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.InputProver)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      54, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InputProver_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InputProver& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<InputProver_DbEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        db_;
    ::google::protobuf::internal::MapField<InputProver_ContractsBytecodeEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        contracts_bytecode_;
    ::aggregator::v1::PublicInputs* public_inputs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenStatelessBatchProofRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GenStatelessBatchProofRequest) */ {
 public:
  inline GenStatelessBatchProofRequest() : GenStatelessBatchProofRequest(nullptr) {}
  ~GenStatelessBatchProofRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenStatelessBatchProofRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenStatelessBatchProofRequest(const GenStatelessBatchProofRequest& from) : GenStatelessBatchProofRequest(nullptr, from) {}
  inline GenStatelessBatchProofRequest(GenStatelessBatchProofRequest&& from) noexcept
      : GenStatelessBatchProofRequest(nullptr, std::move(from)) {}
  inline GenStatelessBatchProofRequest& operator=(const GenStatelessBatchProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenStatelessBatchProofRequest& operator=(GenStatelessBatchProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenStatelessBatchProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenStatelessBatchProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenStatelessBatchProofRequest*>(
        &_GenStatelessBatchProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GenStatelessBatchProofRequest& a, GenStatelessBatchProofRequest& b) { a.Swap(&b); }
  inline void Swap(GenStatelessBatchProofRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenStatelessBatchProofRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenStatelessBatchProofRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenStatelessBatchProofRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenStatelessBatchProofRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenStatelessBatchProofRequest& from) { GenStatelessBatchProofRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenStatelessBatchProofRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GenStatelessBatchProofRequest"; }

 protected:
  explicit GenStatelessBatchProofRequest(::google::protobuf::Arena* arena);
  GenStatelessBatchProofRequest(::google::protobuf::Arena* arena, const GenStatelessBatchProofRequest& from);
  GenStatelessBatchProofRequest(::google::protobuf::Arena* arena, GenStatelessBatchProofRequest&& from) noexcept
      : GenStatelessBatchProofRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 1,
  };
  // .aggregator.v1.StatelessInputProver input = 1;
  bool has_input() const;
  void clear_input() ;
  const ::aggregator::v1::StatelessInputProver& input() const;
  PROTOBUF_NODISCARD ::aggregator::v1::StatelessInputProver* release_input();
  ::aggregator::v1::StatelessInputProver* mutable_input();
  void set_allocated_input(::aggregator::v1::StatelessInputProver* value);
  void unsafe_arena_set_allocated_input(::aggregator::v1::StatelessInputProver* value);
  ::aggregator::v1::StatelessInputProver* unsafe_arena_release_input();

  private:
  const ::aggregator::v1::StatelessInputProver& _internal_input() const;
  ::aggregator::v1::StatelessInputProver* _internal_mutable_input();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GenStatelessBatchProofRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenStatelessBatchProofRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenStatelessBatchProofRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::aggregator::v1::StatelessInputProver* input_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GenBatchProofRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GenBatchProofRequest) */ {
 public:
  inline GenBatchProofRequest() : GenBatchProofRequest(nullptr) {}
  ~GenBatchProofRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenBatchProofRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenBatchProofRequest(const GenBatchProofRequest& from) : GenBatchProofRequest(nullptr, from) {}
  inline GenBatchProofRequest(GenBatchProofRequest&& from) noexcept
      : GenBatchProofRequest(nullptr, std::move(from)) {}
  inline GenBatchProofRequest& operator=(const GenBatchProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenBatchProofRequest& operator=(GenBatchProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenBatchProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenBatchProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenBatchProofRequest*>(
        &_GenBatchProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GenBatchProofRequest& a, GenBatchProofRequest& b) { a.Swap(&b); }
  inline void Swap(GenBatchProofRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenBatchProofRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenBatchProofRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenBatchProofRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenBatchProofRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenBatchProofRequest& from) { GenBatchProofRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenBatchProofRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GenBatchProofRequest"; }

 protected:
  explicit GenBatchProofRequest(::google::protobuf::Arena* arena);
  GenBatchProofRequest(::google::protobuf::Arena* arena, const GenBatchProofRequest& from);
  GenBatchProofRequest(::google::protobuf::Arena* arena, GenBatchProofRequest&& from) noexcept
      : GenBatchProofRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 1,
  };
  // .aggregator.v1.InputProver input = 1;
  bool has_input() const;
  void clear_input() ;
  const ::aggregator::v1::InputProver& input() const;
  PROTOBUF_NODISCARD ::aggregator::v1::InputProver* release_input();
  ::aggregator::v1::InputProver* mutable_input();
  void set_allocated_input(::aggregator::v1::InputProver* value);
  void unsafe_arena_set_allocated_input(::aggregator::v1::InputProver* value);
  ::aggregator::v1::InputProver* unsafe_arena_release_input();

  private:
  const ::aggregator::v1::InputProver& _internal_input() const;
  ::aggregator::v1::InputProver* _internal_mutable_input();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.GenBatchProofRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenBatchProofRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenBatchProofRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::aggregator::v1::InputProver* input_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class FinalProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.FinalProof) */ {
 public:
  inline FinalProof() : FinalProof(nullptr) {}
  ~FinalProof() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FinalProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline FinalProof(const FinalProof& from) : FinalProof(nullptr, from) {}
  inline FinalProof(FinalProof&& from) noexcept
      : FinalProof(nullptr, std::move(from)) {}
  inline FinalProof& operator=(const FinalProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalProof& operator=(FinalProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinalProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinalProof* internal_default_instance() {
    return reinterpret_cast<const FinalProof*>(
        &_FinalProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(FinalProof& a, FinalProof& b) { a.Swap(&b); }
  inline void Swap(FinalProof* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinalProof* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<FinalProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FinalProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FinalProof& from) { FinalProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FinalProof* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.FinalProof"; }

 protected:
  explicit FinalProof(::google::protobuf::Arena* arena);
  FinalProof(::google::protobuf::Arena* arena, const FinalProof& from);
  FinalProof(::google::protobuf::Arena* arena, FinalProof&& from) noexcept
      : FinalProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProofFieldNumber = 1,
    kPublicFieldNumber = 2,
  };
  // string proof = 1;
  void clear_proof() ;
  const std::string& proof() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof(Arg_&& arg, Args_... args);
  std::string* mutable_proof();
  PROTOBUF_NODISCARD std::string* release_proof();
  void set_allocated_proof(std::string* value);

  private:
  const std::string& _internal_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof(
      const std::string& value);
  std::string* _internal_mutable_proof();

  public:
  // .aggregator.v1.PublicInputsExtended public = 2;
  bool has_public_() const;
  void clear_public_() ;
  const ::aggregator::v1::PublicInputsExtended& public_() const;
  PROTOBUF_NODISCARD ::aggregator::v1::PublicInputsExtended* release_public_();
  ::aggregator::v1::PublicInputsExtended* mutable_public_();
  void set_allocated_public_(::aggregator::v1::PublicInputsExtended* value);
  void unsafe_arena_set_allocated_public_(::aggregator::v1::PublicInputsExtended* value);
  ::aggregator::v1::PublicInputsExtended* unsafe_arena_release_public_();

  private:
  const ::aggregator::v1::PublicInputsExtended& _internal_public_() const;
  ::aggregator::v1::PublicInputsExtended* _internal_mutable_public_();

  public:
  // @@protoc_insertion_point(class_scope:aggregator.v1.FinalProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FinalProof_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FinalProof& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr proof_;
    ::aggregator::v1::PublicInputsExtended* public__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class GetProofResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.GetProofResponse) */ {
 public:
  inline GetProofResponse() : GetProofResponse(nullptr) {}
  ~GetProofResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetProofResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetProofResponse(const GetProofResponse& from) : GetProofResponse(nullptr, from) {}
  inline GetProofResponse(GetProofResponse&& from) noexcept
      : GetProofResponse(nullptr, std::move(from)) {}
  inline GetProofResponse& operator=(const GetProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProofResponse& operator=(GetProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProofResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kFinalProof = 2,
    kRecursiveProof = 3,
    PROOF_NOT_SET = 0,
  };
  static inline const GetProofResponse* internal_default_instance() {
    return reinterpret_cast<const GetProofResponse*>(
        &_GetProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetProofResponse& a, GetProofResponse& b) { a.Swap(&b); }
  inline void Swap(GetProofResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProofResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProofResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetProofResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProofResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetProofResponse& from) { GetProofResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetProofResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.GetProofResponse"; }

 protected:
  explicit GetProofResponse(::google::protobuf::Arena* arena);
  GetProofResponse(::google::protobuf::Arena* arena, const GetProofResponse& from);
  GetProofResponse(::google::protobuf::Arena* arena, GetProofResponse&& from) noexcept
      : GetProofResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Result = GetProofResponse_Result;
  static constexpr Result RESULT_UNSPECIFIED = GetProofResponse_Result_RESULT_UNSPECIFIED;
  static constexpr Result RESULT_COMPLETED_OK = GetProofResponse_Result_RESULT_COMPLETED_OK;
  static constexpr Result RESULT_ERROR = GetProofResponse_Result_RESULT_ERROR;
  static constexpr Result RESULT_COMPLETED_ERROR = GetProofResponse_Result_RESULT_COMPLETED_ERROR;
  static constexpr Result RESULT_PENDING = GetProofResponse_Result_RESULT_PENDING;
  static constexpr Result RESULT_INTERNAL_ERROR = GetProofResponse_Result_RESULT_INTERNAL_ERROR;
  static constexpr Result RESULT_CANCEL = GetProofResponse_Result_RESULT_CANCEL;
  static inline bool Result_IsValid(int value) {
    return GetProofResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = GetProofResponse_Result_Result_MIN;
  static constexpr Result Result_MAX = GetProofResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = GetProofResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Result_descriptor() {
    return GetProofResponse_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return GetProofResponse_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return GetProofResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kResultStringFieldNumber = 5,
    kResultFieldNumber = 4,
    kFinalProofFieldNumber = 2,
    kRecursiveProofFieldNumber = 3,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string result_string = 5;
  void clear_result_string() ;
  const std::string& result_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_string(Arg_&& arg, Args_... args);
  std::string* mutable_result_string();
  PROTOBUF_NODISCARD std::string* release_result_string();
  void set_allocated_result_string(std::string* value);

  private:
  const std::string& _internal_result_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_string(
      const std::string& value);
  std::string* _internal_mutable_result_string();

  public:
  // .aggregator.v1.GetProofResponse.Result result = 4;
  void clear_result() ;
  ::aggregator::v1::GetProofResponse_Result result() const;
  void set_result(::aggregator::v1::GetProofResponse_Result value);

  private:
  ::aggregator::v1::GetProofResponse_Result _internal_result() const;
  void _internal_set_result(::aggregator::v1::GetProofResponse_Result value);

  public:
  // .aggregator.v1.FinalProof final_proof = 2;
  bool has_final_proof() const;
  private:
  bool _internal_has_final_proof() const;

  public:
  void clear_final_proof() ;
  const ::aggregator::v1::FinalProof& final_proof() const;
  PROTOBUF_NODISCARD ::aggregator::v1::FinalProof* release_final_proof();
  ::aggregator::v1::FinalProof* mutable_final_proof();
  void set_allocated_final_proof(::aggregator::v1::FinalProof* value);
  void unsafe_arena_set_allocated_final_proof(::aggregator::v1::FinalProof* value);
  ::aggregator::v1::FinalProof* unsafe_arena_release_final_proof();

  private:
  const ::aggregator::v1::FinalProof& _internal_final_proof() const;
  ::aggregator::v1::FinalProof* _internal_mutable_final_proof();

  public:
  // string recursive_proof = 3;
  bool has_recursive_proof() const;
  void clear_recursive_proof() ;
  const std::string& recursive_proof() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recursive_proof(Arg_&& arg, Args_... args);
  std::string* mutable_recursive_proof();
  PROTOBUF_NODISCARD std::string* release_recursive_proof();
  void set_allocated_recursive_proof(std::string* value);

  private:
  const std::string& _internal_recursive_proof() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recursive_proof(
      const std::string& value);
  std::string* _internal_mutable_recursive_proof();

  public:
  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:aggregator.v1.GetProofResponse)
 private:
  class _Internal;
  void set_has_final_proof();
  void set_has_recursive_proof();
  inline bool has_proof() const;
  inline void clear_has_proof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      69, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetProofResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetProofResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr result_string_;
    int result_;
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::aggregator::v1::FinalProof* final_proof_;
      ::google::protobuf::internal::ArenaStringPtr recursive_proof_;
    } proof_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class AggregatorMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.AggregatorMessage) */ {
 public:
  inline AggregatorMessage() : AggregatorMessage(nullptr) {}
  ~AggregatorMessage() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AggregatorMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AggregatorMessage(const AggregatorMessage& from) : AggregatorMessage(nullptr, from) {}
  inline AggregatorMessage(AggregatorMessage&& from) noexcept
      : AggregatorMessage(nullptr, std::move(from)) {}
  inline AggregatorMessage& operator=(const AggregatorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregatorMessage& operator=(AggregatorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregatorMessage& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kGetStatusRequest = 2,
    kGenBatchProofRequest = 3,
    kGenAggregatedProofRequest = 4,
    kGenFinalProofRequest = 5,
    kCancelRequest = 6,
    kGetProofRequest = 7,
    kGenStatelessBatchProofRequest = 8,
    REQUEST_NOT_SET = 0,
  };
  static inline const AggregatorMessage* internal_default_instance() {
    return reinterpret_cast<const AggregatorMessage*>(
        &_AggregatorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(AggregatorMessage& a, AggregatorMessage& b) { a.Swap(&b); }
  inline void Swap(AggregatorMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregatorMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregatorMessage* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AggregatorMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregatorMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AggregatorMessage& from) { AggregatorMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggregatorMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.AggregatorMessage"; }

 protected:
  explicit AggregatorMessage(::google::protobuf::Arena* arena);
  AggregatorMessage(::google::protobuf::Arena* arena, const AggregatorMessage& from);
  AggregatorMessage(::google::protobuf::Arena* arena, AggregatorMessage&& from) noexcept
      : AggregatorMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kGetStatusRequestFieldNumber = 2,
    kGenBatchProofRequestFieldNumber = 3,
    kGenAggregatedProofRequestFieldNumber = 4,
    kGenFinalProofRequestFieldNumber = 5,
    kCancelRequestFieldNumber = 6,
    kGetProofRequestFieldNumber = 7,
    kGenStatelessBatchProofRequestFieldNumber = 8,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .aggregator.v1.GetStatusRequest get_status_request = 2;
  bool has_get_status_request() const;
  private:
  bool _internal_has_get_status_request() const;

  public:
  void clear_get_status_request() ;
  const ::aggregator::v1::GetStatusRequest& get_status_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetStatusRequest* release_get_status_request();
  ::aggregator::v1::GetStatusRequest* mutable_get_status_request();
  void set_allocated_get_status_request(::aggregator::v1::GetStatusRequest* value);
  void unsafe_arena_set_allocated_get_status_request(::aggregator::v1::GetStatusRequest* value);
  ::aggregator::v1::GetStatusRequest* unsafe_arena_release_get_status_request();

  private:
  const ::aggregator::v1::GetStatusRequest& _internal_get_status_request() const;
  ::aggregator::v1::GetStatusRequest* _internal_mutable_get_status_request();

  public:
  // .aggregator.v1.GenBatchProofRequest gen_batch_proof_request = 3;
  bool has_gen_batch_proof_request() const;
  private:
  bool _internal_has_gen_batch_proof_request() const;

  public:
  void clear_gen_batch_proof_request() ;
  const ::aggregator::v1::GenBatchProofRequest& gen_batch_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenBatchProofRequest* release_gen_batch_proof_request();
  ::aggregator::v1::GenBatchProofRequest* mutable_gen_batch_proof_request();
  void set_allocated_gen_batch_proof_request(::aggregator::v1::GenBatchProofRequest* value);
  void unsafe_arena_set_allocated_gen_batch_proof_request(::aggregator::v1::GenBatchProofRequest* value);
  ::aggregator::v1::GenBatchProofRequest* unsafe_arena_release_gen_batch_proof_request();

  private:
  const ::aggregator::v1::GenBatchProofRequest& _internal_gen_batch_proof_request() const;
  ::aggregator::v1::GenBatchProofRequest* _internal_mutable_gen_batch_proof_request();

  public:
  // .aggregator.v1.GenAggregatedProofRequest gen_aggregated_proof_request = 4;
  bool has_gen_aggregated_proof_request() const;
  private:
  bool _internal_has_gen_aggregated_proof_request() const;

  public:
  void clear_gen_aggregated_proof_request() ;
  const ::aggregator::v1::GenAggregatedProofRequest& gen_aggregated_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenAggregatedProofRequest* release_gen_aggregated_proof_request();
  ::aggregator::v1::GenAggregatedProofRequest* mutable_gen_aggregated_proof_request();
  void set_allocated_gen_aggregated_proof_request(::aggregator::v1::GenAggregatedProofRequest* value);
  void unsafe_arena_set_allocated_gen_aggregated_proof_request(::aggregator::v1::GenAggregatedProofRequest* value);
  ::aggregator::v1::GenAggregatedProofRequest* unsafe_arena_release_gen_aggregated_proof_request();

  private:
  const ::aggregator::v1::GenAggregatedProofRequest& _internal_gen_aggregated_proof_request() const;
  ::aggregator::v1::GenAggregatedProofRequest* _internal_mutable_gen_aggregated_proof_request();

  public:
  // .aggregator.v1.GenFinalProofRequest gen_final_proof_request = 5;
  bool has_gen_final_proof_request() const;
  private:
  bool _internal_has_gen_final_proof_request() const;

  public:
  void clear_gen_final_proof_request() ;
  const ::aggregator::v1::GenFinalProofRequest& gen_final_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenFinalProofRequest* release_gen_final_proof_request();
  ::aggregator::v1::GenFinalProofRequest* mutable_gen_final_proof_request();
  void set_allocated_gen_final_proof_request(::aggregator::v1::GenFinalProofRequest* value);
  void unsafe_arena_set_allocated_gen_final_proof_request(::aggregator::v1::GenFinalProofRequest* value);
  ::aggregator::v1::GenFinalProofRequest* unsafe_arena_release_gen_final_proof_request();

  private:
  const ::aggregator::v1::GenFinalProofRequest& _internal_gen_final_proof_request() const;
  ::aggregator::v1::GenFinalProofRequest* _internal_mutable_gen_final_proof_request();

  public:
  // .aggregator.v1.CancelRequest cancel_request = 6;
  bool has_cancel_request() const;
  private:
  bool _internal_has_cancel_request() const;

  public:
  void clear_cancel_request() ;
  const ::aggregator::v1::CancelRequest& cancel_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::CancelRequest* release_cancel_request();
  ::aggregator::v1::CancelRequest* mutable_cancel_request();
  void set_allocated_cancel_request(::aggregator::v1::CancelRequest* value);
  void unsafe_arena_set_allocated_cancel_request(::aggregator::v1::CancelRequest* value);
  ::aggregator::v1::CancelRequest* unsafe_arena_release_cancel_request();

  private:
  const ::aggregator::v1::CancelRequest& _internal_cancel_request() const;
  ::aggregator::v1::CancelRequest* _internal_mutable_cancel_request();

  public:
  // .aggregator.v1.GetProofRequest get_proof_request = 7;
  bool has_get_proof_request() const;
  private:
  bool _internal_has_get_proof_request() const;

  public:
  void clear_get_proof_request() ;
  const ::aggregator::v1::GetProofRequest& get_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetProofRequest* release_get_proof_request();
  ::aggregator::v1::GetProofRequest* mutable_get_proof_request();
  void set_allocated_get_proof_request(::aggregator::v1::GetProofRequest* value);
  void unsafe_arena_set_allocated_get_proof_request(::aggregator::v1::GetProofRequest* value);
  ::aggregator::v1::GetProofRequest* unsafe_arena_release_get_proof_request();

  private:
  const ::aggregator::v1::GetProofRequest& _internal_get_proof_request() const;
  ::aggregator::v1::GetProofRequest* _internal_mutable_get_proof_request();

  public:
  // .aggregator.v1.GenStatelessBatchProofRequest gen_stateless_batch_proof_request = 8;
  bool has_gen_stateless_batch_proof_request() const;
  private:
  bool _internal_has_gen_stateless_batch_proof_request() const;

  public:
  void clear_gen_stateless_batch_proof_request() ;
  const ::aggregator::v1::GenStatelessBatchProofRequest& gen_stateless_batch_proof_request() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenStatelessBatchProofRequest* release_gen_stateless_batch_proof_request();
  ::aggregator::v1::GenStatelessBatchProofRequest* mutable_gen_stateless_batch_proof_request();
  void set_allocated_gen_stateless_batch_proof_request(::aggregator::v1::GenStatelessBatchProofRequest* value);
  void unsafe_arena_set_allocated_gen_stateless_batch_proof_request(::aggregator::v1::GenStatelessBatchProofRequest* value);
  ::aggregator::v1::GenStatelessBatchProofRequest* unsafe_arena_release_gen_stateless_batch_proof_request();

  private:
  const ::aggregator::v1::GenStatelessBatchProofRequest& _internal_gen_stateless_batch_proof_request() const;
  ::aggregator::v1::GenStatelessBatchProofRequest* _internal_mutable_gen_stateless_batch_proof_request();

  public:
  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:aggregator.v1.AggregatorMessage)
 private:
  class _Internal;
  void set_has_get_status_request();
  void set_has_gen_batch_proof_request();
  void set_has_gen_aggregated_proof_request();
  void set_has_gen_final_proof_request();
  void set_has_cancel_request();
  void set_has_get_proof_request();
  void set_has_gen_stateless_batch_proof_request();
  inline bool has_request() const;
  inline void clear_has_request();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 7,
      50, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AggregatorMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AggregatorMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::aggregator::v1::GetStatusRequest* get_status_request_;
      ::aggregator::v1::GenBatchProofRequest* gen_batch_proof_request_;
      ::aggregator::v1::GenAggregatedProofRequest* gen_aggregated_proof_request_;
      ::aggregator::v1::GenFinalProofRequest* gen_final_proof_request_;
      ::aggregator::v1::CancelRequest* cancel_request_;
      ::aggregator::v1::GetProofRequest* get_proof_request_;
      ::aggregator::v1::GenStatelessBatchProofRequest* gen_stateless_batch_proof_request_;
    } request_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};
// -------------------------------------------------------------------

class ProverMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:aggregator.v1.ProverMessage) */ {
 public:
  inline ProverMessage() : ProverMessage(nullptr) {}
  ~ProverMessage() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProverMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProverMessage(const ProverMessage& from) : ProverMessage(nullptr, from) {}
  inline ProverMessage(ProverMessage&& from) noexcept
      : ProverMessage(nullptr, std::move(from)) {}
  inline ProverMessage& operator=(const ProverMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProverMessage& operator=(ProverMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProverMessage& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kGetStatusResponse = 2,
    kGenBatchProofResponse = 3,
    kGenAggregatedProofResponse = 4,
    kGenFinalProofResponse = 5,
    kCancelResponse = 6,
    kGetProofResponse = 7,
    RESPONSE_NOT_SET = 0,
  };
  static inline const ProverMessage* internal_default_instance() {
    return reinterpret_cast<const ProverMessage*>(
        &_ProverMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ProverMessage& a, ProverMessage& b) { a.Swap(&b); }
  inline void Swap(ProverMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProverMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProverMessage* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ProverMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProverMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProverMessage& from) { ProverMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProverMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "aggregator.v1.ProverMessage"; }

 protected:
  explicit ProverMessage(::google::protobuf::Arena* arena);
  ProverMessage(::google::protobuf::Arena* arena, const ProverMessage& from);
  ProverMessage(::google::protobuf::Arena* arena, ProverMessage&& from) noexcept
      : ProverMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kGetStatusResponseFieldNumber = 2,
    kGenBatchProofResponseFieldNumber = 3,
    kGenAggregatedProofResponseFieldNumber = 4,
    kGenFinalProofResponseFieldNumber = 5,
    kCancelResponseFieldNumber = 6,
    kGetProofResponseFieldNumber = 7,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .aggregator.v1.GetStatusResponse get_status_response = 2;
  bool has_get_status_response() const;
  private:
  bool _internal_has_get_status_response() const;

  public:
  void clear_get_status_response() ;
  const ::aggregator::v1::GetStatusResponse& get_status_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetStatusResponse* release_get_status_response();
  ::aggregator::v1::GetStatusResponse* mutable_get_status_response();
  void set_allocated_get_status_response(::aggregator::v1::GetStatusResponse* value);
  void unsafe_arena_set_allocated_get_status_response(::aggregator::v1::GetStatusResponse* value);
  ::aggregator::v1::GetStatusResponse* unsafe_arena_release_get_status_response();

  private:
  const ::aggregator::v1::GetStatusResponse& _internal_get_status_response() const;
  ::aggregator::v1::GetStatusResponse* _internal_mutable_get_status_response();

  public:
  // .aggregator.v1.GenBatchProofResponse gen_batch_proof_response = 3;
  bool has_gen_batch_proof_response() const;
  private:
  bool _internal_has_gen_batch_proof_response() const;

  public:
  void clear_gen_batch_proof_response() ;
  const ::aggregator::v1::GenBatchProofResponse& gen_batch_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenBatchProofResponse* release_gen_batch_proof_response();
  ::aggregator::v1::GenBatchProofResponse* mutable_gen_batch_proof_response();
  void set_allocated_gen_batch_proof_response(::aggregator::v1::GenBatchProofResponse* value);
  void unsafe_arena_set_allocated_gen_batch_proof_response(::aggregator::v1::GenBatchProofResponse* value);
  ::aggregator::v1::GenBatchProofResponse* unsafe_arena_release_gen_batch_proof_response();

  private:
  const ::aggregator::v1::GenBatchProofResponse& _internal_gen_batch_proof_response() const;
  ::aggregator::v1::GenBatchProofResponse* _internal_mutable_gen_batch_proof_response();

  public:
  // .aggregator.v1.GenAggregatedProofResponse gen_aggregated_proof_response = 4;
  bool has_gen_aggregated_proof_response() const;
  private:
  bool _internal_has_gen_aggregated_proof_response() const;

  public:
  void clear_gen_aggregated_proof_response() ;
  const ::aggregator::v1::GenAggregatedProofResponse& gen_aggregated_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenAggregatedProofResponse* release_gen_aggregated_proof_response();
  ::aggregator::v1::GenAggregatedProofResponse* mutable_gen_aggregated_proof_response();
  void set_allocated_gen_aggregated_proof_response(::aggregator::v1::GenAggregatedProofResponse* value);
  void unsafe_arena_set_allocated_gen_aggregated_proof_response(::aggregator::v1::GenAggregatedProofResponse* value);
  ::aggregator::v1::GenAggregatedProofResponse* unsafe_arena_release_gen_aggregated_proof_response();

  private:
  const ::aggregator::v1::GenAggregatedProofResponse& _internal_gen_aggregated_proof_response() const;
  ::aggregator::v1::GenAggregatedProofResponse* _internal_mutable_gen_aggregated_proof_response();

  public:
  // .aggregator.v1.GenFinalProofResponse gen_final_proof_response = 5;
  bool has_gen_final_proof_response() const;
  private:
  bool _internal_has_gen_final_proof_response() const;

  public:
  void clear_gen_final_proof_response() ;
  const ::aggregator::v1::GenFinalProofResponse& gen_final_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GenFinalProofResponse* release_gen_final_proof_response();
  ::aggregator::v1::GenFinalProofResponse* mutable_gen_final_proof_response();
  void set_allocated_gen_final_proof_response(::aggregator::v1::GenFinalProofResponse* value);
  void unsafe_arena_set_allocated_gen_final_proof_response(::aggregator::v1::GenFinalProofResponse* value);
  ::aggregator::v1::GenFinalProofResponse* unsafe_arena_release_gen_final_proof_response();

  private:
  const ::aggregator::v1::GenFinalProofResponse& _internal_gen_final_proof_response() const;
  ::aggregator::v1::GenFinalProofResponse* _internal_mutable_gen_final_proof_response();

  public:
  // .aggregator.v1.CancelResponse cancel_response = 6;
  bool has_cancel_response() const;
  private:
  bool _internal_has_cancel_response() const;

  public:
  void clear_cancel_response() ;
  const ::aggregator::v1::CancelResponse& cancel_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::CancelResponse* release_cancel_response();
  ::aggregator::v1::CancelResponse* mutable_cancel_response();
  void set_allocated_cancel_response(::aggregator::v1::CancelResponse* value);
  void unsafe_arena_set_allocated_cancel_response(::aggregator::v1::CancelResponse* value);
  ::aggregator::v1::CancelResponse* unsafe_arena_release_cancel_response();

  private:
  const ::aggregator::v1::CancelResponse& _internal_cancel_response() const;
  ::aggregator::v1::CancelResponse* _internal_mutable_cancel_response();

  public:
  // .aggregator.v1.GetProofResponse get_proof_response = 7;
  bool has_get_proof_response() const;
  private:
  bool _internal_has_get_proof_response() const;

  public:
  void clear_get_proof_response() ;
  const ::aggregator::v1::GetProofResponse& get_proof_response() const;
  PROTOBUF_NODISCARD ::aggregator::v1::GetProofResponse* release_get_proof_response();
  ::aggregator::v1::GetProofResponse* mutable_get_proof_response();
  void set_allocated_get_proof_response(::aggregator::v1::GetProofResponse* value);
  void unsafe_arena_set_allocated_get_proof_response(::aggregator::v1::GetProofResponse* value);
  ::aggregator::v1::GetProofResponse* unsafe_arena_release_get_proof_response();

  private:
  const ::aggregator::v1::GetProofResponse& _internal_get_proof_response() const;
  ::aggregator::v1::GetProofResponse* _internal_mutable_get_proof_response();

  public:
  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:aggregator.v1.ProverMessage)
 private:
  class _Internal;
  void set_has_get_status_response();
  void set_has_gen_batch_proof_response();
  void set_has_gen_aggregated_proof_response();
  void set_has_gen_final_proof_response();
  void set_has_cancel_response();
  void set_has_get_proof_response();
  inline bool has_response() const;
  inline void clear_has_response();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 6,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ProverMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ProverMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::aggregator::v1::GetStatusResponse* get_status_response_;
      ::aggregator::v1::GenBatchProofResponse* gen_batch_proof_response_;
      ::aggregator::v1::GenAggregatedProofResponse* gen_aggregated_proof_response_;
      ::aggregator::v1::GenFinalProofResponse* gen_final_proof_response_;
      ::aggregator::v1::CancelResponse* cancel_response_;
      ::aggregator::v1::GetProofResponse* get_proof_response_;
    } response_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_aggregator_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Version

// string v0_0_1 = 1;
inline void Version::clear_v0_0_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.v0_0_1_.ClearToEmpty();
}
inline const std::string& Version::v0_0_1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.Version.v0_0_1)
  return _internal_v0_0_1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Version::set_v0_0_1(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.v0_0_1_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.Version.v0_0_1)
}
inline std::string* Version::mutable_v0_0_1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_v0_0_1();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.Version.v0_0_1)
  return _s;
}
inline const std::string& Version::_internal_v0_0_1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.v0_0_1_.Get();
}
inline void Version::_internal_set_v0_0_1(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.v0_0_1_.Set(value, GetArena());
}
inline std::string* Version::_internal_mutable_v0_0_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.v0_0_1_.Mutable( GetArena());
}
inline std::string* Version::release_v0_0_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.Version.v0_0_1)
  return _impl_.v0_0_1_.Release();
}
inline void Version::set_allocated_v0_0_1(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.v0_0_1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.v0_0_1_.IsDefault()) {
          _impl_.v0_0_1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.Version.v0_0_1)
}

// -------------------------------------------------------------------

// AggregatorMessage

// string id = 1;
inline void AggregatorMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AggregatorMessage::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggregatorMessage::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.AggregatorMessage.id)
}
inline std::string* AggregatorMessage::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.id)
  return _s;
}
inline const std::string& AggregatorMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void AggregatorMessage::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* AggregatorMessage::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* AggregatorMessage::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.id)
  return _impl_.id_.Release();
}
inline void AggregatorMessage::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.AggregatorMessage.id)
}

// .aggregator.v1.GetStatusRequest get_status_request = 2;
inline bool AggregatorMessage::has_get_status_request() const {
  return request_case() == kGetStatusRequest;
}
inline bool AggregatorMessage::_internal_has_get_status_request() const {
  return request_case() == kGetStatusRequest;
}
inline void AggregatorMessage::set_has_get_status_request() {
  _impl_._oneof_case_[0] = kGetStatusRequest;
}
inline void AggregatorMessage::clear_get_status_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kGetStatusRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.get_status_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.get_status_request_);
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::release_get_status_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.get_status_request)
  if (request_case() == kGetStatusRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.get_status_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.get_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetStatusRequest& AggregatorMessage::_internal_get_status_request() const {
  return request_case() == kGetStatusRequest ? *_impl_.request_.get_status_request_ : reinterpret_cast<::aggregator::v1::GetStatusRequest&>(::aggregator::v1::_GetStatusRequest_default_instance_);
}
inline const ::aggregator::v1::GetStatusRequest& AggregatorMessage::get_status_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.get_status_request)
  return _internal_get_status_request();
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::unsafe_arena_release_get_status_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.get_status_request)
  if (request_case() == kGetStatusRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.get_status_request_;
    _impl_.request_.get_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_get_status_request(::aggregator::v1::GetStatusRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_get_status_request();
    _impl_.request_.get_status_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.get_status_request)
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::_internal_mutable_get_status_request() {
  if (request_case() != kGetStatusRequest) {
    clear_request();
    set_has_get_status_request();
    _impl_.request_.get_status_request_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GetStatusRequest>(GetArena());
  }
  return _impl_.request_.get_status_request_;
}
inline ::aggregator::v1::GetStatusRequest* AggregatorMessage::mutable_get_status_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GetStatusRequest* _msg = _internal_mutable_get_status_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.get_status_request)
  return _msg;
}

// .aggregator.v1.GenBatchProofRequest gen_batch_proof_request = 3;
inline bool AggregatorMessage::has_gen_batch_proof_request() const {
  return request_case() == kGenBatchProofRequest;
}
inline bool AggregatorMessage::_internal_has_gen_batch_proof_request() const {
  return request_case() == kGenBatchProofRequest;
}
inline void AggregatorMessage::set_has_gen_batch_proof_request() {
  _impl_._oneof_case_[0] = kGenBatchProofRequest;
}
inline void AggregatorMessage::clear_gen_batch_proof_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kGenBatchProofRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.gen_batch_proof_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.gen_batch_proof_request_);
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::release_gen_batch_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  if (request_case() == kGenBatchProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_batch_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.gen_batch_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenBatchProofRequest& AggregatorMessage::_internal_gen_batch_proof_request() const {
  return request_case() == kGenBatchProofRequest ? *_impl_.request_.gen_batch_proof_request_ : reinterpret_cast<::aggregator::v1::GenBatchProofRequest&>(::aggregator::v1::_GenBatchProofRequest_default_instance_);
}
inline const ::aggregator::v1::GenBatchProofRequest& AggregatorMessage::gen_batch_proof_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  return _internal_gen_batch_proof_request();
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::unsafe_arena_release_gen_batch_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  if (request_case() == kGenBatchProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_batch_proof_request_;
    _impl_.request_.gen_batch_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_gen_batch_proof_request(::aggregator::v1::GenBatchProofRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_gen_batch_proof_request();
    _impl_.request_.gen_batch_proof_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::_internal_mutable_gen_batch_proof_request() {
  if (request_case() != kGenBatchProofRequest) {
    clear_request();
    set_has_gen_batch_proof_request();
    _impl_.request_.gen_batch_proof_request_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GenBatchProofRequest>(GetArena());
  }
  return _impl_.request_.gen_batch_proof_request_;
}
inline ::aggregator::v1::GenBatchProofRequest* AggregatorMessage::mutable_gen_batch_proof_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GenBatchProofRequest* _msg = _internal_mutable_gen_batch_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.gen_batch_proof_request)
  return _msg;
}

// .aggregator.v1.GenAggregatedProofRequest gen_aggregated_proof_request = 4;
inline bool AggregatorMessage::has_gen_aggregated_proof_request() const {
  return request_case() == kGenAggregatedProofRequest;
}
inline bool AggregatorMessage::_internal_has_gen_aggregated_proof_request() const {
  return request_case() == kGenAggregatedProofRequest;
}
inline void AggregatorMessage::set_has_gen_aggregated_proof_request() {
  _impl_._oneof_case_[0] = kGenAggregatedProofRequest;
}
inline void AggregatorMessage::clear_gen_aggregated_proof_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kGenAggregatedProofRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.gen_aggregated_proof_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.gen_aggregated_proof_request_);
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::release_gen_aggregated_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  if (request_case() == kGenAggregatedProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_aggregated_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.gen_aggregated_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenAggregatedProofRequest& AggregatorMessage::_internal_gen_aggregated_proof_request() const {
  return request_case() == kGenAggregatedProofRequest ? *_impl_.request_.gen_aggregated_proof_request_ : reinterpret_cast<::aggregator::v1::GenAggregatedProofRequest&>(::aggregator::v1::_GenAggregatedProofRequest_default_instance_);
}
inline const ::aggregator::v1::GenAggregatedProofRequest& AggregatorMessage::gen_aggregated_proof_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  return _internal_gen_aggregated_proof_request();
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::unsafe_arena_release_gen_aggregated_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  if (request_case() == kGenAggregatedProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_aggregated_proof_request_;
    _impl_.request_.gen_aggregated_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_gen_aggregated_proof_request(::aggregator::v1::GenAggregatedProofRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_gen_aggregated_proof_request();
    _impl_.request_.gen_aggregated_proof_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::_internal_mutable_gen_aggregated_proof_request() {
  if (request_case() != kGenAggregatedProofRequest) {
    clear_request();
    set_has_gen_aggregated_proof_request();
    _impl_.request_.gen_aggregated_proof_request_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GenAggregatedProofRequest>(GetArena());
  }
  return _impl_.request_.gen_aggregated_proof_request_;
}
inline ::aggregator::v1::GenAggregatedProofRequest* AggregatorMessage::mutable_gen_aggregated_proof_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GenAggregatedProofRequest* _msg = _internal_mutable_gen_aggregated_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.gen_aggregated_proof_request)
  return _msg;
}

// .aggregator.v1.GenFinalProofRequest gen_final_proof_request = 5;
inline bool AggregatorMessage::has_gen_final_proof_request() const {
  return request_case() == kGenFinalProofRequest;
}
inline bool AggregatorMessage::_internal_has_gen_final_proof_request() const {
  return request_case() == kGenFinalProofRequest;
}
inline void AggregatorMessage::set_has_gen_final_proof_request() {
  _impl_._oneof_case_[0] = kGenFinalProofRequest;
}
inline void AggregatorMessage::clear_gen_final_proof_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kGenFinalProofRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.gen_final_proof_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.gen_final_proof_request_);
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::release_gen_final_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  if (request_case() == kGenFinalProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_final_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.gen_final_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenFinalProofRequest& AggregatorMessage::_internal_gen_final_proof_request() const {
  return request_case() == kGenFinalProofRequest ? *_impl_.request_.gen_final_proof_request_ : reinterpret_cast<::aggregator::v1::GenFinalProofRequest&>(::aggregator::v1::_GenFinalProofRequest_default_instance_);
}
inline const ::aggregator::v1::GenFinalProofRequest& AggregatorMessage::gen_final_proof_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  return _internal_gen_final_proof_request();
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::unsafe_arena_release_gen_final_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  if (request_case() == kGenFinalProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_final_proof_request_;
    _impl_.request_.gen_final_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_gen_final_proof_request(::aggregator::v1::GenFinalProofRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_gen_final_proof_request();
    _impl_.request_.gen_final_proof_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.gen_final_proof_request)
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::_internal_mutable_gen_final_proof_request() {
  if (request_case() != kGenFinalProofRequest) {
    clear_request();
    set_has_gen_final_proof_request();
    _impl_.request_.gen_final_proof_request_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GenFinalProofRequest>(GetArena());
  }
  return _impl_.request_.gen_final_proof_request_;
}
inline ::aggregator::v1::GenFinalProofRequest* AggregatorMessage::mutable_gen_final_proof_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GenFinalProofRequest* _msg = _internal_mutable_gen_final_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.gen_final_proof_request)
  return _msg;
}

// .aggregator.v1.CancelRequest cancel_request = 6;
inline bool AggregatorMessage::has_cancel_request() const {
  return request_case() == kCancelRequest;
}
inline bool AggregatorMessage::_internal_has_cancel_request() const {
  return request_case() == kCancelRequest;
}
inline void AggregatorMessage::set_has_cancel_request() {
  _impl_._oneof_case_[0] = kCancelRequest;
}
inline void AggregatorMessage::clear_cancel_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kCancelRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.cancel_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.cancel_request_);
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::release_cancel_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.cancel_request)
  if (request_case() == kCancelRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.cancel_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::CancelRequest& AggregatorMessage::_internal_cancel_request() const {
  return request_case() == kCancelRequest ? *_impl_.request_.cancel_request_ : reinterpret_cast<::aggregator::v1::CancelRequest&>(::aggregator::v1::_CancelRequest_default_instance_);
}
inline const ::aggregator::v1::CancelRequest& AggregatorMessage::cancel_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.cancel_request)
  return _internal_cancel_request();
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::unsafe_arena_release_cancel_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.cancel_request)
  if (request_case() == kCancelRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.cancel_request_;
    _impl_.request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_cancel_request(::aggregator::v1::CancelRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_cancel_request();
    _impl_.request_.cancel_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.cancel_request)
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::_internal_mutable_cancel_request() {
  if (request_case() != kCancelRequest) {
    clear_request();
    set_has_cancel_request();
    _impl_.request_.cancel_request_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::CancelRequest>(GetArena());
  }
  return _impl_.request_.cancel_request_;
}
inline ::aggregator::v1::CancelRequest* AggregatorMessage::mutable_cancel_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::CancelRequest* _msg = _internal_mutable_cancel_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.cancel_request)
  return _msg;
}

// .aggregator.v1.GetProofRequest get_proof_request = 7;
inline bool AggregatorMessage::has_get_proof_request() const {
  return request_case() == kGetProofRequest;
}
inline bool AggregatorMessage::_internal_has_get_proof_request() const {
  return request_case() == kGetProofRequest;
}
inline void AggregatorMessage::set_has_get_proof_request() {
  _impl_._oneof_case_[0] = kGetProofRequest;
}
inline void AggregatorMessage::clear_get_proof_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kGetProofRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.get_proof_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.get_proof_request_);
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::release_get_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.get_proof_request)
  if (request_case() == kGetProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.get_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.get_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetProofRequest& AggregatorMessage::_internal_get_proof_request() const {
  return request_case() == kGetProofRequest ? *_impl_.request_.get_proof_request_ : reinterpret_cast<::aggregator::v1::GetProofRequest&>(::aggregator::v1::_GetProofRequest_default_instance_);
}
inline const ::aggregator::v1::GetProofRequest& AggregatorMessage::get_proof_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.get_proof_request)
  return _internal_get_proof_request();
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::unsafe_arena_release_get_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.get_proof_request)
  if (request_case() == kGetProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.get_proof_request_;
    _impl_.request_.get_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_get_proof_request(::aggregator::v1::GetProofRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_get_proof_request();
    _impl_.request_.get_proof_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.get_proof_request)
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::_internal_mutable_get_proof_request() {
  if (request_case() != kGetProofRequest) {
    clear_request();
    set_has_get_proof_request();
    _impl_.request_.get_proof_request_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GetProofRequest>(GetArena());
  }
  return _impl_.request_.get_proof_request_;
}
inline ::aggregator::v1::GetProofRequest* AggregatorMessage::mutable_get_proof_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GetProofRequest* _msg = _internal_mutable_get_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.get_proof_request)
  return _msg;
}

// .aggregator.v1.GenStatelessBatchProofRequest gen_stateless_batch_proof_request = 8;
inline bool AggregatorMessage::has_gen_stateless_batch_proof_request() const {
  return request_case() == kGenStatelessBatchProofRequest;
}
inline bool AggregatorMessage::_internal_has_gen_stateless_batch_proof_request() const {
  return request_case() == kGenStatelessBatchProofRequest;
}
inline void AggregatorMessage::set_has_gen_stateless_batch_proof_request() {
  _impl_._oneof_case_[0] = kGenStatelessBatchProofRequest;
}
inline void AggregatorMessage::clear_gen_stateless_batch_proof_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (request_case() == kGenStatelessBatchProofRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.request_.gen_stateless_batch_proof_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.request_.gen_stateless_batch_proof_request_);
    }
    clear_has_request();
  }
}
inline ::aggregator::v1::GenStatelessBatchProofRequest* AggregatorMessage::release_gen_stateless_batch_proof_request() {
  // @@protoc_insertion_point(field_release:aggregator.v1.AggregatorMessage.gen_stateless_batch_proof_request)
  if (request_case() == kGenStatelessBatchProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_stateless_batch_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.gen_stateless_batch_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenStatelessBatchProofRequest& AggregatorMessage::_internal_gen_stateless_batch_proof_request() const {
  return request_case() == kGenStatelessBatchProofRequest ? *_impl_.request_.gen_stateless_batch_proof_request_ : reinterpret_cast<::aggregator::v1::GenStatelessBatchProofRequest&>(::aggregator::v1::_GenStatelessBatchProofRequest_default_instance_);
}
inline const ::aggregator::v1::GenStatelessBatchProofRequest& AggregatorMessage::gen_stateless_batch_proof_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.AggregatorMessage.gen_stateless_batch_proof_request)
  return _internal_gen_stateless_batch_proof_request();
}
inline ::aggregator::v1::GenStatelessBatchProofRequest* AggregatorMessage::unsafe_arena_release_gen_stateless_batch_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.AggregatorMessage.gen_stateless_batch_proof_request)
  if (request_case() == kGenStatelessBatchProofRequest) {
    clear_has_request();
    auto* temp = _impl_.request_.gen_stateless_batch_proof_request_;
    _impl_.request_.gen_stateless_batch_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggregatorMessage::unsafe_arena_set_allocated_gen_stateless_batch_proof_request(::aggregator::v1::GenStatelessBatchProofRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_request();
  if (value) {
    set_has_gen_stateless_batch_proof_request();
    _impl_.request_.gen_stateless_batch_proof_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.AggregatorMessage.gen_stateless_batch_proof_request)
}
inline ::aggregator::v1::GenStatelessBatchProofRequest* AggregatorMessage::_internal_mutable_gen_stateless_batch_proof_request() {
  if (request_case() != kGenStatelessBatchProofRequest) {
    clear_request();
    set_has_gen_stateless_batch_proof_request();
    _impl_.request_.gen_stateless_batch_proof_request_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GenStatelessBatchProofRequest>(GetArena());
  }
  return _impl_.request_.gen_stateless_batch_proof_request_;
}
inline ::aggregator::v1::GenStatelessBatchProofRequest* AggregatorMessage::mutable_gen_stateless_batch_proof_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GenStatelessBatchProofRequest* _msg = _internal_mutable_gen_stateless_batch_proof_request();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.AggregatorMessage.gen_stateless_batch_proof_request)
  return _msg;
}

inline bool AggregatorMessage::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void AggregatorMessage::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline AggregatorMessage::RequestCase AggregatorMessage::request_case() const {
  return AggregatorMessage::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProverMessage

// string id = 1;
inline void ProverMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ProverMessage::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProverMessage::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.ProverMessage.id)
}
inline std::string* ProverMessage::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.id)
  return _s;
}
inline const std::string& ProverMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ProverMessage::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ProverMessage::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ProverMessage::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.id)
  return _impl_.id_.Release();
}
inline void ProverMessage::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.ProverMessage.id)
}

// .aggregator.v1.GetStatusResponse get_status_response = 2;
inline bool ProverMessage::has_get_status_response() const {
  return response_case() == kGetStatusResponse;
}
inline bool ProverMessage::_internal_has_get_status_response() const {
  return response_case() == kGetStatusResponse;
}
inline void ProverMessage::set_has_get_status_response() {
  _impl_._oneof_case_[0] = kGetStatusResponse;
}
inline void ProverMessage::clear_get_status_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kGetStatusResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.get_status_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.get_status_response_);
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::release_get_status_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.get_status_response)
  if (response_case() == kGetStatusResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.get_status_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.get_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetStatusResponse& ProverMessage::_internal_get_status_response() const {
  return response_case() == kGetStatusResponse ? *_impl_.response_.get_status_response_ : reinterpret_cast<::aggregator::v1::GetStatusResponse&>(::aggregator::v1::_GetStatusResponse_default_instance_);
}
inline const ::aggregator::v1::GetStatusResponse& ProverMessage::get_status_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.get_status_response)
  return _internal_get_status_response();
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::unsafe_arena_release_get_status_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.get_status_response)
  if (response_case() == kGetStatusResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.get_status_response_;
    _impl_.response_.get_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_get_status_response(::aggregator::v1::GetStatusResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_get_status_response();
    _impl_.response_.get_status_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.get_status_response)
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::_internal_mutable_get_status_response() {
  if (response_case() != kGetStatusResponse) {
    clear_response();
    set_has_get_status_response();
    _impl_.response_.get_status_response_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GetStatusResponse>(GetArena());
  }
  return _impl_.response_.get_status_response_;
}
inline ::aggregator::v1::GetStatusResponse* ProverMessage::mutable_get_status_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GetStatusResponse* _msg = _internal_mutable_get_status_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.get_status_response)
  return _msg;
}

// .aggregator.v1.GenBatchProofResponse gen_batch_proof_response = 3;
inline bool ProverMessage::has_gen_batch_proof_response() const {
  return response_case() == kGenBatchProofResponse;
}
inline bool ProverMessage::_internal_has_gen_batch_proof_response() const {
  return response_case() == kGenBatchProofResponse;
}
inline void ProverMessage::set_has_gen_batch_proof_response() {
  _impl_._oneof_case_[0] = kGenBatchProofResponse;
}
inline void ProverMessage::clear_gen_batch_proof_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kGenBatchProofResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.gen_batch_proof_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.gen_batch_proof_response_);
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::release_gen_batch_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.gen_batch_proof_response)
  if (response_case() == kGenBatchProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.gen_batch_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gen_batch_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenBatchProofResponse& ProverMessage::_internal_gen_batch_proof_response() const {
  return response_case() == kGenBatchProofResponse ? *_impl_.response_.gen_batch_proof_response_ : reinterpret_cast<::aggregator::v1::GenBatchProofResponse&>(::aggregator::v1::_GenBatchProofResponse_default_instance_);
}
inline const ::aggregator::v1::GenBatchProofResponse& ProverMessage::gen_batch_proof_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.gen_batch_proof_response)
  return _internal_gen_batch_proof_response();
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::unsafe_arena_release_gen_batch_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.gen_batch_proof_response)
  if (response_case() == kGenBatchProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.gen_batch_proof_response_;
    _impl_.response_.gen_batch_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_batch_proof_response(::aggregator::v1::GenBatchProofResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_gen_batch_proof_response();
    _impl_.response_.gen_batch_proof_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.gen_batch_proof_response)
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::_internal_mutable_gen_batch_proof_response() {
  if (response_case() != kGenBatchProofResponse) {
    clear_response();
    set_has_gen_batch_proof_response();
    _impl_.response_.gen_batch_proof_response_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GenBatchProofResponse>(GetArena());
  }
  return _impl_.response_.gen_batch_proof_response_;
}
inline ::aggregator::v1::GenBatchProofResponse* ProverMessage::mutable_gen_batch_proof_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GenBatchProofResponse* _msg = _internal_mutable_gen_batch_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.gen_batch_proof_response)
  return _msg;
}

// .aggregator.v1.GenAggregatedProofResponse gen_aggregated_proof_response = 4;
inline bool ProverMessage::has_gen_aggregated_proof_response() const {
  return response_case() == kGenAggregatedProofResponse;
}
inline bool ProverMessage::_internal_has_gen_aggregated_proof_response() const {
  return response_case() == kGenAggregatedProofResponse;
}
inline void ProverMessage::set_has_gen_aggregated_proof_response() {
  _impl_._oneof_case_[0] = kGenAggregatedProofResponse;
}
inline void ProverMessage::clear_gen_aggregated_proof_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kGenAggregatedProofResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.gen_aggregated_proof_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.gen_aggregated_proof_response_);
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::release_gen_aggregated_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  if (response_case() == kGenAggregatedProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.gen_aggregated_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gen_aggregated_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenAggregatedProofResponse& ProverMessage::_internal_gen_aggregated_proof_response() const {
  return response_case() == kGenAggregatedProofResponse ? *_impl_.response_.gen_aggregated_proof_response_ : reinterpret_cast<::aggregator::v1::GenAggregatedProofResponse&>(::aggregator::v1::_GenAggregatedProofResponse_default_instance_);
}
inline const ::aggregator::v1::GenAggregatedProofResponse& ProverMessage::gen_aggregated_proof_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  return _internal_gen_aggregated_proof_response();
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::unsafe_arena_release_gen_aggregated_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  if (response_case() == kGenAggregatedProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.gen_aggregated_proof_response_;
    _impl_.response_.gen_aggregated_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_aggregated_proof_response(::aggregator::v1::GenAggregatedProofResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_gen_aggregated_proof_response();
    _impl_.response_.gen_aggregated_proof_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::_internal_mutable_gen_aggregated_proof_response() {
  if (response_case() != kGenAggregatedProofResponse) {
    clear_response();
    set_has_gen_aggregated_proof_response();
    _impl_.response_.gen_aggregated_proof_response_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GenAggregatedProofResponse>(GetArena());
  }
  return _impl_.response_.gen_aggregated_proof_response_;
}
inline ::aggregator::v1::GenAggregatedProofResponse* ProverMessage::mutable_gen_aggregated_proof_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GenAggregatedProofResponse* _msg = _internal_mutable_gen_aggregated_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.gen_aggregated_proof_response)
  return _msg;
}

// .aggregator.v1.GenFinalProofResponse gen_final_proof_response = 5;
inline bool ProverMessage::has_gen_final_proof_response() const {
  return response_case() == kGenFinalProofResponse;
}
inline bool ProverMessage::_internal_has_gen_final_proof_response() const {
  return response_case() == kGenFinalProofResponse;
}
inline void ProverMessage::set_has_gen_final_proof_response() {
  _impl_._oneof_case_[0] = kGenFinalProofResponse;
}
inline void ProverMessage::clear_gen_final_proof_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kGenFinalProofResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.gen_final_proof_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.gen_final_proof_response_);
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::release_gen_final_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.gen_final_proof_response)
  if (response_case() == kGenFinalProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.gen_final_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gen_final_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GenFinalProofResponse& ProverMessage::_internal_gen_final_proof_response() const {
  return response_case() == kGenFinalProofResponse ? *_impl_.response_.gen_final_proof_response_ : reinterpret_cast<::aggregator::v1::GenFinalProofResponse&>(::aggregator::v1::_GenFinalProofResponse_default_instance_);
}
inline const ::aggregator::v1::GenFinalProofResponse& ProverMessage::gen_final_proof_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.gen_final_proof_response)
  return _internal_gen_final_proof_response();
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::unsafe_arena_release_gen_final_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.gen_final_proof_response)
  if (response_case() == kGenFinalProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.gen_final_proof_response_;
    _impl_.response_.gen_final_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_final_proof_response(::aggregator::v1::GenFinalProofResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_gen_final_proof_response();
    _impl_.response_.gen_final_proof_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.gen_final_proof_response)
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::_internal_mutable_gen_final_proof_response() {
  if (response_case() != kGenFinalProofResponse) {
    clear_response();
    set_has_gen_final_proof_response();
    _impl_.response_.gen_final_proof_response_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GenFinalProofResponse>(GetArena());
  }
  return _impl_.response_.gen_final_proof_response_;
}
inline ::aggregator::v1::GenFinalProofResponse* ProverMessage::mutable_gen_final_proof_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GenFinalProofResponse* _msg = _internal_mutable_gen_final_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.gen_final_proof_response)
  return _msg;
}

// .aggregator.v1.CancelResponse cancel_response = 6;
inline bool ProverMessage::has_cancel_response() const {
  return response_case() == kCancelResponse;
}
inline bool ProverMessage::_internal_has_cancel_response() const {
  return response_case() == kCancelResponse;
}
inline void ProverMessage::set_has_cancel_response() {
  _impl_._oneof_case_[0] = kCancelResponse;
}
inline void ProverMessage::clear_cancel_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kCancelResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.cancel_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.cancel_response_);
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::CancelResponse* ProverMessage::release_cancel_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.cancel_response)
  if (response_case() == kCancelResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.cancel_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.cancel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::CancelResponse& ProverMessage::_internal_cancel_response() const {
  return response_case() == kCancelResponse ? *_impl_.response_.cancel_response_ : reinterpret_cast<::aggregator::v1::CancelResponse&>(::aggregator::v1::_CancelResponse_default_instance_);
}
inline const ::aggregator::v1::CancelResponse& ProverMessage::cancel_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.cancel_response)
  return _internal_cancel_response();
}
inline ::aggregator::v1::CancelResponse* ProverMessage::unsafe_arena_release_cancel_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.cancel_response)
  if (response_case() == kCancelResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.cancel_response_;
    _impl_.response_.cancel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_cancel_response(::aggregator::v1::CancelResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_cancel_response();
    _impl_.response_.cancel_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.cancel_response)
}
inline ::aggregator::v1::CancelResponse* ProverMessage::_internal_mutable_cancel_response() {
  if (response_case() != kCancelResponse) {
    clear_response();
    set_has_cancel_response();
    _impl_.response_.cancel_response_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::CancelResponse>(GetArena());
  }
  return _impl_.response_.cancel_response_;
}
inline ::aggregator::v1::CancelResponse* ProverMessage::mutable_cancel_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::CancelResponse* _msg = _internal_mutable_cancel_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.cancel_response)
  return _msg;
}

// .aggregator.v1.GetProofResponse get_proof_response = 7;
inline bool ProverMessage::has_get_proof_response() const {
  return response_case() == kGetProofResponse;
}
inline bool ProverMessage::_internal_has_get_proof_response() const {
  return response_case() == kGetProofResponse;
}
inline void ProverMessage::set_has_get_proof_response() {
  _impl_._oneof_case_[0] = kGetProofResponse;
}
inline void ProverMessage::clear_get_proof_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (response_case() == kGetProofResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.response_.get_proof_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.response_.get_proof_response_);
    }
    clear_has_response();
  }
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::release_get_proof_response() {
  // @@protoc_insertion_point(field_release:aggregator.v1.ProverMessage.get_proof_response)
  if (response_case() == kGetProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.get_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.get_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::GetProofResponse& ProverMessage::_internal_get_proof_response() const {
  return response_case() == kGetProofResponse ? *_impl_.response_.get_proof_response_ : reinterpret_cast<::aggregator::v1::GetProofResponse&>(::aggregator::v1::_GetProofResponse_default_instance_);
}
inline const ::aggregator::v1::GetProofResponse& ProverMessage::get_proof_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.ProverMessage.get_proof_response)
  return _internal_get_proof_response();
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::unsafe_arena_release_get_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.ProverMessage.get_proof_response)
  if (response_case() == kGetProofResponse) {
    clear_has_response();
    auto* temp = _impl_.response_.get_proof_response_;
    _impl_.response_.get_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_get_proof_response(::aggregator::v1::GetProofResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_response();
  if (value) {
    set_has_get_proof_response();
    _impl_.response_.get_proof_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.ProverMessage.get_proof_response)
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::_internal_mutable_get_proof_response() {
  if (response_case() != kGetProofResponse) {
    clear_response();
    set_has_get_proof_response();
    _impl_.response_.get_proof_response_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::GetProofResponse>(GetArena());
  }
  return _impl_.response_.get_proof_response_;
}
inline ::aggregator::v1::GetProofResponse* ProverMessage::mutable_get_proof_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::GetProofResponse* _msg = _internal_mutable_get_proof_response();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.ProverMessage.get_proof_response)
  return _msg;
}

inline bool ProverMessage::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ProverMessage::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ProverMessage::ResponseCase ProverMessage::response_case() const {
  return ProverMessage::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetStatusRequest

// -------------------------------------------------------------------

// GenBatchProofRequest

// .aggregator.v1.InputProver input = 1;
inline bool GenBatchProofRequest::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void GenBatchProofRequest::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aggregator::v1::InputProver& GenBatchProofRequest::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::aggregator::v1::InputProver* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::InputProver&>(::aggregator::v1::_InputProver_default_instance_);
}
inline const ::aggregator::v1::InputProver& GenBatchProofRequest::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenBatchProofRequest.input)
  return _internal_input();
}
inline void GenBatchProofRequest::unsafe_arena_set_allocated_input(::aggregator::v1::InputProver* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::aggregator::v1::InputProver*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.GenBatchProofRequest.input)
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::InputProver* released = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenBatchProofRequest.input)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::InputProver* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::InputProver>(GetArena());
    _impl_.input_ = reinterpret_cast<::aggregator::v1::InputProver*>(p);
  }
  return _impl_.input_;
}
inline ::aggregator::v1::InputProver* GenBatchProofRequest::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::aggregator::v1::InputProver* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenBatchProofRequest.input)
  return _msg;
}
inline void GenBatchProofRequest::set_allocated_input(::aggregator::v1::InputProver* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_ = reinterpret_cast<::aggregator::v1::InputProver*>(value);
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenBatchProofRequest.input)
}

// -------------------------------------------------------------------

// GenStatelessBatchProofRequest

// .aggregator.v1.StatelessInputProver input = 1;
inline bool GenStatelessBatchProofRequest::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void GenStatelessBatchProofRequest::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aggregator::v1::StatelessInputProver& GenStatelessBatchProofRequest::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::aggregator::v1::StatelessInputProver* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::StatelessInputProver&>(::aggregator::v1::_StatelessInputProver_default_instance_);
}
inline const ::aggregator::v1::StatelessInputProver& GenStatelessBatchProofRequest::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenStatelessBatchProofRequest.input)
  return _internal_input();
}
inline void GenStatelessBatchProofRequest::unsafe_arena_set_allocated_input(::aggregator::v1::StatelessInputProver* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::aggregator::v1::StatelessInputProver*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.GenStatelessBatchProofRequest.input)
}
inline ::aggregator::v1::StatelessInputProver* GenStatelessBatchProofRequest::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::StatelessInputProver* released = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::aggregator::v1::StatelessInputProver* GenStatelessBatchProofRequest::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenStatelessBatchProofRequest.input)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::StatelessInputProver* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::aggregator::v1::StatelessInputProver* GenStatelessBatchProofRequest::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::StatelessInputProver>(GetArena());
    _impl_.input_ = reinterpret_cast<::aggregator::v1::StatelessInputProver*>(p);
  }
  return _impl_.input_;
}
inline ::aggregator::v1::StatelessInputProver* GenStatelessBatchProofRequest::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::aggregator::v1::StatelessInputProver* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenStatelessBatchProofRequest.input)
  return _msg;
}
inline void GenStatelessBatchProofRequest::set_allocated_input(::aggregator::v1::StatelessInputProver* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_ = reinterpret_cast<::aggregator::v1::StatelessInputProver*>(value);
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenStatelessBatchProofRequest.input)
}

// -------------------------------------------------------------------

// GenAggregatedProofRequest

// string recursive_proof_1 = 1;
inline void GenAggregatedProofRequest::clear_recursive_proof_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_1_.ClearToEmpty();
}
inline const std::string& GenAggregatedProofRequest::recursive_proof_1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
  return _internal_recursive_proof_1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenAggregatedProofRequest::set_recursive_proof_1(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_1_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
}
inline std::string* GenAggregatedProofRequest::mutable_recursive_proof_1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recursive_proof_1();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
  return _s;
}
inline const std::string& GenAggregatedProofRequest::_internal_recursive_proof_1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recursive_proof_1_.Get();
}
inline void GenAggregatedProofRequest::_internal_set_recursive_proof_1(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_1_.Set(value, GetArena());
}
inline std::string* GenAggregatedProofRequest::_internal_mutable_recursive_proof_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recursive_proof_1_.Mutable( GetArena());
}
inline std::string* GenAggregatedProofRequest::release_recursive_proof_1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
  return _impl_.recursive_proof_1_.Release();
}
inline void GenAggregatedProofRequest::set_allocated_recursive_proof_1(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recursive_proof_1_.IsDefault()) {
          _impl_.recursive_proof_1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenAggregatedProofRequest.recursive_proof_1)
}

// string recursive_proof_2 = 2;
inline void GenAggregatedProofRequest::clear_recursive_proof_2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_2_.ClearToEmpty();
}
inline const std::string& GenAggregatedProofRequest::recursive_proof_2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
  return _internal_recursive_proof_2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenAggregatedProofRequest::set_recursive_proof_2(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_2_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
}
inline std::string* GenAggregatedProofRequest::mutable_recursive_proof_2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recursive_proof_2();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
  return _s;
}
inline const std::string& GenAggregatedProofRequest::_internal_recursive_proof_2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recursive_proof_2_.Get();
}
inline void GenAggregatedProofRequest::_internal_set_recursive_proof_2(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_2_.Set(value, GetArena());
}
inline std::string* GenAggregatedProofRequest::_internal_mutable_recursive_proof_2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recursive_proof_2_.Mutable( GetArena());
}
inline std::string* GenAggregatedProofRequest::release_recursive_proof_2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
  return _impl_.recursive_proof_2_.Release();
}
inline void GenAggregatedProofRequest::set_allocated_recursive_proof_2(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_2_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recursive_proof_2_.IsDefault()) {
          _impl_.recursive_proof_2_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenAggregatedProofRequest.recursive_proof_2)
}

// -------------------------------------------------------------------

// GenFinalProofRequest

// string recursive_proof = 1;
inline void GenFinalProofRequest::clear_recursive_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_.ClearToEmpty();
}
inline const std::string& GenFinalProofRequest::recursive_proof() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofRequest.recursive_proof)
  return _internal_recursive_proof();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenFinalProofRequest::set_recursive_proof(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofRequest.recursive_proof)
}
inline std::string* GenFinalProofRequest::mutable_recursive_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recursive_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenFinalProofRequest.recursive_proof)
  return _s;
}
inline const std::string& GenFinalProofRequest::_internal_recursive_proof() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recursive_proof_.Get();
}
inline void GenFinalProofRequest::_internal_set_recursive_proof(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_.Set(value, GetArena());
}
inline std::string* GenFinalProofRequest::_internal_mutable_recursive_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recursive_proof_.Mutable( GetArena());
}
inline std::string* GenFinalProofRequest::release_recursive_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenFinalProofRequest.recursive_proof)
  return _impl_.recursive_proof_.Release();
}
inline void GenFinalProofRequest::set_allocated_recursive_proof(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recursive_proof_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recursive_proof_.IsDefault()) {
          _impl_.recursive_proof_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenFinalProofRequest.recursive_proof)
}

// string aggregator_addr = 2;
inline void GenFinalProofRequest::clear_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.ClearToEmpty();
}
inline const std::string& GenFinalProofRequest::aggregator_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofRequest.aggregator_addr)
  return _internal_aggregator_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenFinalProofRequest::set_aggregator_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofRequest.aggregator_addr)
}
inline std::string* GenFinalProofRequest::mutable_aggregator_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_aggregator_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenFinalProofRequest.aggregator_addr)
  return _s;
}
inline const std::string& GenFinalProofRequest::_internal_aggregator_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggregator_addr_.Get();
}
inline void GenFinalProofRequest::_internal_set_aggregator_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.Set(value, GetArena());
}
inline std::string* GenFinalProofRequest::_internal_mutable_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aggregator_addr_.Mutable( GetArena());
}
inline std::string* GenFinalProofRequest::release_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenFinalProofRequest.aggregator_addr)
  return _impl_.aggregator_addr_.Release();
}
inline void GenFinalProofRequest::set_allocated_aggregator_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aggregator_addr_.IsDefault()) {
          _impl_.aggregator_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenFinalProofRequest.aggregator_addr)
}

// -------------------------------------------------------------------

// CancelRequest

// string id = 1;
inline void CancelRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CancelRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.CancelRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.CancelRequest.id)
}
inline std::string* CancelRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.CancelRequest.id)
  return _s;
}
inline const std::string& CancelRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void CancelRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* CancelRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* CancelRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.CancelRequest.id)
  return _impl_.id_.Release();
}
inline void CancelRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.CancelRequest.id)
}

// -------------------------------------------------------------------

// GetProofRequest

// string id = 1;
inline void GetProofRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetProofRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProofRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofRequest.id)
}
inline std::string* GetProofRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofRequest.id)
  return _s;
}
inline const std::string& GetProofRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GetProofRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetProofRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetProofRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofRequest.id)
  return _impl_.id_.Release();
}
inline void GetProofRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofRequest.id)
}

// uint64 timeout = 2;
inline void GetProofRequest::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
}
inline ::uint64_t GetProofRequest::timeout() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofRequest.timeout)
  return _internal_timeout();
}
inline void GetProofRequest::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofRequest.timeout)
}
inline ::uint64_t GetProofRequest::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void GetProofRequest::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// GetStatusResponse

// .aggregator.v1.GetStatusResponse.Status status = 1;
inline void GetStatusResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::aggregator::v1::GetStatusResponse_Status GetStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.status)
  return _internal_status();
}
inline void GetStatusResponse::set_status(::aggregator::v1::GetStatusResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.status)
}
inline ::aggregator::v1::GetStatusResponse_Status GetStatusResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::aggregator::v1::GetStatusResponse_Status>(_impl_.status_);
}
inline void GetStatusResponse::_internal_set_status(::aggregator::v1::GetStatusResponse_Status value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string last_computed_request_id = 2;
inline void GetStatusResponse::clear_last_computed_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_computed_request_id_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::last_computed_request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.last_computed_request_id)
  return _internal_last_computed_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetStatusResponse::set_last_computed_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_computed_request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.last_computed_request_id)
}
inline std::string* GetStatusResponse::mutable_last_computed_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_computed_request_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.last_computed_request_id)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_last_computed_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_computed_request_id_.Get();
}
inline void GetStatusResponse::_internal_set_last_computed_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_computed_request_id_.Set(value, GetArena());
}
inline std::string* GetStatusResponse::_internal_mutable_last_computed_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_computed_request_id_.Mutable( GetArena());
}
inline std::string* GetStatusResponse::release_last_computed_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.last_computed_request_id)
  return _impl_.last_computed_request_id_.Release();
}
inline void GetStatusResponse::set_allocated_last_computed_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_computed_request_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.last_computed_request_id_.IsDefault()) {
          _impl_.last_computed_request_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.last_computed_request_id)
}

// uint64 last_computed_end_time = 3;
inline void GetStatusResponse::clear_last_computed_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_computed_end_time_ = ::uint64_t{0u};
}
inline ::uint64_t GetStatusResponse::last_computed_end_time() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.last_computed_end_time)
  return _internal_last_computed_end_time();
}
inline void GetStatusResponse::set_last_computed_end_time(::uint64_t value) {
  _internal_set_last_computed_end_time(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.last_computed_end_time)
}
inline ::uint64_t GetStatusResponse::_internal_last_computed_end_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_computed_end_time_;
}
inline void GetStatusResponse::_internal_set_last_computed_end_time(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_computed_end_time_ = value;
}

// string current_computing_request_id = 4;
inline void GetStatusResponse::clear_current_computing_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_computing_request_id_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::current_computing_request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.current_computing_request_id)
  return _internal_current_computing_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetStatusResponse::set_current_computing_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_computing_request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.current_computing_request_id)
}
inline std::string* GetStatusResponse::mutable_current_computing_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_computing_request_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.current_computing_request_id)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_current_computing_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_computing_request_id_.Get();
}
inline void GetStatusResponse::_internal_set_current_computing_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_computing_request_id_.Set(value, GetArena());
}
inline std::string* GetStatusResponse::_internal_mutable_current_computing_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.current_computing_request_id_.Mutable( GetArena());
}
inline std::string* GetStatusResponse::release_current_computing_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.current_computing_request_id)
  return _impl_.current_computing_request_id_.Release();
}
inline void GetStatusResponse::set_allocated_current_computing_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_computing_request_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_computing_request_id_.IsDefault()) {
          _impl_.current_computing_request_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.current_computing_request_id)
}

// uint64 current_computing_start_time = 5;
inline void GetStatusResponse::clear_current_computing_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_computing_start_time_ = ::uint64_t{0u};
}
inline ::uint64_t GetStatusResponse::current_computing_start_time() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.current_computing_start_time)
  return _internal_current_computing_start_time();
}
inline void GetStatusResponse::set_current_computing_start_time(::uint64_t value) {
  _internal_set_current_computing_start_time(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.current_computing_start_time)
}
inline ::uint64_t GetStatusResponse::_internal_current_computing_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_computing_start_time_;
}
inline void GetStatusResponse::_internal_set_current_computing_start_time(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_computing_start_time_ = value;
}

// string version_proto = 6;
inline void GetStatusResponse::clear_version_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_proto_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::version_proto() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.version_proto)
  return _internal_version_proto();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetStatusResponse::set_version_proto(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_proto_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.version_proto)
}
inline std::string* GetStatusResponse::mutable_version_proto() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version_proto();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.version_proto)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_version_proto() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_proto_.Get();
}
inline void GetStatusResponse::_internal_set_version_proto(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_proto_.Set(value, GetArena());
}
inline std::string* GetStatusResponse::_internal_mutable_version_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.version_proto_.Mutable( GetArena());
}
inline std::string* GetStatusResponse::release_version_proto() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.version_proto)
  return _impl_.version_proto_.Release();
}
inline void GetStatusResponse::set_allocated_version_proto(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_proto_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_proto_.IsDefault()) {
          _impl_.version_proto_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.version_proto)
}

// string version_server = 7;
inline void GetStatusResponse::clear_version_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_server_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::version_server() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.version_server)
  return _internal_version_server();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetStatusResponse::set_version_server(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_server_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.version_server)
}
inline std::string* GetStatusResponse::mutable_version_server() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version_server();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.version_server)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_version_server() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_server_.Get();
}
inline void GetStatusResponse::_internal_set_version_server(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_server_.Set(value, GetArena());
}
inline std::string* GetStatusResponse::_internal_mutable_version_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.version_server_.Mutable( GetArena());
}
inline std::string* GetStatusResponse::release_version_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.version_server)
  return _impl_.version_server_.Release();
}
inline void GetStatusResponse::set_allocated_version_server(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_server_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_server_.IsDefault()) {
          _impl_.version_server_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.version_server)
}

// repeated string pending_request_queue_ids = 8;
inline int GetStatusResponse::_internal_pending_request_queue_ids_size() const {
  return _internal_pending_request_queue_ids().size();
}
inline int GetStatusResponse::pending_request_queue_ids_size() const {
  return _internal_pending_request_queue_ids_size();
}
inline void GetStatusResponse::clear_pending_request_queue_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pending_request_queue_ids_.Clear();
}
inline std::string* GetStatusResponse::add_pending_request_queue_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_pending_request_queue_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _s;
}
inline const std::string& GetStatusResponse::pending_request_queue_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _internal_pending_request_queue_ids().Get(index);
}
inline std::string* GetStatusResponse::mutable_pending_request_queue_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _internal_mutable_pending_request_queue_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GetStatusResponse::set_pending_request_queue_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_pending_request_queue_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
template <typename Arg_, typename... Args_>
inline void GetStatusResponse::add_pending_request_queue_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_pending_request_queue_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetStatusResponse::pending_request_queue_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  return _internal_pending_request_queue_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetStatusResponse::mutable_pending_request_queue_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:aggregator.v1.GetStatusResponse.pending_request_queue_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pending_request_queue_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetStatusResponse::_internal_pending_request_queue_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pending_request_queue_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetStatusResponse::_internal_mutable_pending_request_queue_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pending_request_queue_ids_;
}

// string prover_name = 9;
inline void GetStatusResponse::clear_prover_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_name_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::prover_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.prover_name)
  return _internal_prover_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetStatusResponse::set_prover_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.prover_name)
}
inline std::string* GetStatusResponse::mutable_prover_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prover_name();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.prover_name)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_prover_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prover_name_.Get();
}
inline void GetStatusResponse::_internal_set_prover_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_name_.Set(value, GetArena());
}
inline std::string* GetStatusResponse::_internal_mutable_prover_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prover_name_.Mutable( GetArena());
}
inline std::string* GetStatusResponse::release_prover_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.prover_name)
  return _impl_.prover_name_.Release();
}
inline void GetStatusResponse::set_allocated_prover_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prover_name_.IsDefault()) {
          _impl_.prover_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.prover_name)
}

// string prover_id = 10;
inline void GetStatusResponse::clear_prover_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& GetStatusResponse::prover_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.prover_id)
  return _internal_prover_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetStatusResponse::set_prover_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.prover_id)
}
inline std::string* GetStatusResponse::mutable_prover_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetStatusResponse.prover_id)
  return _s;
}
inline const std::string& GetStatusResponse::_internal_prover_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prover_id_.Get();
}
inline void GetStatusResponse::_internal_set_prover_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_id_.Set(value, GetArena());
}
inline std::string* GetStatusResponse::_internal_mutable_prover_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prover_id_.Mutable( GetArena());
}
inline std::string* GetStatusResponse::release_prover_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetStatusResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void GetStatusResponse::set_allocated_prover_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prover_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prover_id_.IsDefault()) {
          _impl_.prover_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetStatusResponse.prover_id)
}

// uint64 number_of_cores = 11;
inline void GetStatusResponse::clear_number_of_cores() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_cores_ = ::uint64_t{0u};
}
inline ::uint64_t GetStatusResponse::number_of_cores() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.number_of_cores)
  return _internal_number_of_cores();
}
inline void GetStatusResponse::set_number_of_cores(::uint64_t value) {
  _internal_set_number_of_cores(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.number_of_cores)
}
inline ::uint64_t GetStatusResponse::_internal_number_of_cores() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_of_cores_;
}
inline void GetStatusResponse::_internal_set_number_of_cores(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_cores_ = value;
}

// uint64 total_memory = 12;
inline void GetStatusResponse::clear_total_memory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_memory_ = ::uint64_t{0u};
}
inline ::uint64_t GetStatusResponse::total_memory() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.total_memory)
  return _internal_total_memory();
}
inline void GetStatusResponse::set_total_memory(::uint64_t value) {
  _internal_set_total_memory(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.total_memory)
}
inline ::uint64_t GetStatusResponse::_internal_total_memory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_memory_;
}
inline void GetStatusResponse::_internal_set_total_memory(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_memory_ = value;
}

// uint64 free_memory = 13;
inline void GetStatusResponse::clear_free_memory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_memory_ = ::uint64_t{0u};
}
inline ::uint64_t GetStatusResponse::free_memory() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.free_memory)
  return _internal_free_memory();
}
inline void GetStatusResponse::set_free_memory(::uint64_t value) {
  _internal_set_free_memory(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.free_memory)
}
inline ::uint64_t GetStatusResponse::_internal_free_memory() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.free_memory_;
}
inline void GetStatusResponse::_internal_set_free_memory(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_memory_ = value;
}

// uint64 fork_id = 14;
inline void GetStatusResponse::clear_fork_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fork_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetStatusResponse::fork_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetStatusResponse.fork_id)
  return _internal_fork_id();
}
inline void GetStatusResponse::set_fork_id(::uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetStatusResponse.fork_id)
}
inline ::uint64_t GetStatusResponse::_internal_fork_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fork_id_;
}
inline void GetStatusResponse::_internal_set_fork_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fork_id_ = value;
}

// -------------------------------------------------------------------

// GenBatchProofResponse

// string id = 1;
inline void GenBatchProofResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GenBatchProofResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenBatchProofResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenBatchProofResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenBatchProofResponse.id)
}
inline std::string* GenBatchProofResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenBatchProofResponse.id)
  return _s;
}
inline const std::string& GenBatchProofResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GenBatchProofResponse::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GenBatchProofResponse::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GenBatchProofResponse::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenBatchProofResponse.id)
  return _impl_.id_.Release();
}
inline void GenBatchProofResponse::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenBatchProofResponse.id)
}

// .aggregator.v1.Result result = 2;
inline void GenBatchProofResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result GenBatchProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenBatchProofResponse.result)
  return _internal_result();
}
inline void GenBatchProofResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GenBatchProofResponse.result)
}
inline ::aggregator::v1::Result GenBatchProofResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::aggregator::v1::Result>(_impl_.result_);
}
inline void GenBatchProofResponse::_internal_set_result(::aggregator::v1::Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// GenAggregatedProofResponse

// string id = 1;
inline void GenAggregatedProofResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GenAggregatedProofResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenAggregatedProofResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofResponse.id)
}
inline std::string* GenAggregatedProofResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenAggregatedProofResponse.id)
  return _s;
}
inline const std::string& GenAggregatedProofResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GenAggregatedProofResponse::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GenAggregatedProofResponse::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GenAggregatedProofResponse::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenAggregatedProofResponse.id)
  return _impl_.id_.Release();
}
inline void GenAggregatedProofResponse::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenAggregatedProofResponse.id)
}

// .aggregator.v1.Result result = 2;
inline void GenAggregatedProofResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result GenAggregatedProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenAggregatedProofResponse.result)
  return _internal_result();
}
inline void GenAggregatedProofResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GenAggregatedProofResponse.result)
}
inline ::aggregator::v1::Result GenAggregatedProofResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::aggregator::v1::Result>(_impl_.result_);
}
inline void GenAggregatedProofResponse::_internal_set_result(::aggregator::v1::Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// GenFinalProofResponse

// string id = 1;
inline void GenFinalProofResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GenFinalProofResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenFinalProofResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofResponse.id)
}
inline std::string* GenFinalProofResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GenFinalProofResponse.id)
  return _s;
}
inline const std::string& GenFinalProofResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GenFinalProofResponse::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GenFinalProofResponse::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GenFinalProofResponse::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GenFinalProofResponse.id)
  return _impl_.id_.Release();
}
inline void GenFinalProofResponse::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GenFinalProofResponse.id)
}

// .aggregator.v1.Result result = 2;
inline void GenFinalProofResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result GenFinalProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GenFinalProofResponse.result)
  return _internal_result();
}
inline void GenFinalProofResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GenFinalProofResponse.result)
}
inline ::aggregator::v1::Result GenFinalProofResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::aggregator::v1::Result>(_impl_.result_);
}
inline void GenFinalProofResponse::_internal_set_result(::aggregator::v1::Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// CancelResponse

// .aggregator.v1.Result result = 1;
inline void CancelResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::aggregator::v1::Result CancelResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.CancelResponse.result)
  return _internal_result();
}
inline void CancelResponse::set_result(::aggregator::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.CancelResponse.result)
}
inline ::aggregator::v1::Result CancelResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::aggregator::v1::Result>(_impl_.result_);
}
inline void CancelResponse::_internal_set_result(::aggregator::v1::Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// GetProofResponse

// string id = 1;
inline void GetProofResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetProofResponse::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProofResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.id)
}
inline std::string* GetProofResponse::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.id)
  return _s;
}
inline const std::string& GetProofResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GetProofResponse::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetProofResponse::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetProofResponse::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.id)
  return _impl_.id_.Release();
}
inline void GetProofResponse::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofResponse.id)
}

// .aggregator.v1.FinalProof final_proof = 2;
inline bool GetProofResponse::has_final_proof() const {
  return proof_case() == kFinalProof;
}
inline bool GetProofResponse::_internal_has_final_proof() const {
  return proof_case() == kFinalProof;
}
inline void GetProofResponse::set_has_final_proof() {
  _impl_._oneof_case_[0] = kFinalProof;
}
inline void GetProofResponse::clear_final_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kFinalProof) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.final_proof_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.final_proof_);
    }
    clear_has_proof();
  }
}
inline ::aggregator::v1::FinalProof* GetProofResponse::release_final_proof() {
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.final_proof)
  if (proof_case() == kFinalProof) {
    clear_has_proof();
    auto* temp = _impl_.proof_.final_proof_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.final_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aggregator::v1::FinalProof& GetProofResponse::_internal_final_proof() const {
  return proof_case() == kFinalProof ? *_impl_.proof_.final_proof_ : reinterpret_cast<::aggregator::v1::FinalProof&>(::aggregator::v1::_FinalProof_default_instance_);
}
inline const ::aggregator::v1::FinalProof& GetProofResponse::final_proof() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.final_proof)
  return _internal_final_proof();
}
inline ::aggregator::v1::FinalProof* GetProofResponse::unsafe_arena_release_final_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aggregator.v1.GetProofResponse.final_proof)
  if (proof_case() == kFinalProof) {
    clear_has_proof();
    auto* temp = _impl_.proof_.final_proof_;
    _impl_.proof_.final_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetProofResponse::unsafe_arena_set_allocated_final_proof(::aggregator::v1::FinalProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_final_proof();
    _impl_.proof_.final_proof_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.GetProofResponse.final_proof)
}
inline ::aggregator::v1::FinalProof* GetProofResponse::_internal_mutable_final_proof() {
  if (proof_case() != kFinalProof) {
    clear_proof();
    set_has_final_proof();
    _impl_.proof_.final_proof_ =
        ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::FinalProof>(GetArena());
  }
  return _impl_.proof_.final_proof_;
}
inline ::aggregator::v1::FinalProof* GetProofResponse::mutable_final_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::aggregator::v1::FinalProof* _msg = _internal_mutable_final_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.final_proof)
  return _msg;
}

// string recursive_proof = 3;
inline bool GetProofResponse::has_recursive_proof() const {
  return proof_case() == kRecursiveProof;
}
inline void GetProofResponse::set_has_recursive_proof() {
  _impl_._oneof_case_[0] = kRecursiveProof;
}
inline void GetProofResponse::clear_recursive_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kRecursiveProof) {
    _impl_.proof_.recursive_proof_.Destroy();
    clear_has_proof();
  }
}
inline const std::string& GetProofResponse::recursive_proof() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.recursive_proof)
  return _internal_recursive_proof();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProofResponse::set_recursive_proof(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() != kRecursiveProof) {
    clear_proof();

    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitDefault();
  }
  _impl_.proof_.recursive_proof_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.recursive_proof)
}
inline std::string* GetProofResponse::mutable_recursive_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recursive_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.recursive_proof)
  return _s;
}
inline const std::string& GetProofResponse::_internal_recursive_proof() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (proof_case() != kRecursiveProof) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.proof_.recursive_proof_.Get();
}
inline void GetProofResponse::_internal_set_recursive_proof(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() != kRecursiveProof) {
    clear_proof();

    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitDefault();
  }
  _impl_.proof_.recursive_proof_.Set(value, GetArena());
}
inline std::string* GetProofResponse::_internal_mutable_recursive_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() != kRecursiveProof) {
    clear_proof();

    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitDefault();
  }
  return _impl_.proof_.recursive_proof_.Mutable( GetArena());
}
inline std::string* GetProofResponse::release_recursive_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.recursive_proof)
  if (proof_case() != kRecursiveProof) {
    return nullptr;
  }
  clear_has_proof();
  return _impl_.proof_.recursive_proof_.Release();
}
inline void GetProofResponse::set_allocated_recursive_proof(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_proof()) {
    clear_proof();
  }
  if (value != nullptr) {
    set_has_recursive_proof();
    _impl_.proof_.recursive_proof_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofResponse.recursive_proof)
}

// .aggregator.v1.GetProofResponse.Result result = 4;
inline void GetProofResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::aggregator::v1::GetProofResponse_Result GetProofResponse::result() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.result)
  return _internal_result();
}
inline void GetProofResponse::set_result(::aggregator::v1::GetProofResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.result)
}
inline ::aggregator::v1::GetProofResponse_Result GetProofResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::aggregator::v1::GetProofResponse_Result>(_impl_.result_);
}
inline void GetProofResponse::_internal_set_result(::aggregator::v1::GetProofResponse_Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// string result_string = 5;
inline void GetProofResponse::clear_result_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_string_.ClearToEmpty();
}
inline const std::string& GetProofResponse::result_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.GetProofResponse.result_string)
  return _internal_result_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProofResponse::set_result_string(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.GetProofResponse.result_string)
}
inline std::string* GetProofResponse::mutable_result_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_result_string();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.GetProofResponse.result_string)
  return _s;
}
inline const std::string& GetProofResponse::_internal_result_string() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_string_.Get();
}
inline void GetProofResponse::_internal_set_result_string(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_string_.Set(value, GetArena());
}
inline std::string* GetProofResponse::_internal_mutable_result_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.result_string_.Mutable( GetArena());
}
inline std::string* GetProofResponse::release_result_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.GetProofResponse.result_string)
  return _impl_.result_string_.Release();
}
inline void GetProofResponse::set_allocated_result_string(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.result_string_.IsDefault()) {
          _impl_.result_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.GetProofResponse.result_string)
}

inline bool GetProofResponse::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void GetProofResponse::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline GetProofResponse::ProofCase GetProofResponse::proof_case() const {
  return GetProofResponse::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FinalProof

// string proof = 1;
inline void FinalProof::clear_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proof_.ClearToEmpty();
}
inline const std::string& FinalProof::proof() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.FinalProof.proof)
  return _internal_proof();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FinalProof::set_proof(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proof_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.FinalProof.proof)
}
inline std::string* FinalProof::mutable_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_proof();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.FinalProof.proof)
  return _s;
}
inline const std::string& FinalProof::_internal_proof() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proof_.Get();
}
inline void FinalProof::_internal_set_proof(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proof_.Set(value, GetArena());
}
inline std::string* FinalProof::_internal_mutable_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.proof_.Mutable( GetArena());
}
inline std::string* FinalProof::release_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.FinalProof.proof)
  return _impl_.proof_.Release();
}
inline void FinalProof::set_allocated_proof(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proof_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_.IsDefault()) {
          _impl_.proof_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.FinalProof.proof)
}

// .aggregator.v1.PublicInputsExtended public = 2;
inline bool FinalProof::has_public_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public__ != nullptr);
  return value;
}
inline void FinalProof::clear_public_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public__ != nullptr) _impl_.public__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aggregator::v1::PublicInputsExtended& FinalProof::_internal_public_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::aggregator::v1::PublicInputsExtended* p = _impl_.public__;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::PublicInputsExtended&>(::aggregator::v1::_PublicInputsExtended_default_instance_);
}
inline const ::aggregator::v1::PublicInputsExtended& FinalProof::public_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.FinalProof.public)
  return _internal_public_();
}
inline void FinalProof::unsafe_arena_set_allocated_public_(::aggregator::v1::PublicInputsExtended* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.public__);
  }
  _impl_.public__ = reinterpret_cast<::aggregator::v1::PublicInputsExtended*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.FinalProof.public)
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::release_public_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::PublicInputsExtended* released = _impl_.public__;
  _impl_.public__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::unsafe_arena_release_public_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.FinalProof.public)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::PublicInputsExtended* temp = _impl_.public__;
  _impl_.public__ = nullptr;
  return temp;
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::_internal_mutable_public_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::PublicInputsExtended>(GetArena());
    _impl_.public__ = reinterpret_cast<::aggregator::v1::PublicInputsExtended*>(p);
  }
  return _impl_.public__;
}
inline ::aggregator::v1::PublicInputsExtended* FinalProof::mutable_public_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::aggregator::v1::PublicInputsExtended* _msg = _internal_mutable_public_();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.FinalProof.public)
  return _msg;
}
inline void FinalProof::set_allocated_public_(::aggregator::v1::PublicInputsExtended* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.public__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.public__ = reinterpret_cast<::aggregator::v1::PublicInputsExtended*>(value);
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.FinalProof.public)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PublicInputs

// bytes old_state_root = 1;
inline void PublicInputs::clear_old_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& PublicInputs::old_state_root() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.old_state_root)
  return _internal_old_state_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputs::set_old_state_root(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_state_root_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.old_state_root)
}
inline std::string* PublicInputs::mutable_old_state_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.old_state_root)
  return _s;
}
inline const std::string& PublicInputs::_internal_old_state_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.old_state_root_.Get();
}
inline void PublicInputs::_internal_set_old_state_root(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_state_root_.Set(value, GetArena());
}
inline std::string* PublicInputs::_internal_mutable_old_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.old_state_root_.Mutable( GetArena());
}
inline std::string* PublicInputs::release_old_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void PublicInputs::set_allocated_old_state_root(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_state_root_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.old_state_root_.IsDefault()) {
          _impl_.old_state_root_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.old_state_root)
}

// bytes old_acc_input_hash = 2;
inline void PublicInputs::clear_old_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.ClearToEmpty();
}
inline const std::string& PublicInputs::old_acc_input_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.old_acc_input_hash)
  return _internal_old_acc_input_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputs::set_old_acc_input_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.old_acc_input_hash)
}
inline std::string* PublicInputs::mutable_old_acc_input_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_old_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.old_acc_input_hash)
  return _s;
}
inline const std::string& PublicInputs::_internal_old_acc_input_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.old_acc_input_hash_.Get();
}
inline void PublicInputs::_internal_set_old_acc_input_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.Set(value, GetArena());
}
inline std::string* PublicInputs::_internal_mutable_old_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.old_acc_input_hash_.Mutable( GetArena());
}
inline std::string* PublicInputs::release_old_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.old_acc_input_hash)
  return _impl_.old_acc_input_hash_.Release();
}
inline void PublicInputs::set_allocated_old_acc_input_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.old_acc_input_hash_.IsDefault()) {
          _impl_.old_acc_input_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.old_acc_input_hash)
}

// uint64 old_batch_num = 3;
inline void PublicInputs::clear_old_batch_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_batch_num_ = ::uint64_t{0u};
}
inline ::uint64_t PublicInputs::old_batch_num() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.old_batch_num)
  return _internal_old_batch_num();
}
inline void PublicInputs::set_old_batch_num(::uint64_t value) {
  _internal_set_old_batch_num(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.old_batch_num)
}
inline ::uint64_t PublicInputs::_internal_old_batch_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.old_batch_num_;
}
inline void PublicInputs::_internal_set_old_batch_num(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_batch_num_ = value;
}

// uint64 chain_id = 4;
inline void PublicInputs::clear_chain_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t PublicInputs::chain_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.chain_id)
  return _internal_chain_id();
}
inline void PublicInputs::set_chain_id(::uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.chain_id)
}
inline ::uint64_t PublicInputs::_internal_chain_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chain_id_;
}
inline void PublicInputs::_internal_set_chain_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chain_id_ = value;
}

// uint64 fork_id = 5;
inline void PublicInputs::clear_fork_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fork_id_ = ::uint64_t{0u};
}
inline ::uint64_t PublicInputs::fork_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.fork_id)
  return _internal_fork_id();
}
inline void PublicInputs::set_fork_id(::uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.fork_id)
}
inline ::uint64_t PublicInputs::_internal_fork_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fork_id_;
}
inline void PublicInputs::_internal_set_fork_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fork_id_ = value;
}

// bytes batch_l2_data = 6;
inline void PublicInputs::clear_batch_l2_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.ClearToEmpty();
}
inline const std::string& PublicInputs::batch_l2_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.batch_l2_data)
  return _internal_batch_l2_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputs::set_batch_l2_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.batch_l2_data)
}
inline std::string* PublicInputs::mutable_batch_l2_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_batch_l2_data();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.batch_l2_data)
  return _s;
}
inline const std::string& PublicInputs::_internal_batch_l2_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.batch_l2_data_.Get();
}
inline void PublicInputs::_internal_set_batch_l2_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.Set(value, GetArena());
}
inline std::string* PublicInputs::_internal_mutable_batch_l2_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.batch_l2_data_.Mutable( GetArena());
}
inline std::string* PublicInputs::release_batch_l2_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.batch_l2_data)
  return _impl_.batch_l2_data_.Release();
}
inline void PublicInputs::set_allocated_batch_l2_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.batch_l2_data_.IsDefault()) {
          _impl_.batch_l2_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.batch_l2_data)
}

// bytes l1_info_root = 7;
inline void PublicInputs::clear_l1_info_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.ClearToEmpty();
}
inline const std::string& PublicInputs::l1_info_root() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.l1_info_root)
  return _internal_l1_info_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputs::set_l1_info_root(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.l1_info_root)
}
inline std::string* PublicInputs::mutable_l1_info_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_l1_info_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.l1_info_root)
  return _s;
}
inline const std::string& PublicInputs::_internal_l1_info_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.l1_info_root_.Get();
}
inline void PublicInputs::_internal_set_l1_info_root(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.Set(value, GetArena());
}
inline std::string* PublicInputs::_internal_mutable_l1_info_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.l1_info_root_.Mutable( GetArena());
}
inline std::string* PublicInputs::release_l1_info_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.l1_info_root)
  return _impl_.l1_info_root_.Release();
}
inline void PublicInputs::set_allocated_l1_info_root(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.l1_info_root_.IsDefault()) {
          _impl_.l1_info_root_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.l1_info_root)
}

// uint64 timestamp_limit = 8;
inline void PublicInputs::clear_timestamp_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_limit_ = ::uint64_t{0u};
}
inline ::uint64_t PublicInputs::timestamp_limit() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.timestamp_limit)
  return _internal_timestamp_limit();
}
inline void PublicInputs::set_timestamp_limit(::uint64_t value) {
  _internal_set_timestamp_limit(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.timestamp_limit)
}
inline ::uint64_t PublicInputs::_internal_timestamp_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_limit_;
}
inline void PublicInputs::_internal_set_timestamp_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_limit_ = value;
}

// string sequencer_addr = 9;
inline void PublicInputs::clear_sequencer_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.ClearToEmpty();
}
inline const std::string& PublicInputs::sequencer_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.sequencer_addr)
  return _internal_sequencer_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputs::set_sequencer_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.sequencer_addr)
}
inline std::string* PublicInputs::mutable_sequencer_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sequencer_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.sequencer_addr)
  return _s;
}
inline const std::string& PublicInputs::_internal_sequencer_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sequencer_addr_.Get();
}
inline void PublicInputs::_internal_set_sequencer_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.Set(value, GetArena());
}
inline std::string* PublicInputs::_internal_mutable_sequencer_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sequencer_addr_.Mutable( GetArena());
}
inline std::string* PublicInputs::release_sequencer_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.sequencer_addr)
  return _impl_.sequencer_addr_.Release();
}
inline void PublicInputs::set_allocated_sequencer_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sequencer_addr_.IsDefault()) {
          _impl_.sequencer_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.sequencer_addr)
}

// bytes forced_blockhash_l1 = 10;
inline void PublicInputs::clear_forced_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.ClearToEmpty();
}
inline const std::string& PublicInputs::forced_blockhash_l1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.forced_blockhash_l1)
  return _internal_forced_blockhash_l1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputs::set_forced_blockhash_l1(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.forced_blockhash_l1)
}
inline std::string* PublicInputs::mutable_forced_blockhash_l1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_forced_blockhash_l1();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.forced_blockhash_l1)
  return _s;
}
inline const std::string& PublicInputs::_internal_forced_blockhash_l1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.forced_blockhash_l1_.Get();
}
inline void PublicInputs::_internal_set_forced_blockhash_l1(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.Set(value, GetArena());
}
inline std::string* PublicInputs::_internal_mutable_forced_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.forced_blockhash_l1_.Mutable( GetArena());
}
inline std::string* PublicInputs::release_forced_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.forced_blockhash_l1)
  return _impl_.forced_blockhash_l1_.Release();
}
inline void PublicInputs::set_allocated_forced_blockhash_l1(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.forced_blockhash_l1_.IsDefault()) {
          _impl_.forced_blockhash_l1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.forced_blockhash_l1)
}

// string aggregator_addr = 12;
inline void PublicInputs::clear_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.ClearToEmpty();
}
inline const std::string& PublicInputs::aggregator_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputs.aggregator_addr)
  return _internal_aggregator_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputs::set_aggregator_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputs.aggregator_addr)
}
inline std::string* PublicInputs::mutable_aggregator_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_aggregator_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputs.aggregator_addr)
  return _s;
}
inline const std::string& PublicInputs::_internal_aggregator_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggregator_addr_.Get();
}
inline void PublicInputs::_internal_set_aggregator_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.Set(value, GetArena());
}
inline std::string* PublicInputs::_internal_mutable_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aggregator_addr_.Mutable( GetArena());
}
inline std::string* PublicInputs::release_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputs.aggregator_addr)
  return _impl_.aggregator_addr_.Release();
}
inline void PublicInputs::set_allocated_aggregator_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aggregator_addr_.IsDefault()) {
          _impl_.aggregator_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputs.aggregator_addr)
}

// map<uint32, .aggregator.v1.L1Data> l1_info_tree_data = 16;
inline int PublicInputs::_internal_l1_info_tree_data_size() const {
  return _internal_l1_info_tree_data().size();
}
inline int PublicInputs::l1_info_tree_data_size() const {
  return _internal_l1_info_tree_data_size();
}
inline void PublicInputs::clear_l1_info_tree_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_tree_data_.Clear();
}
inline const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& PublicInputs::_internal_l1_info_tree_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.l1_info_tree_data_.GetMap();
}
inline const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& PublicInputs::l1_info_tree_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:aggregator.v1.PublicInputs.l1_info_tree_data)
  return _internal_l1_info_tree_data();
}
inline ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* PublicInputs::_internal_mutable_l1_info_tree_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.l1_info_tree_data_.MutableMap();
}
inline ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* PublicInputs::mutable_l1_info_tree_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:aggregator.v1.PublicInputs.l1_info_tree_data)
  return _internal_mutable_l1_info_tree_data();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StatelessPublicInputs

// bytes witness = 1;
inline void StatelessPublicInputs::clear_witness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_.ClearToEmpty();
}
inline const std::string& StatelessPublicInputs::witness() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.witness)
  return _internal_witness();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatelessPublicInputs::set_witness(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.witness)
}
inline std::string* StatelessPublicInputs::mutable_witness() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_witness();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessPublicInputs.witness)
  return _s;
}
inline const std::string& StatelessPublicInputs::_internal_witness() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.witness_.Get();
}
inline void StatelessPublicInputs::_internal_set_witness(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_.Set(value, GetArena());
}
inline std::string* StatelessPublicInputs::_internal_mutable_witness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.witness_.Mutable( GetArena());
}
inline std::string* StatelessPublicInputs::release_witness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessPublicInputs.witness)
  return _impl_.witness_.Release();
}
inline void StatelessPublicInputs::set_allocated_witness(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.witness_.IsDefault()) {
          _impl_.witness_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessPublicInputs.witness)
}

// bytes old_acc_input_hash = 2;
inline void StatelessPublicInputs::clear_old_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.ClearToEmpty();
}
inline const std::string& StatelessPublicInputs::old_acc_input_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.old_acc_input_hash)
  return _internal_old_acc_input_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatelessPublicInputs::set_old_acc_input_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.old_acc_input_hash)
}
inline std::string* StatelessPublicInputs::mutable_old_acc_input_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_old_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessPublicInputs.old_acc_input_hash)
  return _s;
}
inline const std::string& StatelessPublicInputs::_internal_old_acc_input_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.old_acc_input_hash_.Get();
}
inline void StatelessPublicInputs::_internal_set_old_acc_input_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.Set(value, GetArena());
}
inline std::string* StatelessPublicInputs::_internal_mutable_old_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.old_acc_input_hash_.Mutable( GetArena());
}
inline std::string* StatelessPublicInputs::release_old_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessPublicInputs.old_acc_input_hash)
  return _impl_.old_acc_input_hash_.Release();
}
inline void StatelessPublicInputs::set_allocated_old_acc_input_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_acc_input_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.old_acc_input_hash_.IsDefault()) {
          _impl_.old_acc_input_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessPublicInputs.old_acc_input_hash)
}

// uint64 old_batch_num = 3;
inline void StatelessPublicInputs::clear_old_batch_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_batch_num_ = ::uint64_t{0u};
}
inline ::uint64_t StatelessPublicInputs::old_batch_num() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.old_batch_num)
  return _internal_old_batch_num();
}
inline void StatelessPublicInputs::set_old_batch_num(::uint64_t value) {
  _internal_set_old_batch_num(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.old_batch_num)
}
inline ::uint64_t StatelessPublicInputs::_internal_old_batch_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.old_batch_num_;
}
inline void StatelessPublicInputs::_internal_set_old_batch_num(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.old_batch_num_ = value;
}

// uint64 chain_id = 4;
inline void StatelessPublicInputs::clear_chain_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t StatelessPublicInputs::chain_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.chain_id)
  return _internal_chain_id();
}
inline void StatelessPublicInputs::set_chain_id(::uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.chain_id)
}
inline ::uint64_t StatelessPublicInputs::_internal_chain_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chain_id_;
}
inline void StatelessPublicInputs::_internal_set_chain_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chain_id_ = value;
}

// uint64 fork_id = 5;
inline void StatelessPublicInputs::clear_fork_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fork_id_ = ::uint64_t{0u};
}
inline ::uint64_t StatelessPublicInputs::fork_id() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.fork_id)
  return _internal_fork_id();
}
inline void StatelessPublicInputs::set_fork_id(::uint64_t value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.fork_id)
}
inline ::uint64_t StatelessPublicInputs::_internal_fork_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fork_id_;
}
inline void StatelessPublicInputs::_internal_set_fork_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fork_id_ = value;
}

// bytes batch_l2_data = 6;
inline void StatelessPublicInputs::clear_batch_l2_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.ClearToEmpty();
}
inline const std::string& StatelessPublicInputs::batch_l2_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.batch_l2_data)
  return _internal_batch_l2_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatelessPublicInputs::set_batch_l2_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.batch_l2_data)
}
inline std::string* StatelessPublicInputs::mutable_batch_l2_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_batch_l2_data();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessPublicInputs.batch_l2_data)
  return _s;
}
inline const std::string& StatelessPublicInputs::_internal_batch_l2_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.batch_l2_data_.Get();
}
inline void StatelessPublicInputs::_internal_set_batch_l2_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.Set(value, GetArena());
}
inline std::string* StatelessPublicInputs::_internal_mutable_batch_l2_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.batch_l2_data_.Mutable( GetArena());
}
inline std::string* StatelessPublicInputs::release_batch_l2_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessPublicInputs.batch_l2_data)
  return _impl_.batch_l2_data_.Release();
}
inline void StatelessPublicInputs::set_allocated_batch_l2_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_l2_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.batch_l2_data_.IsDefault()) {
          _impl_.batch_l2_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessPublicInputs.batch_l2_data)
}

// bytes l1_info_root = 7;
inline void StatelessPublicInputs::clear_l1_info_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.ClearToEmpty();
}
inline const std::string& StatelessPublicInputs::l1_info_root() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.l1_info_root)
  return _internal_l1_info_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatelessPublicInputs::set_l1_info_root(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.l1_info_root)
}
inline std::string* StatelessPublicInputs::mutable_l1_info_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_l1_info_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessPublicInputs.l1_info_root)
  return _s;
}
inline const std::string& StatelessPublicInputs::_internal_l1_info_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.l1_info_root_.Get();
}
inline void StatelessPublicInputs::_internal_set_l1_info_root(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.Set(value, GetArena());
}
inline std::string* StatelessPublicInputs::_internal_mutable_l1_info_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.l1_info_root_.Mutable( GetArena());
}
inline std::string* StatelessPublicInputs::release_l1_info_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessPublicInputs.l1_info_root)
  return _impl_.l1_info_root_.Release();
}
inline void StatelessPublicInputs::set_allocated_l1_info_root(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_root_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.l1_info_root_.IsDefault()) {
          _impl_.l1_info_root_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessPublicInputs.l1_info_root)
}

// uint64 timestamp_limit = 8;
inline void StatelessPublicInputs::clear_timestamp_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_limit_ = ::uint64_t{0u};
}
inline ::uint64_t StatelessPublicInputs::timestamp_limit() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.timestamp_limit)
  return _internal_timestamp_limit();
}
inline void StatelessPublicInputs::set_timestamp_limit(::uint64_t value) {
  _internal_set_timestamp_limit(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.timestamp_limit)
}
inline ::uint64_t StatelessPublicInputs::_internal_timestamp_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_limit_;
}
inline void StatelessPublicInputs::_internal_set_timestamp_limit(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_limit_ = value;
}

// string sequencer_addr = 9;
inline void StatelessPublicInputs::clear_sequencer_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.ClearToEmpty();
}
inline const std::string& StatelessPublicInputs::sequencer_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.sequencer_addr)
  return _internal_sequencer_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatelessPublicInputs::set_sequencer_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.sequencer_addr)
}
inline std::string* StatelessPublicInputs::mutable_sequencer_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sequencer_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessPublicInputs.sequencer_addr)
  return _s;
}
inline const std::string& StatelessPublicInputs::_internal_sequencer_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sequencer_addr_.Get();
}
inline void StatelessPublicInputs::_internal_set_sequencer_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.Set(value, GetArena());
}
inline std::string* StatelessPublicInputs::_internal_mutable_sequencer_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sequencer_addr_.Mutable( GetArena());
}
inline std::string* StatelessPublicInputs::release_sequencer_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessPublicInputs.sequencer_addr)
  return _impl_.sequencer_addr_.Release();
}
inline void StatelessPublicInputs::set_allocated_sequencer_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequencer_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sequencer_addr_.IsDefault()) {
          _impl_.sequencer_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessPublicInputs.sequencer_addr)
}

// bytes forced_blockhash_l1 = 10;
inline void StatelessPublicInputs::clear_forced_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.ClearToEmpty();
}
inline const std::string& StatelessPublicInputs::forced_blockhash_l1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.forced_blockhash_l1)
  return _internal_forced_blockhash_l1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatelessPublicInputs::set_forced_blockhash_l1(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.forced_blockhash_l1)
}
inline std::string* StatelessPublicInputs::mutable_forced_blockhash_l1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_forced_blockhash_l1();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessPublicInputs.forced_blockhash_l1)
  return _s;
}
inline const std::string& StatelessPublicInputs::_internal_forced_blockhash_l1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.forced_blockhash_l1_.Get();
}
inline void StatelessPublicInputs::_internal_set_forced_blockhash_l1(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.Set(value, GetArena());
}
inline std::string* StatelessPublicInputs::_internal_mutable_forced_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.forced_blockhash_l1_.Mutable( GetArena());
}
inline std::string* StatelessPublicInputs::release_forced_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessPublicInputs.forced_blockhash_l1)
  return _impl_.forced_blockhash_l1_.Release();
}
inline void StatelessPublicInputs::set_allocated_forced_blockhash_l1(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forced_blockhash_l1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.forced_blockhash_l1_.IsDefault()) {
          _impl_.forced_blockhash_l1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessPublicInputs.forced_blockhash_l1)
}

// string aggregator_addr = 11;
inline void StatelessPublicInputs::clear_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.ClearToEmpty();
}
inline const std::string& StatelessPublicInputs::aggregator_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessPublicInputs.aggregator_addr)
  return _internal_aggregator_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatelessPublicInputs::set_aggregator_addr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.StatelessPublicInputs.aggregator_addr)
}
inline std::string* StatelessPublicInputs::mutable_aggregator_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_aggregator_addr();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessPublicInputs.aggregator_addr)
  return _s;
}
inline const std::string& StatelessPublicInputs::_internal_aggregator_addr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggregator_addr_.Get();
}
inline void StatelessPublicInputs::_internal_set_aggregator_addr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.Set(value, GetArena());
}
inline std::string* StatelessPublicInputs::_internal_mutable_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aggregator_addr_.Mutable( GetArena());
}
inline std::string* StatelessPublicInputs::release_aggregator_addr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessPublicInputs.aggregator_addr)
  return _impl_.aggregator_addr_.Release();
}
inline void StatelessPublicInputs::set_allocated_aggregator_addr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregator_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aggregator_addr_.IsDefault()) {
          _impl_.aggregator_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessPublicInputs.aggregator_addr)
}

// map<uint32, .aggregator.v1.L1Data> l1_info_tree_data = 12;
inline int StatelessPublicInputs::_internal_l1_info_tree_data_size() const {
  return _internal_l1_info_tree_data().size();
}
inline int StatelessPublicInputs::l1_info_tree_data_size() const {
  return _internal_l1_info_tree_data_size();
}
inline void StatelessPublicInputs::clear_l1_info_tree_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.l1_info_tree_data_.Clear();
}
inline const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& StatelessPublicInputs::_internal_l1_info_tree_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.l1_info_tree_data_.GetMap();
}
inline const ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>& StatelessPublicInputs::l1_info_tree_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:aggregator.v1.StatelessPublicInputs.l1_info_tree_data)
  return _internal_l1_info_tree_data();
}
inline ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* StatelessPublicInputs::_internal_mutable_l1_info_tree_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.l1_info_tree_data_.MutableMap();
}
inline ::google::protobuf::Map<::uint32_t, ::aggregator::v1::L1Data>* StatelessPublicInputs::mutable_l1_info_tree_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:aggregator.v1.StatelessPublicInputs.l1_info_tree_data)
  return _internal_mutable_l1_info_tree_data();
}

// -------------------------------------------------------------------

// L1Data

// bytes global_exit_root = 1;
inline void L1Data::clear_global_exit_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_exit_root_.ClearToEmpty();
}
inline const std::string& L1Data::global_exit_root() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.L1Data.global_exit_root)
  return _internal_global_exit_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void L1Data::set_global_exit_root(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_exit_root_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.L1Data.global_exit_root)
}
inline std::string* L1Data::mutable_global_exit_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_global_exit_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.L1Data.global_exit_root)
  return _s;
}
inline const std::string& L1Data::_internal_global_exit_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.global_exit_root_.Get();
}
inline void L1Data::_internal_set_global_exit_root(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_exit_root_.Set(value, GetArena());
}
inline std::string* L1Data::_internal_mutable_global_exit_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.global_exit_root_.Mutable( GetArena());
}
inline std::string* L1Data::release_global_exit_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.L1Data.global_exit_root)
  return _impl_.global_exit_root_.Release();
}
inline void L1Data::set_allocated_global_exit_root(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_exit_root_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.global_exit_root_.IsDefault()) {
          _impl_.global_exit_root_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.L1Data.global_exit_root)
}

// bytes blockhash_l1 = 2;
inline void L1Data::clear_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_l1_.ClearToEmpty();
}
inline const std::string& L1Data::blockhash_l1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.L1Data.blockhash_l1)
  return _internal_blockhash_l1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void L1Data::set_blockhash_l1(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_l1_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.L1Data.blockhash_l1)
}
inline std::string* L1Data::mutable_blockhash_l1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_blockhash_l1();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.L1Data.blockhash_l1)
  return _s;
}
inline const std::string& L1Data::_internal_blockhash_l1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blockhash_l1_.Get();
}
inline void L1Data::_internal_set_blockhash_l1(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_l1_.Set(value, GetArena());
}
inline std::string* L1Data::_internal_mutable_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.blockhash_l1_.Mutable( GetArena());
}
inline std::string* L1Data::release_blockhash_l1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.L1Data.blockhash_l1)
  return _impl_.blockhash_l1_.Release();
}
inline void L1Data::set_allocated_blockhash_l1(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blockhash_l1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.blockhash_l1_.IsDefault()) {
          _impl_.blockhash_l1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.L1Data.blockhash_l1)
}

// uint32 min_timestamp = 3;
inline void L1Data::clear_min_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_timestamp_ = 0u;
}
inline ::uint32_t L1Data::min_timestamp() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.L1Data.min_timestamp)
  return _internal_min_timestamp();
}
inline void L1Data::set_min_timestamp(::uint32_t value) {
  _internal_set_min_timestamp(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.L1Data.min_timestamp)
}
inline ::uint32_t L1Data::_internal_min_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_timestamp_;
}
inline void L1Data::_internal_set_min_timestamp(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_timestamp_ = value;
}

// repeated bytes smt_proof = 4;
inline int L1Data::_internal_smt_proof_size() const {
  return _internal_smt_proof().size();
}
inline int L1Data::smt_proof_size() const {
  return _internal_smt_proof_size();
}
inline void L1Data::clear_smt_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.smt_proof_.Clear();
}
inline std::string* L1Data::add_smt_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_smt_proof()->Add();
  // @@protoc_insertion_point(field_add_mutable:aggregator.v1.L1Data.smt_proof)
  return _s;
}
inline const std::string& L1Data::smt_proof(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.L1Data.smt_proof)
  return _internal_smt_proof().Get(index);
}
inline std::string* L1Data::mutable_smt_proof(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:aggregator.v1.L1Data.smt_proof)
  return _internal_mutable_smt_proof()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void L1Data::set_smt_proof(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_smt_proof()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:aggregator.v1.L1Data.smt_proof)
}
template <typename Arg_, typename... Args_>
inline void L1Data::add_smt_proof(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_smt_proof(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:aggregator.v1.L1Data.smt_proof)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
L1Data::smt_proof() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:aggregator.v1.L1Data.smt_proof)
  return _internal_smt_proof();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
L1Data::mutable_smt_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:aggregator.v1.L1Data.smt_proof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_smt_proof();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
L1Data::_internal_smt_proof() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.smt_proof_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
L1Data::_internal_mutable_smt_proof() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.smt_proof_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InputProver

// .aggregator.v1.PublicInputs public_inputs = 1;
inline bool InputProver::has_public_inputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_inputs_ != nullptr);
  return value;
}
inline void InputProver::clear_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public_inputs_ != nullptr) _impl_.public_inputs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aggregator::v1::PublicInputs& InputProver::_internal_public_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::aggregator::v1::PublicInputs* p = _impl_.public_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::PublicInputs&>(::aggregator::v1::_PublicInputs_default_instance_);
}
inline const ::aggregator::v1::PublicInputs& InputProver::public_inputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.InputProver.public_inputs)
  return _internal_public_inputs();
}
inline void InputProver::unsafe_arena_set_allocated_public_inputs(::aggregator::v1::PublicInputs* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.public_inputs_);
  }
  _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::PublicInputs*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.InputProver.public_inputs)
}
inline ::aggregator::v1::PublicInputs* InputProver::release_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::PublicInputs* released = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::aggregator::v1::PublicInputs* InputProver::unsafe_arena_release_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.InputProver.public_inputs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::PublicInputs* temp = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
  return temp;
}
inline ::aggregator::v1::PublicInputs* InputProver::_internal_mutable_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public_inputs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::PublicInputs>(GetArena());
    _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::PublicInputs*>(p);
  }
  return _impl_.public_inputs_;
}
inline ::aggregator::v1::PublicInputs* InputProver::mutable_public_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::aggregator::v1::PublicInputs* _msg = _internal_mutable_public_inputs();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.InputProver.public_inputs)
  return _msg;
}
inline void InputProver::set_allocated_public_inputs(::aggregator::v1::PublicInputs* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.public_inputs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::PublicInputs*>(value);
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.InputProver.public_inputs)
}

// map<string, string> db = 4;
inline int InputProver::_internal_db_size() const {
  return _internal_db().size();
}
inline int InputProver::db_size() const {
  return _internal_db_size();
}
inline void InputProver::clear_db() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& InputProver::_internal_db() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.db_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& InputProver::db() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:aggregator.v1.InputProver.db)
  return _internal_db();
}
inline ::google::protobuf::Map<std::string, std::string>* InputProver::_internal_mutable_db() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.db_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* InputProver::mutable_db() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:aggregator.v1.InputProver.db)
  return _internal_mutable_db();
}

// map<string, string> contracts_bytecode = 5;
inline int InputProver::_internal_contracts_bytecode_size() const {
  return _internal_contracts_bytecode().size();
}
inline int InputProver::contracts_bytecode_size() const {
  return _internal_contracts_bytecode_size();
}
inline void InputProver::clear_contracts_bytecode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contracts_bytecode_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& InputProver::_internal_contracts_bytecode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contracts_bytecode_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& InputProver::contracts_bytecode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:aggregator.v1.InputProver.contracts_bytecode)
  return _internal_contracts_bytecode();
}
inline ::google::protobuf::Map<std::string, std::string>* InputProver::_internal_mutable_contracts_bytecode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contracts_bytecode_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* InputProver::mutable_contracts_bytecode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:aggregator.v1.InputProver.contracts_bytecode)
  return _internal_mutable_contracts_bytecode();
}

// -------------------------------------------------------------------

// StatelessInputProver

// .aggregator.v1.StatelessPublicInputs public_inputs = 1;
inline bool StatelessInputProver::has_public_inputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_inputs_ != nullptr);
  return value;
}
inline void StatelessInputProver::clear_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public_inputs_ != nullptr) _impl_.public_inputs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aggregator::v1::StatelessPublicInputs& StatelessInputProver::_internal_public_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::aggregator::v1::StatelessPublicInputs* p = _impl_.public_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::StatelessPublicInputs&>(::aggregator::v1::_StatelessPublicInputs_default_instance_);
}
inline const ::aggregator::v1::StatelessPublicInputs& StatelessInputProver::public_inputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.StatelessInputProver.public_inputs)
  return _internal_public_inputs();
}
inline void StatelessInputProver::unsafe_arena_set_allocated_public_inputs(::aggregator::v1::StatelessPublicInputs* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.public_inputs_);
  }
  _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::StatelessPublicInputs*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.StatelessInputProver.public_inputs)
}
inline ::aggregator::v1::StatelessPublicInputs* StatelessInputProver::release_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::StatelessPublicInputs* released = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::aggregator::v1::StatelessPublicInputs* StatelessInputProver::unsafe_arena_release_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.StatelessInputProver.public_inputs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::StatelessPublicInputs* temp = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
  return temp;
}
inline ::aggregator::v1::StatelessPublicInputs* StatelessInputProver::_internal_mutable_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public_inputs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::StatelessPublicInputs>(GetArena());
    _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::StatelessPublicInputs*>(p);
  }
  return _impl_.public_inputs_;
}
inline ::aggregator::v1::StatelessPublicInputs* StatelessInputProver::mutable_public_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::aggregator::v1::StatelessPublicInputs* _msg = _internal_mutable_public_inputs();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.StatelessInputProver.public_inputs)
  return _msg;
}
inline void StatelessInputProver::set_allocated_public_inputs(::aggregator::v1::StatelessPublicInputs* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.public_inputs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::StatelessPublicInputs*>(value);
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.StatelessInputProver.public_inputs)
}

// -------------------------------------------------------------------

// PublicInputsExtended

// .aggregator.v1.PublicInputs public_inputs = 1;
inline bool PublicInputsExtended::has_public_inputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.public_inputs_ != nullptr);
  return value;
}
inline void PublicInputsExtended::clear_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public_inputs_ != nullptr) _impl_.public_inputs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::aggregator::v1::PublicInputs& PublicInputsExtended::_internal_public_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::aggregator::v1::PublicInputs* p = _impl_.public_inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::aggregator::v1::PublicInputs&>(::aggregator::v1::_PublicInputs_default_instance_);
}
inline const ::aggregator::v1::PublicInputs& PublicInputsExtended::public_inputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.public_inputs)
  return _internal_public_inputs();
}
inline void PublicInputsExtended::unsafe_arena_set_allocated_public_inputs(::aggregator::v1::PublicInputs* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.public_inputs_);
  }
  _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::PublicInputs*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aggregator.v1.PublicInputsExtended.public_inputs)
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::release_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::PublicInputs* released = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::unsafe_arena_release_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.public_inputs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::aggregator::v1::PublicInputs* temp = _impl_.public_inputs_;
  _impl_.public_inputs_ = nullptr;
  return temp;
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::_internal_mutable_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.public_inputs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::aggregator::v1::PublicInputs>(GetArena());
    _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::PublicInputs*>(p);
  }
  return _impl_.public_inputs_;
}
inline ::aggregator::v1::PublicInputs* PublicInputsExtended::mutable_public_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::aggregator::v1::PublicInputs* _msg = _internal_mutable_public_inputs();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.public_inputs)
  return _msg;
}
inline void PublicInputsExtended::set_allocated_public_inputs(::aggregator::v1::PublicInputs* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.public_inputs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.public_inputs_ = reinterpret_cast<::aggregator::v1::PublicInputs*>(value);
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.public_inputs)
}

// bytes new_state_root = 2;
inline void PublicInputsExtended::clear_new_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& PublicInputsExtended::new_state_root() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_state_root)
  return _internal_new_state_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputsExtended::set_new_state_root(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_root_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_state_root)
}
inline std::string* PublicInputsExtended::mutable_new_state_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.new_state_root)
  return _s;
}
inline const std::string& PublicInputsExtended::_internal_new_state_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_state_root_.Get();
}
inline void PublicInputsExtended::_internal_set_new_state_root(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_root_.Set(value, GetArena());
}
inline std::string* PublicInputsExtended::_internal_mutable_new_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_state_root_.Mutable( GetArena());
}
inline std::string* PublicInputsExtended::release_new_state_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void PublicInputsExtended::set_allocated_new_state_root(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_root_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_state_root_.IsDefault()) {
          _impl_.new_state_root_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.new_state_root)
}

// bytes new_acc_input_hash = 3;
inline void PublicInputsExtended::clear_new_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_acc_input_hash_.ClearToEmpty();
}
inline const std::string& PublicInputsExtended::new_acc_input_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
  return _internal_new_acc_input_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputsExtended::set_new_acc_input_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_acc_input_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
}
inline std::string* PublicInputsExtended::mutable_new_acc_input_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_acc_input_hash();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
  return _s;
}
inline const std::string& PublicInputsExtended::_internal_new_acc_input_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_acc_input_hash_.Get();
}
inline void PublicInputsExtended::_internal_set_new_acc_input_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_acc_input_hash_.Set(value, GetArena());
}
inline std::string* PublicInputsExtended::_internal_mutable_new_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_acc_input_hash_.Mutable( GetArena());
}
inline std::string* PublicInputsExtended::release_new_acc_input_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
  return _impl_.new_acc_input_hash_.Release();
}
inline void PublicInputsExtended::set_allocated_new_acc_input_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_acc_input_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_acc_input_hash_.IsDefault()) {
          _impl_.new_acc_input_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.new_acc_input_hash)
}

// bytes new_local_exit_root = 4;
inline void PublicInputsExtended::clear_new_local_exit_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_local_exit_root_.ClearToEmpty();
}
inline const std::string& PublicInputsExtended::new_local_exit_root() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_local_exit_root)
  return _internal_new_local_exit_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicInputsExtended::set_new_local_exit_root(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_local_exit_root_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_local_exit_root)
}
inline std::string* PublicInputsExtended::mutable_new_local_exit_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_local_exit_root();
  // @@protoc_insertion_point(field_mutable:aggregator.v1.PublicInputsExtended.new_local_exit_root)
  return _s;
}
inline const std::string& PublicInputsExtended::_internal_new_local_exit_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_local_exit_root_.Get();
}
inline void PublicInputsExtended::_internal_set_new_local_exit_root(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_local_exit_root_.Set(value, GetArena());
}
inline std::string* PublicInputsExtended::_internal_mutable_new_local_exit_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_local_exit_root_.Mutable( GetArena());
}
inline std::string* PublicInputsExtended::release_new_local_exit_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:aggregator.v1.PublicInputsExtended.new_local_exit_root)
  return _impl_.new_local_exit_root_.Release();
}
inline void PublicInputsExtended::set_allocated_new_local_exit_root(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_local_exit_root_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_local_exit_root_.IsDefault()) {
          _impl_.new_local_exit_root_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:aggregator.v1.PublicInputsExtended.new_local_exit_root)
}

// uint64 new_batch_num = 5;
inline void PublicInputsExtended::clear_new_batch_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_batch_num_ = ::uint64_t{0u};
}
inline ::uint64_t PublicInputsExtended::new_batch_num() const {
  // @@protoc_insertion_point(field_get:aggregator.v1.PublicInputsExtended.new_batch_num)
  return _internal_new_batch_num();
}
inline void PublicInputsExtended::set_new_batch_num(::uint64_t value) {
  _internal_set_new_batch_num(value);
  // @@protoc_insertion_point(field_set:aggregator.v1.PublicInputsExtended.new_batch_num)
}
inline ::uint64_t PublicInputsExtended::_internal_new_batch_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_batch_num_;
}
inline void PublicInputsExtended::_internal_set_new_batch_num(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_batch_num_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace aggregator


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::aggregator::v1::GetStatusResponse_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aggregator::v1::GetStatusResponse_Status>() {
  return ::aggregator::v1::GetStatusResponse_Status_descriptor();
}
template <>
struct is_proto_enum<::aggregator::v1::GetProofResponse_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aggregator::v1::GetProofResponse_Result>() {
  return ::aggregator::v1::GetProofResponse_Result_descriptor();
}
template <>
struct is_proto_enum<::aggregator::v1::Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::aggregator::v1::Result>() {
  return ::aggregator::v1::Result_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_aggregator_2eproto_2epb_2eh
