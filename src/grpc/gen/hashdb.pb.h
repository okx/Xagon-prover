// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hashdb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hashdb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hashdb_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hashdb_2eproto;
namespace hashdb {
namespace v1 {
class CancelBatchRequest;
struct CancelBatchRequestDefaultTypeInternal;
extern CancelBatchRequestDefaultTypeInternal _CancelBatchRequest_default_instance_;
class CancelBatchResponse;
struct CancelBatchResponseDefaultTypeInternal;
extern CancelBatchResponseDefaultTypeInternal _CancelBatchResponse_default_instance_;
class ConsolidateStateRequest;
struct ConsolidateStateRequestDefaultTypeInternal;
extern ConsolidateStateRequestDefaultTypeInternal _ConsolidateStateRequest_default_instance_;
class ConsolidateStateResponse;
struct ConsolidateStateResponseDefaultTypeInternal;
extern ConsolidateStateResponseDefaultTypeInternal _ConsolidateStateResponse_default_instance_;
class FeList;
struct FeListDefaultTypeInternal;
extern FeListDefaultTypeInternal _FeList_default_instance_;
class Fea;
struct FeaDefaultTypeInternal;
extern FeaDefaultTypeInternal _Fea_default_instance_;
class Fea12;
struct Fea12DefaultTypeInternal;
extern Fea12DefaultTypeInternal _Fea12_default_instance_;
class FinishBlockRequest;
struct FinishBlockRequestDefaultTypeInternal;
extern FinishBlockRequestDefaultTypeInternal _FinishBlockRequest_default_instance_;
class FinishTxRequest;
struct FinishTxRequestDefaultTypeInternal;
extern FinishTxRequestDefaultTypeInternal _FinishTxRequest_default_instance_;
class FlushRequest;
struct FlushRequestDefaultTypeInternal;
extern FlushRequestDefaultTypeInternal _FlushRequest_default_instance_;
class FlushResponse;
struct FlushResponseDefaultTypeInternal;
extern FlushResponseDefaultTypeInternal _FlushResponse_default_instance_;
class GetFlushDataRequest;
struct GetFlushDataRequestDefaultTypeInternal;
extern GetFlushDataRequestDefaultTypeInternal _GetFlushDataRequest_default_instance_;
class GetFlushDataResponse;
struct GetFlushDataResponseDefaultTypeInternal;
extern GetFlushDataResponseDefaultTypeInternal _GetFlushDataResponse_default_instance_;
class GetFlushDataResponse_NodesEntry_DoNotUse;
struct GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_;
class GetFlushDataResponse_ProgramEntry_DoNotUse;
struct GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_;
class GetFlushStatusResponse;
struct GetFlushStatusResponseDefaultTypeInternal;
extern GetFlushStatusResponseDefaultTypeInternal _GetFlushStatusResponse_default_instance_;
class GetLatestStateRootResponse;
struct GetLatestStateRootResponseDefaultTypeInternal;
extern GetLatestStateRootResponseDefaultTypeInternal _GetLatestStateRootResponse_default_instance_;
class GetProgramRequest;
struct GetProgramRequestDefaultTypeInternal;
extern GetProgramRequestDefaultTypeInternal _GetProgramRequest_default_instance_;
class GetProgramResponse;
struct GetProgramResponseDefaultTypeInternal;
extern GetProgramResponseDefaultTypeInternal _GetProgramResponse_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class GetResponse_DbReadLogEntry_DoNotUse;
struct GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _GetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class GetResponse_SiblingsEntry_DoNotUse;
struct GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _GetResponse_SiblingsEntry_DoNotUse_default_instance_;
class HashValueGL;
struct HashValueGLDefaultTypeInternal;
extern HashValueGLDefaultTypeInternal _HashValueGL_default_instance_;
class KeyValue;
struct KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class LoadDBRequest;
struct LoadDBRequestDefaultTypeInternal;
extern LoadDBRequestDefaultTypeInternal _LoadDBRequest_default_instance_;
class LoadDBRequest_InputDbEntry_DoNotUse;
struct LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal;
extern LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal _LoadDBRequest_InputDbEntry_DoNotUse_default_instance_;
class LoadProgramDBRequest;
struct LoadProgramDBRequestDefaultTypeInternal;
extern LoadProgramDBRequestDefaultTypeInternal _LoadProgramDBRequest_default_instance_;
class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse;
struct LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal;
extern LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal _LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_;
class PurgeRequest;
struct PurgeRequestDefaultTypeInternal;
extern PurgeRequestDefaultTypeInternal _PurgeRequest_default_instance_;
class PurgeResponse;
struct PurgeResponseDefaultTypeInternal;
extern PurgeResponseDefaultTypeInternal _PurgeResponse_default_instance_;
class ReadTreeRequest;
struct ReadTreeRequestDefaultTypeInternal;
extern ReadTreeRequestDefaultTypeInternal _ReadTreeRequest_default_instance_;
class ReadTreeResponse;
struct ReadTreeResponseDefaultTypeInternal;
extern ReadTreeResponseDefaultTypeInternal _ReadTreeResponse_default_instance_;
class ResetDBResponse;
struct ResetDBResponseDefaultTypeInternal;
extern ResetDBResponseDefaultTypeInternal _ResetDBResponse_default_instance_;
class ResultCode;
struct ResultCodeDefaultTypeInternal;
extern ResultCodeDefaultTypeInternal _ResultCode_default_instance_;
class SetProgramRequest;
struct SetProgramRequestDefaultTypeInternal;
extern SetProgramRequestDefaultTypeInternal _SetProgramRequest_default_instance_;
class SetProgramResponse;
struct SetProgramResponseDefaultTypeInternal;
extern SetProgramResponseDefaultTypeInternal _SetProgramResponse_default_instance_;
class SetRequest;
struct SetRequestDefaultTypeInternal;
extern SetRequestDefaultTypeInternal _SetRequest_default_instance_;
class SetResponse;
struct SetResponseDefaultTypeInternal;
extern SetResponseDefaultTypeInternal _SetResponse_default_instance_;
class SetResponse_DbReadLogEntry_DoNotUse;
struct SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _SetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class SetResponse_SiblingsEntry_DoNotUse;
struct SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _SetResponse_SiblingsEntry_DoNotUse_default_instance_;
class SiblingList;
struct SiblingListDefaultTypeInternal;
extern SiblingListDefaultTypeInternal _SiblingList_default_instance_;
class StartBlockRequest;
struct StartBlockRequestDefaultTypeInternal;
extern StartBlockRequestDefaultTypeInternal _StartBlockRequest_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace v1
}  // namespace hashdb
PROTOBUF_NAMESPACE_OPEN
template<> ::hashdb::v1::CancelBatchRequest* Arena::CreateMaybeMessage<::hashdb::v1::CancelBatchRequest>(Arena*);
template<> ::hashdb::v1::CancelBatchResponse* Arena::CreateMaybeMessage<::hashdb::v1::CancelBatchResponse>(Arena*);
template<> ::hashdb::v1::ConsolidateStateRequest* Arena::CreateMaybeMessage<::hashdb::v1::ConsolidateStateRequest>(Arena*);
template<> ::hashdb::v1::ConsolidateStateResponse* Arena::CreateMaybeMessage<::hashdb::v1::ConsolidateStateResponse>(Arena*);
template<> ::hashdb::v1::FeList* Arena::CreateMaybeMessage<::hashdb::v1::FeList>(Arena*);
template<> ::hashdb::v1::Fea* Arena::CreateMaybeMessage<::hashdb::v1::Fea>(Arena*);
template<> ::hashdb::v1::Fea12* Arena::CreateMaybeMessage<::hashdb::v1::Fea12>(Arena*);
template<> ::hashdb::v1::FinishBlockRequest* Arena::CreateMaybeMessage<::hashdb::v1::FinishBlockRequest>(Arena*);
template<> ::hashdb::v1::FinishTxRequest* Arena::CreateMaybeMessage<::hashdb::v1::FinishTxRequest>(Arena*);
template<> ::hashdb::v1::FlushRequest* Arena::CreateMaybeMessage<::hashdb::v1::FlushRequest>(Arena*);
template<> ::hashdb::v1::FlushResponse* Arena::CreateMaybeMessage<::hashdb::v1::FlushResponse>(Arena*);
template<> ::hashdb::v1::GetFlushDataRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataRequest>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetFlushStatusResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushStatusResponse>(Arena*);
template<> ::hashdb::v1::GetLatestStateRootResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetLatestStateRootResponse>(Arena*);
template<> ::hashdb::v1::GetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramRequest>(Arena*);
template<> ::hashdb::v1::GetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramResponse>(Arena*);
template<> ::hashdb::v1::GetRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetRequest>(Arena*);
template<> ::hashdb::v1::GetResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse>(Arena*);
template<> ::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::HashValueGL* Arena::CreateMaybeMessage<::hashdb::v1::HashValueGL>(Arena*);
template<> ::hashdb::v1::KeyValue* Arena::CreateMaybeMessage<::hashdb::v1::KeyValue>(Arena*);
template<> ::hashdb::v1::LoadDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest>(Arena*);
template<> ::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::LoadProgramDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest>(Arena*);
template<> ::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::PurgeRequest* Arena::CreateMaybeMessage<::hashdb::v1::PurgeRequest>(Arena*);
template<> ::hashdb::v1::PurgeResponse* Arena::CreateMaybeMessage<::hashdb::v1::PurgeResponse>(Arena*);
template<> ::hashdb::v1::ReadTreeRequest* Arena::CreateMaybeMessage<::hashdb::v1::ReadTreeRequest>(Arena*);
template<> ::hashdb::v1::ReadTreeResponse* Arena::CreateMaybeMessage<::hashdb::v1::ReadTreeResponse>(Arena*);
template<> ::hashdb::v1::ResetDBResponse* Arena::CreateMaybeMessage<::hashdb::v1::ResetDBResponse>(Arena*);
template<> ::hashdb::v1::ResultCode* Arena::CreateMaybeMessage<::hashdb::v1::ResultCode>(Arena*);
template<> ::hashdb::v1::SetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramRequest>(Arena*);
template<> ::hashdb::v1::SetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramResponse>(Arena*);
template<> ::hashdb::v1::SetRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetRequest>(Arena*);
template<> ::hashdb::v1::SetResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse>(Arena*);
template<> ::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse>(Arena*);
template<> ::hashdb::v1::SiblingList* Arena::CreateMaybeMessage<::hashdb::v1::SiblingList>(Arena*);
template<> ::hashdb::v1::StartBlockRequest* Arena::CreateMaybeMessage<::hashdb::v1::StartBlockRequest>(Arena*);
template<> ::hashdb::v1::Version* Arena::CreateMaybeMessage<::hashdb::v1::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hashdb {
namespace v1 {

enum ResultCode_Code : int {
  ResultCode_Code_CODE_UNSPECIFIED = 0,
  ResultCode_Code_CODE_SUCCESS = 1,
  ResultCode_Code_CODE_DB_KEY_NOT_FOUND = 2,
  ResultCode_Code_CODE_DB_ERROR = 3,
  ResultCode_Code_CODE_INTERNAL_ERROR = 4,
  ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE = 14,
  ResultCode_Code_ResultCode_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResultCode_Code_ResultCode_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResultCode_Code_IsValid(int value);
constexpr ResultCode_Code ResultCode_Code_Code_MIN = ResultCode_Code_CODE_UNSPECIFIED;
constexpr ResultCode_Code ResultCode_Code_Code_MAX = ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE;
constexpr int ResultCode_Code_Code_ARRAYSIZE = ResultCode_Code_Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultCode_Code_descriptor();
template<typename T>
inline const std::string& ResultCode_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResultCode_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResultCode_Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResultCode_Code_descriptor(), enum_t_value);
}
inline bool ResultCode_Code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResultCode_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResultCode_Code>(
    ResultCode_Code_descriptor(), name, value);
}
enum Persistence : int {
  PERSISTENCE_CACHE_UNSPECIFIED = 0,
  PERSISTENCE_DATABASE = 1,
  PERSISTENCE_TEMPORARY = 2,
  Persistence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Persistence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Persistence_IsValid(int value);
constexpr Persistence Persistence_MIN = PERSISTENCE_CACHE_UNSPECIFIED;
constexpr Persistence Persistence_MAX = PERSISTENCE_TEMPORARY;
constexpr int Persistence_ARRAYSIZE = Persistence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Persistence_descriptor();
template<typename T>
inline const std::string& Persistence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Persistence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Persistence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Persistence_descriptor(), enum_t_value);
}
inline bool Persistence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Persistence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Persistence>(
    Persistence_descriptor(), name, value);
}
// ===================================================================

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV001FieldNumber = 1,
  };
  // string v0_0_1 = 1;
  void clear_v0_0_1();
  const std::string& v0_0_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v0_0_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v0_0_1();
  PROTOBUF_NODISCARD std::string* release_v0_0_1();
  void set_allocated_v0_0_1(std::string* v0_0_1);
  private:
  const std::string& _internal_v0_0_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v0_0_1(const std::string& value);
  std::string* _internal_mutable_v0_0_1();
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v0_0_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetRequest) */ {
 public:
  inline SetRequest() : SetRequest(nullptr) {}
  ~SetRequest() override;
  explicit PROTOBUF_CONSTEXPR SetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetRequest(const SetRequest& from);
  SetRequest(SetRequest&& from) noexcept
    : SetRequest() {
    *this = ::std::move(from);
  }

  inline SetRequest& operator=(const SetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRequest& operator=(SetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetRequest* internal_default_instance() {
    return reinterpret_cast<const SetRequest*>(
               &_SetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetRequest& a, SetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetRequest& from) {
    SetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetRequest";
  }
  protected:
  explicit SetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kBatchUuidFieldNumber = 7,
    kOldRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kPersistenceFieldNumber = 4,
    kDetailsFieldNumber = 5,
    kGetDbReadLogFieldNumber = 6,
    kTxIndexFieldNumber = 8,
    kBlockIndexFieldNumber = 9,
  };
  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string batch_uuid = 7;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  private:
  bool _internal_has_old_root() const;
  public:
  void clear_old_root();
  const ::hashdb::v1::Fea& old_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Persistence persistence = 4;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // bool details = 5;
  void clear_details();
  bool details() const;
  void set_details(bool value);
  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);
  public:

  // bool get_db_read_log = 6;
  void clear_get_db_read_log();
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);
  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);
  public:

  // uint64 tx_index = 8;
  void clear_tx_index();
  uint64_t tx_index() const;
  void set_tx_index(uint64_t value);
  private:
  uint64_t _internal_tx_index() const;
  void _internal_set_tx_index(uint64_t value);
  public:

  // uint64 block_index = 9;
  void clear_block_index();
  uint64_t block_index() const;
  void set_block_index(uint64_t value);
  private:
  uint64_t _internal_block_index() const;
  void _internal_set_block_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::hashdb::v1::Fea* old_root_;
    ::hashdb::v1::Fea* key_;
    int persistence_;
    bool details_;
    bool get_db_read_log_;
    uint64_t tx_index_;
    uint64_t block_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRequest& from) {
    GetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 5,
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kDetailsFieldNumber = 3,
    kGetDbReadLogFieldNumber = 4,
  };
  // string batch_uuid = 5;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::hashdb::v1::Fea& root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // bool details = 3;
  void clear_details();
  bool details() const;
  void set_details(bool value);
  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);
  public:

  // bool get_db_read_log = 4;
  void clear_get_db_read_log();
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);
  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::hashdb::v1::Fea* root_;
    ::hashdb::v1::Fea* key_;
    bool details_;
    bool get_db_read_log_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetProgramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramRequest) */ {
 public:
  inline SetProgramRequest() : SetProgramRequest(nullptr) {}
  ~SetProgramRequest() override;
  explicit PROTOBUF_CONSTEXPR SetProgramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProgramRequest(const SetProgramRequest& from);
  SetProgramRequest(SetProgramRequest&& from) noexcept
    : SetProgramRequest() {
    *this = ::std::move(from);
  }

  inline SetProgramRequest& operator=(const SetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramRequest& operator=(SetProgramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProgramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const SetProgramRequest*>(
               &_SetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetProgramRequest& a, SetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProgramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetProgramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetProgramRequest& from) {
    SetProgramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetProgramRequest";
  }
  protected:
  explicit SetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kBatchUuidFieldNumber = 4,
    kKeyFieldNumber = 1,
    kTxIndexFieldNumber = 5,
    kBlockIndexFieldNumber = 6,
    kPersistenceFieldNumber = 3,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string batch_uuid = 4;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // uint64 tx_index = 5;
  void clear_tx_index();
  uint64_t tx_index() const;
  void set_tx_index(uint64_t value);
  private:
  uint64_t _internal_tx_index() const;
  void _internal_set_tx_index(uint64_t value);
  public:

  // uint64 block_index = 6;
  void clear_block_index();
  uint64_t block_index() const;
  void set_block_index(uint64_t value);
  private:
  uint64_t _internal_block_index() const;
  void _internal_set_block_index(uint64_t value);
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::hashdb::v1::Fea* key_;
    uint64_t tx_index_;
    uint64_t block_index_;
    int persistence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetProgramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramRequest) */ {
 public:
  inline GetProgramRequest() : GetProgramRequest(nullptr) {}
  ~GetProgramRequest() override;
  explicit PROTOBUF_CONSTEXPR GetProgramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProgramRequest(const GetProgramRequest& from);
  GetProgramRequest(GetProgramRequest&& from) noexcept
    : GetProgramRequest() {
    *this = ::std::move(from);
  }

  inline GetProgramRequest& operator=(const GetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramRequest& operator=(GetProgramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProgramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const GetProgramRequest*>(
               &_GetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetProgramRequest& a, GetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProgramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProgramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProgramRequest& from) {
    GetProgramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetProgramRequest";
  }
  protected:
  explicit GetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // string batch_uuid = 2;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::hashdb::v1::Fea* key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadDBRequest_InputDbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LoadDBRequest_InputDbEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LoadDBRequest_InputDbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadDBRequest_InputDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadDBRequest_InputDbEntry_DoNotUse& other);
  static const LoadDBRequest_InputDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadDBRequest_InputDbEntry_DoNotUse*>(&_LoadDBRequest_InputDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadDBRequest.InputDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class LoadDBRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadDBRequest) */ {
 public:
  inline LoadDBRequest() : LoadDBRequest(nullptr) {}
  ~LoadDBRequest() override;
  explicit PROTOBUF_CONSTEXPR LoadDBRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadDBRequest(const LoadDBRequest& from);
  LoadDBRequest(LoadDBRequest&& from) noexcept
    : LoadDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadDBRequest& operator=(const LoadDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadDBRequest& operator=(LoadDBRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadDBRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadDBRequest*>(
               &_LoadDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadDBRequest& a, LoadDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadDBRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadDBRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadDBRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadDBRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadDBRequest& from) {
    LoadDBRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadDBRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.LoadDBRequest";
  }
  protected:
  explicit LoadDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputDbFieldNumber = 1,
    kStateRootFieldNumber = 3,
    kPersistentFieldNumber = 2,
  };
  // map<string, .hashdb.v1.FeList> input_db = 1;
  int input_db_size() const;
  private:
  int _internal_input_db_size() const;
  public:
  void clear_input_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_input_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_input_db();

  // .hashdb.v1.Fea state_root = 3;
  bool has_state_root() const;
  private:
  bool _internal_has_state_root() const;
  public:
  void clear_state_root();
  const ::hashdb::v1::Fea& state_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_state_root();
  ::hashdb::v1::Fea* mutable_state_root();
  void set_allocated_state_root(::hashdb::v1::Fea* state_root);
  private:
  const ::hashdb::v1::Fea& _internal_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_state_root();
  public:
  void unsafe_arena_set_allocated_state_root(
      ::hashdb::v1::Fea* state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_state_root();

  // bool persistent = 2;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadDBRequest_InputDbEntry_DoNotUse,
        std::string, ::hashdb::v1::FeList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> input_db_;
    ::hashdb::v1::Fea* state_root_;
    bool persistent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  LoadProgramDBRequest_InputProgramDbEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse& other);
  static const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse*>(&_LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadProgramDBRequest.InputProgramDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class LoadProgramDBRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadProgramDBRequest) */ {
 public:
  inline LoadProgramDBRequest() : LoadProgramDBRequest(nullptr) {}
  ~LoadProgramDBRequest() override;
  explicit PROTOBUF_CONSTEXPR LoadProgramDBRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadProgramDBRequest(const LoadProgramDBRequest& from);
  LoadProgramDBRequest(LoadProgramDBRequest&& from) noexcept
    : LoadProgramDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadProgramDBRequest& operator=(const LoadProgramDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadProgramDBRequest& operator=(LoadProgramDBRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadProgramDBRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadProgramDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadProgramDBRequest*>(
               &_LoadProgramDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoadProgramDBRequest& a, LoadProgramDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadProgramDBRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadProgramDBRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadProgramDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadProgramDBRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadProgramDBRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadProgramDBRequest& from) {
    LoadProgramDBRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadProgramDBRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.LoadProgramDBRequest";
  }
  protected:
  explicit LoadProgramDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputProgramDbFieldNumber = 1,
    kPersistentFieldNumber = 2,
  };
  // map<string, bytes> input_program_db = 1;
  int input_program_db_size() const;
  private:
  int _internal_input_program_db_size() const;
  public:
  void clear_input_program_db();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_input_program_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_input_program_db();

  // bool persistent = 2;
  void clear_persistent();
  bool persistent() const;
  void set_persistent(bool value);
  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadProgramDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadProgramDBRequest_InputProgramDbEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> input_program_db_;
    bool persistent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FlushRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FlushRequest) */ {
 public:
  inline FlushRequest() : FlushRequest(nullptr) {}
  ~FlushRequest() override;
  explicit PROTOBUF_CONSTEXPR FlushRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushRequest(const FlushRequest& from);
  FlushRequest(FlushRequest&& from) noexcept
    : FlushRequest() {
    *this = ::std::move(from);
  }

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushRequest& operator=(FlushRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushRequest* internal_default_instance() {
    return reinterpret_cast<const FlushRequest*>(
               &_FlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FlushRequest& a, FlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushRequest& from) {
    FlushRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FlushRequest";
  }
  protected:
  explicit FlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
    int persistence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FinishTxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FinishTxRequest) */ {
 public:
  inline FinishTxRequest() : FinishTxRequest(nullptr) {}
  ~FinishTxRequest() override;
  explicit PROTOBUF_CONSTEXPR FinishTxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinishTxRequest(const FinishTxRequest& from);
  FinishTxRequest(FinishTxRequest&& from) noexcept
    : FinishTxRequest() {
    *this = ::std::move(from);
  }

  inline FinishTxRequest& operator=(const FinishTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishTxRequest& operator=(FinishTxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinishTxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishTxRequest* internal_default_instance() {
    return reinterpret_cast<const FinishTxRequest*>(
               &_FinishTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FinishTxRequest& a, FinishTxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FinishTxRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishTxRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishTxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinishTxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FinishTxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FinishTxRequest& from) {
    FinishTxRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishTxRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FinishTxRequest";
  }
  protected:
  explicit FinishTxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FinishTxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
    int persistence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class StartBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.StartBlockRequest) */ {
 public:
  inline StartBlockRequest() : StartBlockRequest(nullptr) {}
  ~StartBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR StartBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartBlockRequest(const StartBlockRequest& from);
  StartBlockRequest(StartBlockRequest&& from) noexcept
    : StartBlockRequest() {
    *this = ::std::move(from);
  }

  inline StartBlockRequest& operator=(const StartBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartBlockRequest& operator=(StartBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartBlockRequest* internal_default_instance() {
    return reinterpret_cast<const StartBlockRequest*>(
               &_StartBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StartBlockRequest& a, StartBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartBlockRequest& from) {
    StartBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.StartBlockRequest";
  }
  protected:
  explicit StartBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kOldStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string old_state_root = 2;
  void clear_old_state_root();
  const std::string& old_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_state_root();
  PROTOBUF_NODISCARD std::string* release_old_state_root();
  void set_allocated_old_state_root(std::string* old_state_root);
  private:
  const std::string& _internal_old_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_state_root(const std::string& value);
  std::string* _internal_mutable_old_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.StartBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_state_root_;
    int persistence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FinishBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FinishBlockRequest) */ {
 public:
  inline FinishBlockRequest() : FinishBlockRequest(nullptr) {}
  ~FinishBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR FinishBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinishBlockRequest(const FinishBlockRequest& from);
  FinishBlockRequest(FinishBlockRequest&& from) noexcept
    : FinishBlockRequest() {
    *this = ::std::move(from);
  }

  inline FinishBlockRequest& operator=(const FinishBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishBlockRequest& operator=(FinishBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinishBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishBlockRequest* internal_default_instance() {
    return reinterpret_cast<const FinishBlockRequest*>(
               &_FinishBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FinishBlockRequest& a, FinishBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FinishBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinishBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FinishBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FinishBlockRequest& from) {
    FinishBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FinishBlockRequest";
  }
  protected:
  explicit FinishBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // string new_state_root = 2;
  void clear_new_state_root();
  const std::string& new_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_state_root();
  PROTOBUF_NODISCARD std::string* release_new_state_root();
  void set_allocated_new_state_root(std::string* new_state_root);
  private:
  const std::string& _internal_new_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_state_root(const std::string& value);
  std::string* _internal_mutable_new_state_root();
  public:

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FinishBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_state_root_;
    int persistence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataRequest) */ {
 public:
  inline GetFlushDataRequest() : GetFlushDataRequest(nullptr) {}
  ~GetFlushDataRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFlushDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushDataRequest(const GetFlushDataRequest& from);
  GetFlushDataRequest(GetFlushDataRequest&& from) noexcept
    : GetFlushDataRequest() {
    *this = ::std::move(from);
  }

  inline GetFlushDataRequest& operator=(const GetFlushDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataRequest& operator=(GetFlushDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushDataRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataRequest*>(
               &_GetFlushDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetFlushDataRequest& a, GetFlushDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushDataRequest& from) {
    GetFlushDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushDataRequest";
  }
  protected:
  explicit GetFlushDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlushIdFieldNumber = 1,
  };
  // uint64 flush_id = 1;
  void clear_flush_id();
  uint64_t flush_id() const;
  void set_flush_id(uint64_t value);
  private:
  uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t flush_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ConsolidateStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ConsolidateStateRequest) */ {
 public:
  inline ConsolidateStateRequest() : ConsolidateStateRequest(nullptr) {}
  ~ConsolidateStateRequest() override;
  explicit PROTOBUF_CONSTEXPR ConsolidateStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsolidateStateRequest(const ConsolidateStateRequest& from);
  ConsolidateStateRequest(ConsolidateStateRequest&& from) noexcept
    : ConsolidateStateRequest() {
    *this = ::std::move(from);
  }

  inline ConsolidateStateRequest& operator=(const ConsolidateStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsolidateStateRequest& operator=(ConsolidateStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsolidateStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsolidateStateRequest* internal_default_instance() {
    return reinterpret_cast<const ConsolidateStateRequest*>(
               &_ConsolidateStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ConsolidateStateRequest& a, ConsolidateStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsolidateStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsolidateStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsolidateStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsolidateStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsolidateStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConsolidateStateRequest& from) {
    ConsolidateStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsolidateStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ConsolidateStateRequest";
  }
  protected:
  explicit ConsolidateStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualStateRootFieldNumber = 1,
    kPersistenceFieldNumber = 2,
  };
  // .hashdb.v1.Fea virtual_state_root = 1;
  bool has_virtual_state_root() const;
  private:
  bool _internal_has_virtual_state_root() const;
  public:
  void clear_virtual_state_root();
  const ::hashdb::v1::Fea& virtual_state_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_virtual_state_root();
  ::hashdb::v1::Fea* mutable_virtual_state_root();
  void set_allocated_virtual_state_root(::hashdb::v1::Fea* virtual_state_root);
  private:
  const ::hashdb::v1::Fea& _internal_virtual_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_virtual_state_root();
  public:
  void unsafe_arena_set_allocated_virtual_state_root(
      ::hashdb::v1::Fea* virtual_state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_virtual_state_root();

  // .hashdb.v1.Persistence persistence = 2;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.ConsolidateStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::Fea* virtual_state_root_;
    int persistence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class PurgeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.PurgeRequest) */ {
 public:
  inline PurgeRequest() : PurgeRequest(nullptr) {}
  ~PurgeRequest() override;
  explicit PROTOBUF_CONSTEXPR PurgeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PurgeRequest(const PurgeRequest& from);
  PurgeRequest(PurgeRequest&& from) noexcept
    : PurgeRequest() {
    *this = ::std::move(from);
  }

  inline PurgeRequest& operator=(const PurgeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurgeRequest& operator=(PurgeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PurgeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PurgeRequest* internal_default_instance() {
    return reinterpret_cast<const PurgeRequest*>(
               &_PurgeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PurgeRequest& a, PurgeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PurgeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurgeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PurgeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PurgeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PurgeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PurgeRequest& from) {
    PurgeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurgeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.PurgeRequest";
  }
  protected:
  explicit PurgeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
    kNewStateRootFieldNumber = 2,
    kPersistenceFieldNumber = 3,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // .hashdb.v1.Fea new_state_root = 2;
  bool has_new_state_root() const;
  private:
  bool _internal_has_new_state_root() const;
  public:
  void clear_new_state_root();
  const ::hashdb::v1::Fea& new_state_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_new_state_root();
  ::hashdb::v1::Fea* mutable_new_state_root();
  void set_allocated_new_state_root(::hashdb::v1::Fea* new_state_root);
  private:
  const ::hashdb::v1::Fea& _internal_new_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_new_state_root();
  public:
  void unsafe_arena_set_allocated_new_state_root(
      ::hashdb::v1::Fea* new_state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_new_state_root();

  // .hashdb.v1.Persistence persistence = 3;
  void clear_persistence();
  ::hashdb::v1::Persistence persistence() const;
  void set_persistence(::hashdb::v1::Persistence value);
  private:
  ::hashdb::v1::Persistence _internal_persistence() const;
  void _internal_set_persistence(::hashdb::v1::Persistence value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.PurgeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    ::hashdb::v1::Fea* new_state_root_;
    int persistence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ReadTreeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ReadTreeRequest) */ {
 public:
  inline ReadTreeRequest() : ReadTreeRequest(nullptr) {}
  ~ReadTreeRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadTreeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadTreeRequest(const ReadTreeRequest& from);
  ReadTreeRequest(ReadTreeRequest&& from) noexcept
    : ReadTreeRequest() {
    *this = ::std::move(from);
  }

  inline ReadTreeRequest& operator=(const ReadTreeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadTreeRequest& operator=(ReadTreeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadTreeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadTreeRequest* internal_default_instance() {
    return reinterpret_cast<const ReadTreeRequest*>(
               &_ReadTreeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ReadTreeRequest& a, ReadTreeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadTreeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadTreeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadTreeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadTreeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadTreeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadTreeRequest& from) {
    ReadTreeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadTreeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ReadTreeRequest";
  }
  protected:
  explicit ReadTreeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kStateRootFieldNumber = 1,
  };
  // repeated .hashdb.v1.Fea keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::hashdb::v1::Fea* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >*
      mutable_keys();
  private:
  const ::hashdb::v1::Fea& _internal_keys(int index) const;
  ::hashdb::v1::Fea* _internal_add_keys();
  public:
  const ::hashdb::v1::Fea& keys(int index) const;
  ::hashdb::v1::Fea* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >&
      keys() const;

  // .hashdb.v1.Fea state_root = 1;
  bool has_state_root() const;
  private:
  bool _internal_has_state_root() const;
  public:
  void clear_state_root();
  const ::hashdb::v1::Fea& state_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_state_root();
  ::hashdb::v1::Fea* mutable_state_root();
  void set_allocated_state_root(::hashdb::v1::Fea* state_root);
  private:
  const ::hashdb::v1::Fea& _internal_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_state_root();
  public:
  void unsafe_arena_set_allocated_state_root(
      ::hashdb::v1::Fea* state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_state_root();

  // @@protoc_insertion_point(class_scope:hashdb.v1.ReadTreeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea > keys_;
    ::hashdb::v1::Fea* state_root_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class CancelBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.CancelBatchRequest) */ {
 public:
  inline CancelBatchRequest() : CancelBatchRequest(nullptr) {}
  ~CancelBatchRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelBatchRequest(const CancelBatchRequest& from);
  CancelBatchRequest(CancelBatchRequest&& from) noexcept
    : CancelBatchRequest() {
    *this = ::std::move(from);
  }

  inline CancelBatchRequest& operator=(const CancelBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBatchRequest& operator=(CancelBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelBatchRequest* internal_default_instance() {
    return reinterpret_cast<const CancelBatchRequest*>(
               &_CancelBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CancelBatchRequest& a, CancelBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelBatchRequest& from) {
    CancelBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.CancelBatchRequest";
  }
  protected:
  explicit CancelBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatchUuidFieldNumber = 1,
  };
  // string batch_uuid = 1;
  void clear_batch_uuid();
  const std::string& batch_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_batch_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_batch_uuid();
  PROTOBUF_NODISCARD std::string* release_batch_uuid();
  void set_allocated_batch_uuid(std::string* batch_uuid);
  private:
  const std::string& _internal_batch_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_batch_uuid(const std::string& value);
  std::string* _internal_mutable_batch_uuid();
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.CancelBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batch_uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetLatestStateRootResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetLatestStateRootResponse) */ {
 public:
  inline GetLatestStateRootResponse() : GetLatestStateRootResponse(nullptr) {}
  ~GetLatestStateRootResponse() override;
  explicit PROTOBUF_CONSTEXPR GetLatestStateRootResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestStateRootResponse(const GetLatestStateRootResponse& from);
  GetLatestStateRootResponse(GetLatestStateRootResponse&& from) noexcept
    : GetLatestStateRootResponse() {
    *this = ::std::move(from);
  }

  inline GetLatestStateRootResponse& operator=(const GetLatestStateRootResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestStateRootResponse& operator=(GetLatestStateRootResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestStateRootResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestStateRootResponse* internal_default_instance() {
    return reinterpret_cast<const GetLatestStateRootResponse*>(
               &_GetLatestStateRootResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetLatestStateRootResponse& a, GetLatestStateRootResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestStateRootResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestStateRootResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLatestStateRootResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLatestStateRootResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestStateRootResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLatestStateRootResponse& from) {
    GetLatestStateRootResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestStateRootResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetLatestStateRootResponse";
  }
  protected:
  explicit GetLatestStateRootResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestRootFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // .hashdb.v1.Fea latest_root = 1;
  bool has_latest_root() const;
  private:
  bool _internal_has_latest_root() const;
  public:
  void clear_latest_root();
  const ::hashdb::v1::Fea& latest_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_latest_root();
  ::hashdb::v1::Fea* mutable_latest_root();
  void set_allocated_latest_root(::hashdb::v1::Fea* latest_root);
  private:
  const ::hashdb::v1::Fea& _internal_latest_root() const;
  ::hashdb::v1::Fea* _internal_mutable_latest_root();
  public:
  void unsafe_arena_set_allocated_latest_root(
      ::hashdb::v1::Fea* latest_root);
  ::hashdb::v1::Fea* unsafe_arena_release_latest_root();

  // .hashdb.v1.ResultCode result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetLatestStateRootResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::Fea* latest_root_;
    ::hashdb::v1::ResultCode* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetResponse_SiblingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SetResponse_SiblingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SetResponse_SiblingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_SiblingsEntry_DoNotUse& other);
  static const SetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_SiblingsEntry_DoNotUse*>(&_SetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class SetResponse_DbReadLogEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SetResponse_DbReadLogEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SetResponse_DbReadLogEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_DbReadLogEntry_DoNotUse& other);
  static const SetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_DbReadLogEntry_DoNotUse*>(&_SetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.SetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class SetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetResponse) */ {
 public:
  inline SetResponse() : SetResponse(nullptr) {}
  ~SetResponse() override;
  explicit PROTOBUF_CONSTEXPR SetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetResponse(const SetResponse& from);
  SetResponse(SetResponse&& from) noexcept
    : SetResponse() {
    *this = ::std::move(from);
  }

  inline SetResponse& operator=(const SetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResponse& operator=(SetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetResponse* internal_default_instance() {
    return reinterpret_cast<const SetResponse*>(
               &_SetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SetResponse& a, SetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetResponse& from) {
    SetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetResponse";
  }
  protected:
  explicit SetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 4,
    kDbReadLogFieldNumber = 12,
    kInsValueFieldNumber = 6,
    kOldValueFieldNumber = 8,
    kNewValueFieldNumber = 9,
    kModeFieldNumber = 10,
    kOldRootFieldNumber = 1,
    kNewRootFieldNumber = 2,
    kKeyFieldNumber = 3,
    kInsKeyFieldNumber = 5,
    kResultFieldNumber = 13,
    kSiblingLeftChildFieldNumber = 14,
    kSiblingRightChildFieldNumber = 15,
    kProofHashCounterFieldNumber = 11,
    kIsOld0FieldNumber = 7,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 4;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;
  public:
  void clear_siblings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
      mutable_siblings();

  // map<string, .hashdb.v1.FeList> db_read_log = 12;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;
  public:
  void clear_db_read_log();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();

  // string ins_value = 6;
  void clear_ins_value();
  const std::string& ins_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ins_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ins_value();
  PROTOBUF_NODISCARD std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ins_value);
  private:
  const std::string& _internal_ins_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ins_value(const std::string& value);
  std::string* _internal_mutable_ins_value();
  public:

  // string old_value = 8;
  void clear_old_value();
  const std::string& old_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_value();
  PROTOBUF_NODISCARD std::string* release_old_value();
  void set_allocated_old_value(std::string* old_value);
  private:
  const std::string& _internal_old_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_value(const std::string& value);
  std::string* _internal_mutable_old_value();
  public:

  // string new_value = 9;
  void clear_new_value();
  const std::string& new_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_value();
  PROTOBUF_NODISCARD std::string* release_new_value();
  void set_allocated_new_value(std::string* new_value);
  private:
  const std::string& _internal_new_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_value(const std::string& value);
  std::string* _internal_mutable_new_value();
  public:

  // string mode = 10;
  void clear_mode();
  const std::string& mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  private:
  bool _internal_has_old_root() const;
  public:
  void clear_old_root();
  const ::hashdb::v1::Fea& old_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();

  // .hashdb.v1.Fea new_root = 2;
  bool has_new_root() const;
  private:
  bool _internal_has_new_root() const;
  public:
  void clear_new_root();
  const ::hashdb::v1::Fea& new_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_new_root();
  ::hashdb::v1::Fea* mutable_new_root();
  void set_allocated_new_root(::hashdb::v1::Fea* new_root);
  private:
  const ::hashdb::v1::Fea& _internal_new_root() const;
  ::hashdb::v1::Fea* _internal_mutable_new_root();
  public:
  void unsafe_arena_set_allocated_new_root(
      ::hashdb::v1::Fea* new_root);
  ::hashdb::v1::Fea* unsafe_arena_release_new_root();

  // .hashdb.v1.Fea key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Fea ins_key = 5;
  bool has_ins_key() const;
  private:
  bool _internal_has_ins_key() const;
  public:
  void clear_ins_key();
  const ::hashdb::v1::Fea& ins_key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();

  // .hashdb.v1.ResultCode result = 13;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // .hashdb.v1.Fea sibling_left_child = 14;
  bool has_sibling_left_child() const;
  private:
  bool _internal_has_sibling_left_child() const;
  public:
  void clear_sibling_left_child();
  const ::hashdb::v1::Fea& sibling_left_child() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_sibling_left_child();
  ::hashdb::v1::Fea* mutable_sibling_left_child();
  void set_allocated_sibling_left_child(::hashdb::v1::Fea* sibling_left_child);
  private:
  const ::hashdb::v1::Fea& _internal_sibling_left_child() const;
  ::hashdb::v1::Fea* _internal_mutable_sibling_left_child();
  public:
  void unsafe_arena_set_allocated_sibling_left_child(
      ::hashdb::v1::Fea* sibling_left_child);
  ::hashdb::v1::Fea* unsafe_arena_release_sibling_left_child();

  // .hashdb.v1.Fea sibling_right_child = 15;
  bool has_sibling_right_child() const;
  private:
  bool _internal_has_sibling_right_child() const;
  public:
  void clear_sibling_right_child();
  const ::hashdb::v1::Fea& sibling_right_child() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_sibling_right_child();
  ::hashdb::v1::Fea* mutable_sibling_right_child();
  void set_allocated_sibling_right_child(::hashdb::v1::Fea* sibling_right_child);
  private:
  const ::hashdb::v1::Fea& _internal_sibling_right_child() const;
  ::hashdb::v1::Fea* _internal_mutable_sibling_right_child();
  public:
  void unsafe_arena_set_allocated_sibling_right_child(
      ::hashdb::v1::Fea* sibling_right_child);
  ::hashdb::v1::Fea* unsafe_arena_release_sibling_right_child();

  // uint64 proof_hash_counter = 11;
  void clear_proof_hash_counter();
  uint64_t proof_hash_counter() const;
  void set_proof_hash_counter(uint64_t value);
  private:
  uint64_t _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(uint64_t value);
  public:

  // bool is_old0 = 7;
  void clear_is_old0();
  bool is_old0() const;
  void set_is_old0(bool value);
  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetResponse_SiblingsEntry_DoNotUse,
        uint64_t, ::hashdb::v1::SiblingList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> siblings_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetResponse_DbReadLogEntry_DoNotUse,
        std::string, ::hashdb::v1::FeList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> db_read_log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    ::hashdb::v1::Fea* old_root_;
    ::hashdb::v1::Fea* new_root_;
    ::hashdb::v1::Fea* key_;
    ::hashdb::v1::Fea* ins_key_;
    ::hashdb::v1::ResultCode* result_;
    ::hashdb::v1::Fea* sibling_left_child_;
    ::hashdb::v1::Fea* sibling_right_child_;
    uint64_t proof_hash_counter_;
    bool is_old0_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetResponse_SiblingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetResponse_SiblingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetResponse_SiblingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_SiblingsEntry_DoNotUse& other);
  static const GetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_SiblingsEntry_DoNotUse*>(&_GetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class GetResponse_DbReadLogEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetResponse_DbReadLogEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetResponse_DbReadLogEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_DbReadLogEntry_DoNotUse& other);
  static const GetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_DbReadLogEntry_DoNotUse*>(&_GetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponse& from) {
    GetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 3,
    kDbReadLogFieldNumber = 9,
    kInsValueFieldNumber = 5,
    kValueFieldNumber = 7,
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kInsKeyFieldNumber = 4,
    kResultFieldNumber = 10,
    kProofHashCounterFieldNumber = 8,
    kIsOld0FieldNumber = 6,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 3;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;
  public:
  void clear_siblings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
      mutable_siblings();

  // map<string, .hashdb.v1.FeList> db_read_log = 9;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;
  public:
  void clear_db_read_log();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();

  // string ins_value = 5;
  void clear_ins_value();
  const std::string& ins_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ins_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ins_value();
  PROTOBUF_NODISCARD std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ins_value);
  private:
  const std::string& _internal_ins_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ins_value(const std::string& value);
  std::string* _internal_mutable_ins_value();
  public:

  // string value = 7;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::hashdb::v1::Fea& root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();

  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // .hashdb.v1.Fea ins_key = 4;
  bool has_ins_key() const;
  private:
  bool _internal_has_ins_key() const;
  public:
  void clear_ins_key();
  const ::hashdb::v1::Fea& ins_key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();

  // .hashdb.v1.ResultCode result = 10;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 proof_hash_counter = 8;
  void clear_proof_hash_counter();
  uint64_t proof_hash_counter() const;
  void set_proof_hash_counter(uint64_t value);
  private:
  uint64_t _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(uint64_t value);
  public:

  // bool is_old0 = 6;
  void clear_is_old0();
  bool is_old0() const;
  void set_is_old0(bool value);
  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetResponse_SiblingsEntry_DoNotUse,
        uint64_t, ::hashdb::v1::SiblingList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> siblings_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetResponse_DbReadLogEntry_DoNotUse,
        std::string, ::hashdb::v1::FeList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> db_read_log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::hashdb::v1::Fea* root_;
    ::hashdb::v1::Fea* key_;
    ::hashdb::v1::Fea* ins_key_;
    ::hashdb::v1::ResultCode* result_;
    uint64_t proof_hash_counter_;
    bool is_old0_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetProgramResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramResponse) */ {
 public:
  inline SetProgramResponse() : SetProgramResponse(nullptr) {}
  ~SetProgramResponse() override;
  explicit PROTOBUF_CONSTEXPR SetProgramResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProgramResponse(const SetProgramResponse& from);
  SetProgramResponse(SetProgramResponse&& from) noexcept
    : SetProgramResponse() {
    *this = ::std::move(from);
  }

  inline SetProgramResponse& operator=(const SetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramResponse& operator=(SetProgramResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProgramResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const SetProgramResponse*>(
               &_SetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SetProgramResponse& a, SetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProgramResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetProgramResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetProgramResponse& from) {
    SetProgramResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SetProgramResponse";
  }
  protected:
  explicit SetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::ResultCode* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetProgramResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramResponse) */ {
 public:
  inline GetProgramResponse() : GetProgramResponse(nullptr) {}
  ~GetProgramResponse() override;
  explicit PROTOBUF_CONSTEXPR GetProgramResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProgramResponse(const GetProgramResponse& from);
  GetProgramResponse(GetProgramResponse&& from) noexcept
    : GetProgramResponse() {
    *this = ::std::move(from);
  }

  inline GetProgramResponse& operator=(const GetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramResponse& operator=(GetProgramResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProgramResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const GetProgramResponse*>(
               &_GetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetProgramResponse& a, GetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProgramResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProgramResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProgramResponse& from) {
    GetProgramResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetProgramResponse";
  }
  protected:
  explicit GetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .hashdb.v1.ResultCode result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::hashdb::v1::ResultCode* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FlushResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FlushResponse) */ {
 public:
  inline FlushResponse() : FlushResponse(nullptr) {}
  ~FlushResponse() override;
  explicit PROTOBUF_CONSTEXPR FlushResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushResponse(const FlushResponse& from);
  FlushResponse(FlushResponse&& from) noexcept
    : FlushResponse() {
    *this = ::std::move(from);
  }

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushResponse& operator=(FlushResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushResponse* internal_default_instance() {
    return reinterpret_cast<const FlushResponse*>(
               &_FlushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(FlushResponse& a, FlushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushResponse& from) {
    FlushResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FlushResponse";
  }
  protected:
  explicit FlushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kFlushIdFieldNumber = 1,
    kStoredFlushIdFieldNumber = 2,
  };
  // .hashdb.v1.ResultCode result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 flush_id = 1;
  void clear_flush_id();
  uint64_t flush_id() const;
  void set_flush_id(uint64_t value);
  private:
  uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(uint64_t value);
  public:

  // uint64 stored_flush_id = 2;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.FlushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::ResultCode* result_;
    uint64_t flush_id_;
    uint64_t stored_flush_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushStatusResponse) */ {
 public:
  inline GetFlushStatusResponse() : GetFlushStatusResponse(nullptr) {}
  ~GetFlushStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushStatusResponse(const GetFlushStatusResponse& from);
  GetFlushStatusResponse(GetFlushStatusResponse&& from) noexcept
    : GetFlushStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushStatusResponse& operator=(const GetFlushStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushStatusResponse& operator=(GetFlushStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushStatusResponse*>(
               &_GetFlushStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetFlushStatusResponse& a, GetFlushStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushStatusResponse& from) {
    GetFlushStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushStatusResponse";
  }
  protected:
  explicit GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProverIdFieldNumber = 8,
    kStoredFlushIdFieldNumber = 1,
    kStoringFlushIdFieldNumber = 2,
    kLastFlushIdFieldNumber = 3,
    kPendingToFlushNodesFieldNumber = 4,
    kPendingToFlushProgramFieldNumber = 5,
    kStoringNodesFieldNumber = 6,
    kStoringProgramFieldNumber = 7,
  };
  // string prover_id = 8;
  void clear_prover_id();
  const std::string& prover_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prover_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // uint64 storing_flush_id = 2;
  void clear_storing_flush_id();
  uint64_t storing_flush_id() const;
  void set_storing_flush_id(uint64_t value);
  private:
  uint64_t _internal_storing_flush_id() const;
  void _internal_set_storing_flush_id(uint64_t value);
  public:

  // uint64 last_flush_id = 3;
  void clear_last_flush_id();
  uint64_t last_flush_id() const;
  void set_last_flush_id(uint64_t value);
  private:
  uint64_t _internal_last_flush_id() const;
  void _internal_set_last_flush_id(uint64_t value);
  public:

  // uint64 pending_to_flush_nodes = 4;
  void clear_pending_to_flush_nodes();
  uint64_t pending_to_flush_nodes() const;
  void set_pending_to_flush_nodes(uint64_t value);
  private:
  uint64_t _internal_pending_to_flush_nodes() const;
  void _internal_set_pending_to_flush_nodes(uint64_t value);
  public:

  // uint64 pending_to_flush_program = 5;
  void clear_pending_to_flush_program();
  uint64_t pending_to_flush_program() const;
  void set_pending_to_flush_program(uint64_t value);
  private:
  uint64_t _internal_pending_to_flush_program() const;
  void _internal_set_pending_to_flush_program(uint64_t value);
  public:

  // uint64 storing_nodes = 6;
  void clear_storing_nodes();
  uint64_t storing_nodes() const;
  void set_storing_nodes(uint64_t value);
  private:
  uint64_t _internal_storing_nodes() const;
  void _internal_set_storing_nodes(uint64_t value);
  public:

  // uint64 storing_program = 7;
  void clear_storing_program();
  uint64_t storing_program() const;
  void set_storing_program(uint64_t value);
  private:
  uint64_t _internal_storing_program() const;
  void _internal_set_storing_program(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    uint64_t stored_flush_id_;
    uint64_t storing_flush_id_;
    uint64_t last_flush_id_;
    uint64_t pending_to_flush_nodes_;
    uint64_t pending_to_flush_program_;
    uint64_t storing_nodes_;
    uint64_t storing_program_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataResponse_NodesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetFlushDataResponse_NodesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetFlushDataResponse_NodesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetFlushDataResponse_NodesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_NodesEntry_DoNotUse& other);
  static const GetFlushDataResponse_NodesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_NodesEntry_DoNotUse*>(&_GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class GetFlushDataResponse_ProgramEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetFlushDataResponse_ProgramEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GetFlushDataResponse_ProgramEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetFlushDataResponse_ProgramEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_ProgramEntry_DoNotUse& other);
  static const GetFlushDataResponse_ProgramEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_ProgramEntry_DoNotUse*>(&_GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};

// -------------------------------------------------------------------

class GetFlushDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataResponse) */ {
 public:
  inline GetFlushDataResponse() : GetFlushDataResponse(nullptr) {}
  ~GetFlushDataResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFlushDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushDataResponse(const GetFlushDataResponse& from);
  GetFlushDataResponse(GetFlushDataResponse&& from) noexcept
    : GetFlushDataResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushDataResponse& operator=(const GetFlushDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataResponse& operator=(GetFlushDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushDataResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataResponse*>(
               &_GetFlushDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetFlushDataResponse& a, GetFlushDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushDataResponse& from) {
    GetFlushDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.GetFlushDataResponse";
  }
  protected:
  explicit GetFlushDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kProgramFieldNumber = 3,
    kNodesStateRootFieldNumber = 4,
    kResultFieldNumber = 5,
    kStoredFlushIdFieldNumber = 1,
  };
  // map<string, string> nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_nodes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_nodes();

  // map<string, string> program = 3;
  int program_size() const;
  private:
  int _internal_program_size() const;
  public:
  void clear_program();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_program();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_program();

  // string nodes_state_root = 4;
  void clear_nodes_state_root();
  const std::string& nodes_state_root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodes_state_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodes_state_root();
  PROTOBUF_NODISCARD std::string* release_nodes_state_root();
  void set_allocated_nodes_state_root(std::string* nodes_state_root);
  private:
  const std::string& _internal_nodes_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodes_state_root(const std::string& value);
  std::string* _internal_mutable_nodes_state_root();
  public:

  // .hashdb.v1.ResultCode result = 5;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetFlushDataResponse_NodesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> nodes_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetFlushDataResponse_ProgramEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> program_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodes_state_root_;
    ::hashdb::v1::ResultCode* result_;
    uint64_t stored_flush_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ConsolidateStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ConsolidateStateResponse) */ {
 public:
  inline ConsolidateStateResponse() : ConsolidateStateResponse(nullptr) {}
  ~ConsolidateStateResponse() override;
  explicit PROTOBUF_CONSTEXPR ConsolidateStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsolidateStateResponse(const ConsolidateStateResponse& from);
  ConsolidateStateResponse(ConsolidateStateResponse&& from) noexcept
    : ConsolidateStateResponse() {
    *this = ::std::move(from);
  }

  inline ConsolidateStateResponse& operator=(const ConsolidateStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsolidateStateResponse& operator=(ConsolidateStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsolidateStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsolidateStateResponse* internal_default_instance() {
    return reinterpret_cast<const ConsolidateStateResponse*>(
               &_ConsolidateStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ConsolidateStateResponse& a, ConsolidateStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsolidateStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsolidateStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsolidateStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsolidateStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsolidateStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConsolidateStateResponse& from) {
    ConsolidateStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsolidateStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ConsolidateStateResponse";
  }
  protected:
  explicit ConsolidateStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsolidatedStateRootFieldNumber = 1,
    kResultFieldNumber = 4,
    kFlushIdFieldNumber = 2,
    kStoredFlushIdFieldNumber = 3,
  };
  // .hashdb.v1.Fea consolidated_state_root = 1;
  bool has_consolidated_state_root() const;
  private:
  bool _internal_has_consolidated_state_root() const;
  public:
  void clear_consolidated_state_root();
  const ::hashdb::v1::Fea& consolidated_state_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_consolidated_state_root();
  ::hashdb::v1::Fea* mutable_consolidated_state_root();
  void set_allocated_consolidated_state_root(::hashdb::v1::Fea* consolidated_state_root);
  private:
  const ::hashdb::v1::Fea& _internal_consolidated_state_root() const;
  ::hashdb::v1::Fea* _internal_mutable_consolidated_state_root();
  public:
  void unsafe_arena_set_allocated_consolidated_state_root(
      ::hashdb::v1::Fea* consolidated_state_root);
  ::hashdb::v1::Fea* unsafe_arena_release_consolidated_state_root();

  // .hashdb.v1.ResultCode result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // uint64 flush_id = 2;
  void clear_flush_id();
  uint64_t flush_id() const;
  void set_flush_id(uint64_t value);
  private:
  uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(uint64_t value);
  public:

  // uint64 stored_flush_id = 3;
  void clear_stored_flush_id();
  uint64_t stored_flush_id() const;
  void set_stored_flush_id(uint64_t value);
  private:
  uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.ConsolidateStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::Fea* consolidated_state_root_;
    ::hashdb::v1::ResultCode* result_;
    uint64_t flush_id_;
    uint64_t stored_flush_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class PurgeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.PurgeResponse) */ {
 public:
  inline PurgeResponse() : PurgeResponse(nullptr) {}
  ~PurgeResponse() override;
  explicit PROTOBUF_CONSTEXPR PurgeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PurgeResponse(const PurgeResponse& from);
  PurgeResponse(PurgeResponse&& from) noexcept
    : PurgeResponse() {
    *this = ::std::move(from);
  }

  inline PurgeResponse& operator=(const PurgeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurgeResponse& operator=(PurgeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PurgeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PurgeResponse* internal_default_instance() {
    return reinterpret_cast<const PurgeResponse*>(
               &_PurgeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(PurgeResponse& a, PurgeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PurgeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurgeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PurgeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PurgeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PurgeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PurgeResponse& from) {
    PurgeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurgeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.PurgeResponse";
  }
  protected:
  explicit PurgeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.PurgeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::ResultCode* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ReadTreeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ReadTreeResponse) */ {
 public:
  inline ReadTreeResponse() : ReadTreeResponse(nullptr) {}
  ~ReadTreeResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadTreeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadTreeResponse(const ReadTreeResponse& from);
  ReadTreeResponse(ReadTreeResponse&& from) noexcept
    : ReadTreeResponse() {
    *this = ::std::move(from);
  }

  inline ReadTreeResponse& operator=(const ReadTreeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadTreeResponse& operator=(ReadTreeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadTreeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadTreeResponse* internal_default_instance() {
    return reinterpret_cast<const ReadTreeResponse*>(
               &_ReadTreeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ReadTreeResponse& a, ReadTreeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadTreeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadTreeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadTreeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadTreeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadTreeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadTreeResponse& from) {
    ReadTreeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadTreeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ReadTreeResponse";
  }
  protected:
  explicit ReadTreeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyValueFieldNumber = 1,
    kHashValueFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // repeated .hashdb.v1.KeyValue key_value = 1;
  int key_value_size() const;
  private:
  int _internal_key_value_size() const;
  public:
  void clear_key_value();
  ::hashdb::v1::KeyValue* mutable_key_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >*
      mutable_key_value();
  private:
  const ::hashdb::v1::KeyValue& _internal_key_value(int index) const;
  ::hashdb::v1::KeyValue* _internal_add_key_value();
  public:
  const ::hashdb::v1::KeyValue& key_value(int index) const;
  ::hashdb::v1::KeyValue* add_key_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >&
      key_value() const;

  // repeated .hashdb.v1.HashValueGL hash_value = 2;
  int hash_value_size() const;
  private:
  int _internal_hash_value_size() const;
  public:
  void clear_hash_value();
  ::hashdb::v1::HashValueGL* mutable_hash_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >*
      mutable_hash_value();
  private:
  const ::hashdb::v1::HashValueGL& _internal_hash_value(int index) const;
  ::hashdb::v1::HashValueGL* _internal_add_hash_value();
  public:
  const ::hashdb::v1::HashValueGL& hash_value(int index) const;
  ::hashdb::v1::HashValueGL* add_hash_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >&
      hash_value() const;

  // .hashdb.v1.ResultCode result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.ReadTreeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue > key_value_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL > hash_value_;
    ::hashdb::v1::ResultCode* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class CancelBatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.CancelBatchResponse) */ {
 public:
  inline CancelBatchResponse() : CancelBatchResponse(nullptr) {}
  ~CancelBatchResponse() override;
  explicit PROTOBUF_CONSTEXPR CancelBatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelBatchResponse(const CancelBatchResponse& from);
  CancelBatchResponse(CancelBatchResponse&& from) noexcept
    : CancelBatchResponse() {
    *this = ::std::move(from);
  }

  inline CancelBatchResponse& operator=(const CancelBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelBatchResponse& operator=(CancelBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelBatchResponse* internal_default_instance() {
    return reinterpret_cast<const CancelBatchResponse*>(
               &_CancelBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CancelBatchResponse& a, CancelBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelBatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelBatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelBatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelBatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelBatchResponse& from) {
    CancelBatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.CancelBatchResponse";
  }
  protected:
  explicit CancelBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.CancelBatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::ResultCode* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ResetDBResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ResetDBResponse) */ {
 public:
  inline ResetDBResponse() : ResetDBResponse(nullptr) {}
  ~ResetDBResponse() override;
  explicit PROTOBUF_CONSTEXPR ResetDBResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetDBResponse(const ResetDBResponse& from);
  ResetDBResponse(ResetDBResponse&& from) noexcept
    : ResetDBResponse() {
    *this = ::std::move(from);
  }

  inline ResetDBResponse& operator=(const ResetDBResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetDBResponse& operator=(ResetDBResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetDBResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetDBResponse* internal_default_instance() {
    return reinterpret_cast<const ResetDBResponse*>(
               &_ResetDBResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ResetDBResponse& a, ResetDBResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetDBResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetDBResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetDBResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetDBResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetDBResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetDBResponse& from) {
    ResetDBResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetDBResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ResetDBResponse";
  }
  protected:
  explicit ResetDBResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:hashdb.v1.ResetDBResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::ResultCode* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class Fea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Fea) */ {
 public:
  inline Fea() : Fea(nullptr) {}
  ~Fea() override;
  explicit PROTOBUF_CONSTEXPR Fea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fea(const Fea& from);
  Fea(Fea&& from) noexcept
    : Fea() {
    *this = ::std::move(from);
  }

  inline Fea& operator=(const Fea& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fea& operator=(Fea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fea& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fea* internal_default_instance() {
    return reinterpret_cast<const Fea*>(
               &_Fea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Fea& a, Fea& b) {
    a.Swap(&b);
  }
  inline void Swap(Fea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fea& from) {
    Fea::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Fea";
  }
  protected:
  explicit Fea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFe0FieldNumber = 1,
    kFe1FieldNumber = 2,
    kFe2FieldNumber = 3,
    kFe3FieldNumber = 4,
  };
  // uint64 fe0 = 1;
  void clear_fe0();
  uint64_t fe0() const;
  void set_fe0(uint64_t value);
  private:
  uint64_t _internal_fe0() const;
  void _internal_set_fe0(uint64_t value);
  public:

  // uint64 fe1 = 2;
  void clear_fe1();
  uint64_t fe1() const;
  void set_fe1(uint64_t value);
  private:
  uint64_t _internal_fe1() const;
  void _internal_set_fe1(uint64_t value);
  public:

  // uint64 fe2 = 3;
  void clear_fe2();
  uint64_t fe2() const;
  void set_fe2(uint64_t value);
  private:
  uint64_t _internal_fe2() const;
  void _internal_set_fe2(uint64_t value);
  public:

  // uint64 fe3 = 4;
  void clear_fe3();
  uint64_t fe3() const;
  void set_fe3(uint64_t value);
  private:
  uint64_t _internal_fe3() const;
  void _internal_set_fe3(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Fea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t fe0_;
    uint64_t fe1_;
    uint64_t fe2_;
    uint64_t fe3_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class Fea12 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Fea12) */ {
 public:
  inline Fea12() : Fea12(nullptr) {}
  ~Fea12() override;
  explicit PROTOBUF_CONSTEXPR Fea12(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fea12(const Fea12& from);
  Fea12(Fea12&& from) noexcept
    : Fea12() {
    *this = ::std::move(from);
  }

  inline Fea12& operator=(const Fea12& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fea12& operator=(Fea12&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fea12& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fea12* internal_default_instance() {
    return reinterpret_cast<const Fea12*>(
               &_Fea12_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Fea12& a, Fea12& b) {
    a.Swap(&b);
  }
  inline void Swap(Fea12* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fea12* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fea12* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fea12>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fea12& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fea12& from) {
    Fea12::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fea12* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.Fea12";
  }
  protected:
  explicit Fea12(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFe0FieldNumber = 1,
    kFe1FieldNumber = 2,
    kFe2FieldNumber = 3,
    kFe3FieldNumber = 4,
    kFe4FieldNumber = 5,
    kFe5FieldNumber = 6,
    kFe6FieldNumber = 7,
    kFe7FieldNumber = 8,
    kFe8FieldNumber = 9,
    kFe9FieldNumber = 10,
    kFe10FieldNumber = 11,
    kFe11FieldNumber = 12,
  };
  // uint64 fe0 = 1;
  void clear_fe0();
  uint64_t fe0() const;
  void set_fe0(uint64_t value);
  private:
  uint64_t _internal_fe0() const;
  void _internal_set_fe0(uint64_t value);
  public:

  // uint64 fe1 = 2;
  void clear_fe1();
  uint64_t fe1() const;
  void set_fe1(uint64_t value);
  private:
  uint64_t _internal_fe1() const;
  void _internal_set_fe1(uint64_t value);
  public:

  // uint64 fe2 = 3;
  void clear_fe2();
  uint64_t fe2() const;
  void set_fe2(uint64_t value);
  private:
  uint64_t _internal_fe2() const;
  void _internal_set_fe2(uint64_t value);
  public:

  // uint64 fe3 = 4;
  void clear_fe3();
  uint64_t fe3() const;
  void set_fe3(uint64_t value);
  private:
  uint64_t _internal_fe3() const;
  void _internal_set_fe3(uint64_t value);
  public:

  // uint64 fe4 = 5;
  void clear_fe4();
  uint64_t fe4() const;
  void set_fe4(uint64_t value);
  private:
  uint64_t _internal_fe4() const;
  void _internal_set_fe4(uint64_t value);
  public:

  // uint64 fe5 = 6;
  void clear_fe5();
  uint64_t fe5() const;
  void set_fe5(uint64_t value);
  private:
  uint64_t _internal_fe5() const;
  void _internal_set_fe5(uint64_t value);
  public:

  // uint64 fe6 = 7;
  void clear_fe6();
  uint64_t fe6() const;
  void set_fe6(uint64_t value);
  private:
  uint64_t _internal_fe6() const;
  void _internal_set_fe6(uint64_t value);
  public:

  // uint64 fe7 = 8;
  void clear_fe7();
  uint64_t fe7() const;
  void set_fe7(uint64_t value);
  private:
  uint64_t _internal_fe7() const;
  void _internal_set_fe7(uint64_t value);
  public:

  // uint64 fe8 = 9;
  void clear_fe8();
  uint64_t fe8() const;
  void set_fe8(uint64_t value);
  private:
  uint64_t _internal_fe8() const;
  void _internal_set_fe8(uint64_t value);
  public:

  // uint64 fe9 = 10;
  void clear_fe9();
  uint64_t fe9() const;
  void set_fe9(uint64_t value);
  private:
  uint64_t _internal_fe9() const;
  void _internal_set_fe9(uint64_t value);
  public:

  // uint64 fe10 = 11;
  void clear_fe10();
  uint64_t fe10() const;
  void set_fe10(uint64_t value);
  private:
  uint64_t _internal_fe10() const;
  void _internal_set_fe10(uint64_t value);
  public:

  // uint64 fe11 = 12;
  void clear_fe11();
  uint64_t fe11() const;
  void set_fe11(uint64_t value);
  private:
  uint64_t _internal_fe11() const;
  void _internal_set_fe11(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.Fea12)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t fe0_;
    uint64_t fe1_;
    uint64_t fe2_;
    uint64_t fe3_;
    uint64_t fe4_;
    uint64_t fe5_;
    uint64_t fe6_;
    uint64_t fe7_;
    uint64_t fe8_;
    uint64_t fe9_;
    uint64_t fe10_;
    uint64_t fe11_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class HashValueGL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.HashValueGL) */ {
 public:
  inline HashValueGL() : HashValueGL(nullptr) {}
  ~HashValueGL() override;
  explicit PROTOBUF_CONSTEXPR HashValueGL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashValueGL(const HashValueGL& from);
  HashValueGL(HashValueGL&& from) noexcept
    : HashValueGL() {
    *this = ::std::move(from);
  }

  inline HashValueGL& operator=(const HashValueGL& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashValueGL& operator=(HashValueGL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashValueGL& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashValueGL* internal_default_instance() {
    return reinterpret_cast<const HashValueGL*>(
               &_HashValueGL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(HashValueGL& a, HashValueGL& b) {
    a.Swap(&b);
  }
  inline void Swap(HashValueGL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashValueGL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashValueGL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashValueGL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashValueGL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HashValueGL& from) {
    HashValueGL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashValueGL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.HashValueGL";
  }
  protected:
  explicit HashValueGL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .hashdb.v1.Fea hash = 1;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const ::hashdb::v1::Fea& hash() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_hash();
  ::hashdb::v1::Fea* mutable_hash();
  void set_allocated_hash(::hashdb::v1::Fea* hash);
  private:
  const ::hashdb::v1::Fea& _internal_hash() const;
  ::hashdb::v1::Fea* _internal_mutable_hash();
  public:
  void unsafe_arena_set_allocated_hash(
      ::hashdb::v1::Fea* hash);
  ::hashdb::v1::Fea* unsafe_arena_release_hash();

  // .hashdb.v1.Fea12 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::hashdb::v1::Fea12& value() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea12* release_value();
  ::hashdb::v1::Fea12* mutable_value();
  void set_allocated_value(::hashdb::v1::Fea12* value);
  private:
  const ::hashdb::v1::Fea12& _internal_value() const;
  ::hashdb::v1::Fea12* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::hashdb::v1::Fea12* value);
  ::hashdb::v1::Fea12* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:hashdb.v1.HashValueGL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::hashdb::v1::Fea* hash_;
    ::hashdb::v1::Fea12* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class KeyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.KeyValue) */ {
 public:
  inline KeyValue() : KeyValue(nullptr) {}
  ~KeyValue() override;
  explicit PROTOBUF_CONSTEXPR KeyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValue(const KeyValue& from);
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyValue& from) {
    KeyValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.KeyValue";
  }
  protected:
  explicit KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:hashdb.v1.KeyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::hashdb::v1::Fea* key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class FeList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FeList) */ {
 public:
  inline FeList() : FeList(nullptr) {}
  ~FeList() override;
  explicit PROTOBUF_CONSTEXPR FeList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeList(const FeList& from);
  FeList(FeList&& from) noexcept
    : FeList() {
    *this = ::std::move(from);
  }

  inline FeList& operator=(const FeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeList& operator=(FeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeList* internal_default_instance() {
    return reinterpret_cast<const FeList*>(
               &_FeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(FeList& a, FeList& b) {
    a.Swap(&b);
  }
  inline void Swap(FeList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeList& from) {
    FeList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.FeList";
  }
  protected:
  explicit FeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeFieldNumber = 1,
  };
  // repeated uint64 fe = 1;
  int fe_size() const;
  private:
  int _internal_fe_size() const;
  public:
  void clear_fe();
  private:
  uint64_t _internal_fe(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_fe() const;
  void _internal_add_fe(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_fe();
  public:
  uint64_t fe(int index) const;
  void set_fe(int index, uint64_t value);
  void add_fe(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      fe() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_fe();

  // @@protoc_insertion_point(class_scope:hashdb.v1.FeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > fe_;
    mutable std::atomic<int> _fe_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SiblingList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SiblingList) */ {
 public:
  inline SiblingList() : SiblingList(nullptr) {}
  ~SiblingList() override;
  explicit PROTOBUF_CONSTEXPR SiblingList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SiblingList(const SiblingList& from);
  SiblingList(SiblingList&& from) noexcept
    : SiblingList() {
    *this = ::std::move(from);
  }

  inline SiblingList& operator=(const SiblingList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SiblingList& operator=(SiblingList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SiblingList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SiblingList* internal_default_instance() {
    return reinterpret_cast<const SiblingList*>(
               &_SiblingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SiblingList& a, SiblingList& b) {
    a.Swap(&b);
  }
  inline void Swap(SiblingList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SiblingList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SiblingList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SiblingList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SiblingList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SiblingList& from) {
    SiblingList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SiblingList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.SiblingList";
  }
  protected:
  explicit SiblingList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiblingFieldNumber = 1,
  };
  // repeated uint64 sibling = 1;
  int sibling_size() const;
  private:
  int _internal_sibling_size() const;
  public:
  void clear_sibling();
  private:
  uint64_t _internal_sibling(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_sibling() const;
  void _internal_add_sibling(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_sibling();
  public:
  uint64_t sibling(int index) const;
  void set_sibling(int index, uint64_t value);
  void add_sibling(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      sibling() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_sibling();

  // @@protoc_insertion_point(class_scope:hashdb.v1.SiblingList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > sibling_;
    mutable std::atomic<int> _sibling_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class ResultCode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ResultCode) */ {
 public:
  inline ResultCode() : ResultCode(nullptr) {}
  ~ResultCode() override;
  explicit PROTOBUF_CONSTEXPR ResultCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultCode(const ResultCode& from);
  ResultCode(ResultCode&& from) noexcept
    : ResultCode() {
    *this = ::std::move(from);
  }

  inline ResultCode& operator=(const ResultCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultCode& operator=(ResultCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultCode* internal_default_instance() {
    return reinterpret_cast<const ResultCode*>(
               &_ResultCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ResultCode& a, ResultCode& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultCode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultCode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResultCode& from) {
    ResultCode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hashdb.v1.ResultCode";
  }
  protected:
  explicit ResultCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResultCode_Code Code;
  static constexpr Code CODE_UNSPECIFIED =
    ResultCode_Code_CODE_UNSPECIFIED;
  static constexpr Code CODE_SUCCESS =
    ResultCode_Code_CODE_SUCCESS;
  static constexpr Code CODE_DB_KEY_NOT_FOUND =
    ResultCode_Code_CODE_DB_KEY_NOT_FOUND;
  static constexpr Code CODE_DB_ERROR =
    ResultCode_Code_CODE_DB_ERROR;
  static constexpr Code CODE_INTERNAL_ERROR =
    ResultCode_Code_CODE_INTERNAL_ERROR;
  static constexpr Code CODE_SMT_INVALID_DATA_SIZE =
    ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE;
  static inline bool Code_IsValid(int value) {
    return ResultCode_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    ResultCode_Code_Code_MIN;
  static constexpr Code Code_MAX =
    ResultCode_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    ResultCode_Code_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Code_descriptor() {
    return ResultCode_Code_descriptor();
  }
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return ResultCode_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Code* value) {
    return ResultCode_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode.Code code = 1;
  void clear_code();
  ::hashdb::v1::ResultCode_Code code() const;
  void set_code(::hashdb::v1::ResultCode_Code value);
  private:
  ::hashdb::v1::ResultCode_Code _internal_code() const;
  void _internal_set_code(::hashdb::v1::ResultCode_Code value);
  public:

  // @@protoc_insertion_point(class_scope:hashdb.v1.ResultCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// string v0_0_1 = 1;
inline void Version::clear_v0_0_1() {
  _impl_.v0_0_1_.ClearToEmpty();
}
inline const std::string& Version::v0_0_1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Version.v0_0_1)
  return _internal_v0_0_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_v0_0_1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.v0_0_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::mutable_v0_0_1() {
  std::string* _s = _internal_mutable_v0_0_1();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.Version.v0_0_1)
  return _s;
}
inline const std::string& Version::_internal_v0_0_1() const {
  return _impl_.v0_0_1_.Get();
}
inline void Version::_internal_set_v0_0_1(const std::string& value) {
  
  _impl_.v0_0_1_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_v0_0_1() {
  
  return _impl_.v0_0_1_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_v0_0_1() {
  // @@protoc_insertion_point(field_release:hashdb.v1.Version.v0_0_1)
  return _impl_.v0_0_1_.Release();
}
inline void Version::set_allocated_v0_0_1(std::string* v0_0_1) {
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  _impl_.v0_0_1_.SetAllocated(v0_0_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.v0_0_1_.IsDefault()) {
    _impl_.v0_0_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.Version.v0_0_1)
}

// -------------------------------------------------------------------

// SetRequest

// .hashdb.v1.Fea old_root = 1;
inline bool SetRequest::_internal_has_old_root() const {
  return this != internal_default_instance() && _impl_.old_root_ != nullptr;
}
inline bool SetRequest::has_old_root() const {
  return _internal_has_old_root();
}
inline void SetRequest::clear_old_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.old_root_ != nullptr) {
    delete _impl_.old_root_;
  }
  _impl_.old_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = _impl_.old_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.old_root)
  return _internal_old_root();
}
inline void SetRequest::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_root_);
  }
  _impl_.old_root_ = old_root;
  if (old_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.old_root)
}
inline ::hashdb::v1::Fea* SetRequest::release_old_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.old_root)
  
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_old_root() {
  
  if (_impl_.old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.old_root_ = p;
  }
  return _impl_.old_root_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_old_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_old_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.old_root)
  return _msg;
}
inline void SetRequest::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.old_root)
}

// .hashdb.v1.Fea key = 2;
inline bool SetRequest::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool SetRequest::has_key() const {
  return _internal_has_key();
}
inline void SetRequest::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.key)
  return _internal_key();
}
inline void SetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.key)
}
inline ::hashdb::v1::Fea* SetRequest::release_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.key)
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.key)
  return _msg;
}
inline void SetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.key)
}

// string value = 3;
inline void SetRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SetRequest::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.value)
  return _s;
}
inline const std::string& SetRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetRequest::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetRequest::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetRequest::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.value)
  return _impl_.value_.Release();
}
inline void SetRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.value)
}

// .hashdb.v1.Persistence persistence = 4;
inline void SetRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence SetRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence SetRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.persistence)
  return _internal_persistence();
}
inline void SetRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void SetRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.persistence)
}

// bool details = 5;
inline void SetRequest::clear_details() {
  _impl_.details_ = false;
}
inline bool SetRequest::_internal_details() const {
  return _impl_.details_;
}
inline bool SetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.details)
  return _internal_details();
}
inline void SetRequest::_internal_set_details(bool value) {
  
  _impl_.details_ = value;
}
inline void SetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.details)
}

// bool get_db_read_log = 6;
inline void SetRequest::clear_get_db_read_log() {
  _impl_.get_db_read_log_ = false;
}
inline bool SetRequest::_internal_get_db_read_log() const {
  return _impl_.get_db_read_log_;
}
inline bool SetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void SetRequest::_internal_set_get_db_read_log(bool value) {
  
  _impl_.get_db_read_log_ = value;
}
inline void SetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.get_db_read_log)
}

// string batch_uuid = 7;
inline void SetRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& SetRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.batch_uuid)
}
inline std::string* SetRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.batch_uuid)
  return _s;
}
inline const std::string& SetRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void SetRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void SetRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.batch_uuid)
}

// uint64 tx_index = 8;
inline void SetRequest::clear_tx_index() {
  _impl_.tx_index_ = uint64_t{0u};
}
inline uint64_t SetRequest::_internal_tx_index() const {
  return _impl_.tx_index_;
}
inline uint64_t SetRequest::tx_index() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.tx_index)
  return _internal_tx_index();
}
inline void SetRequest::_internal_set_tx_index(uint64_t value) {
  
  _impl_.tx_index_ = value;
}
inline void SetRequest::set_tx_index(uint64_t value) {
  _internal_set_tx_index(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.tx_index)
}

// uint64 block_index = 9;
inline void SetRequest::clear_block_index() {
  _impl_.block_index_ = uint64_t{0u};
}
inline uint64_t SetRequest::_internal_block_index() const {
  return _impl_.block_index_;
}
inline uint64_t SetRequest::block_index() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.block_index)
  return _internal_block_index();
}
inline void SetRequest::_internal_set_block_index(uint64_t value) {
  
  _impl_.block_index_ = value;
}
inline void SetRequest::set_block_index(uint64_t value) {
  _internal_set_block_index(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.block_index)
}

// -------------------------------------------------------------------

// GetRequest

// .hashdb.v1.Fea root = 1;
inline bool GetRequest::_internal_has_root() const {
  return this != internal_default_instance() && _impl_.root_ != nullptr;
}
inline bool GetRequest::has_root() const {
  return _internal_has_root();
}
inline void GetRequest::clear_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.root_ != nullptr) {
    delete _impl_.root_;
  }
  _impl_.root_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_root() const {
  const ::hashdb::v1::Fea* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.root)
  return _internal_root();
}
inline void GetRequest::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.root)
}
inline ::hashdb::v1::Fea* GetRequest::release_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.root)
  
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_root() {
  
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.root)
  return _msg;
}
inline void GetRequest::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetRequest::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool GetRequest::has_key() const {
  return _internal_has_key();
}
inline void GetRequest::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.key)
  return _internal_key();
}
inline void GetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.key)
}
inline ::hashdb::v1::Fea* GetRequest::release_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.key)
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.key)
  return _msg;
}
inline void GetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.key)
}

// bool details = 3;
inline void GetRequest::clear_details() {
  _impl_.details_ = false;
}
inline bool GetRequest::_internal_details() const {
  return _impl_.details_;
}
inline bool GetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.details)
  return _internal_details();
}
inline void GetRequest::_internal_set_details(bool value) {
  
  _impl_.details_ = value;
}
inline void GetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.details)
}

// bool get_db_read_log = 4;
inline void GetRequest::clear_get_db_read_log() {
  _impl_.get_db_read_log_ = false;
}
inline bool GetRequest::_internal_get_db_read_log() const {
  return _impl_.get_db_read_log_;
}
inline bool GetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void GetRequest::_internal_set_get_db_read_log(bool value) {
  
  _impl_.get_db_read_log_ = value;
}
inline void GetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.get_db_read_log)
}

// string batch_uuid = 5;
inline void GetRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& GetRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.batch_uuid)
}
inline std::string* GetRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.batch_uuid)
  return _s;
}
inline const std::string& GetRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void GetRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void GetRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.batch_uuid)
}

// -------------------------------------------------------------------

// SetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool SetProgramRequest::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool SetProgramRequest::has_key() const {
  return _internal_has_key();
}
inline void SetProgramRequest::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.key)
  return _internal_key();
}
inline void SetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramRequest.key)
}
inline ::hashdb::v1::Fea* SetProgramRequest::release_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.key)
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* SetProgramRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.key)
  return _msg;
}
inline void SetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.key)
}

// bytes data = 2;
inline void SetProgramRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SetProgramRequest::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetProgramRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.data)
  return _s;
}
inline const std::string& SetProgramRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SetProgramRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SetProgramRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SetProgramRequest::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.data)
  return _impl_.data_.Release();
}
inline void SetProgramRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.data)
}

// .hashdb.v1.Persistence persistence = 3;
inline void SetProgramRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence SetProgramRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence SetProgramRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.persistence)
  return _internal_persistence();
}
inline void SetProgramRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void SetProgramRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.persistence)
}

// string batch_uuid = 4;
inline void SetProgramRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& SetProgramRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetProgramRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.batch_uuid)
}
inline std::string* SetProgramRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.batch_uuid)
  return _s;
}
inline const std::string& SetProgramRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void SetProgramRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetProgramRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetProgramRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void SetProgramRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.batch_uuid)
}

// uint64 tx_index = 5;
inline void SetProgramRequest::clear_tx_index() {
  _impl_.tx_index_ = uint64_t{0u};
}
inline uint64_t SetProgramRequest::_internal_tx_index() const {
  return _impl_.tx_index_;
}
inline uint64_t SetProgramRequest::tx_index() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.tx_index)
  return _internal_tx_index();
}
inline void SetProgramRequest::_internal_set_tx_index(uint64_t value) {
  
  _impl_.tx_index_ = value;
}
inline void SetProgramRequest::set_tx_index(uint64_t value) {
  _internal_set_tx_index(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.tx_index)
}

// uint64 block_index = 6;
inline void SetProgramRequest::clear_block_index() {
  _impl_.block_index_ = uint64_t{0u};
}
inline uint64_t SetProgramRequest::_internal_block_index() const {
  return _impl_.block_index_;
}
inline uint64_t SetProgramRequest::block_index() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.block_index)
  return _internal_block_index();
}
inline void SetProgramRequest::_internal_set_block_index(uint64_t value) {
  
  _impl_.block_index_ = value;
}
inline void SetProgramRequest::set_block_index(uint64_t value) {
  _internal_set_block_index(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.block_index)
}

// -------------------------------------------------------------------

// GetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool GetProgramRequest::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool GetProgramRequest::has_key() const {
  return _internal_has_key();
}
inline void GetProgramRequest::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramRequest.key)
  return _internal_key();
}
inline void GetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramRequest.key)
}
inline ::hashdb::v1::Fea* GetProgramRequest::release_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramRequest.key)
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* GetProgramRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramRequest.key)
  return _msg;
}
inline void GetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramRequest.key)
}

// string batch_uuid = 2;
inline void GetProgramRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& GetProgramRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProgramRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetProgramRequest.batch_uuid)
}
inline std::string* GetProgramRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramRequest.batch_uuid)
  return _s;
}
inline const std::string& GetProgramRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void GetProgramRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProgramRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetProgramRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void GetProgramRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramRequest.batch_uuid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadDBRequest

// map<string, .hashdb.v1.FeList> input_db = 1;
inline int LoadDBRequest::_internal_input_db_size() const {
  return _impl_.input_db_.size();
}
inline int LoadDBRequest::input_db_size() const {
  return _internal_input_db_size();
}
inline void LoadDBRequest::clear_input_db() {
  _impl_.input_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::_internal_input_db() const {
  return _impl_.input_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::input_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_input_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::_internal_mutable_input_db() {
  return _impl_.input_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::mutable_input_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_mutable_input_db();
}

// bool persistent = 2;
inline void LoadDBRequest::clear_persistent() {
  _impl_.persistent_ = false;
}
inline bool LoadDBRequest::_internal_persistent() const {
  return _impl_.persistent_;
}
inline bool LoadDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadDBRequest::_internal_set_persistent(bool value) {
  
  _impl_.persistent_ = value;
}
inline void LoadDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadDBRequest.persistent)
}

// .hashdb.v1.Fea state_root = 3;
inline bool LoadDBRequest::_internal_has_state_root() const {
  return this != internal_default_instance() && _impl_.state_root_ != nullptr;
}
inline bool LoadDBRequest::has_state_root() const {
  return _internal_has_state_root();
}
inline void LoadDBRequest::clear_state_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_root_ != nullptr) {
    delete _impl_.state_root_;
  }
  _impl_.state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& LoadDBRequest::_internal_state_root() const {
  const ::hashdb::v1::Fea* p = _impl_.state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& LoadDBRequest::state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadDBRequest.state_root)
  return _internal_state_root();
}
inline void LoadDBRequest::unsafe_arena_set_allocated_state_root(
    ::hashdb::v1::Fea* state_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_root_);
  }
  _impl_.state_root_ = state_root;
  if (state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.LoadDBRequest.state_root)
}
inline ::hashdb::v1::Fea* LoadDBRequest::release_state_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* LoadDBRequest::unsafe_arena_release_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.LoadDBRequest.state_root)
  
  ::hashdb::v1::Fea* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* LoadDBRequest::_internal_mutable_state_root() {
  
  if (_impl_.state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.state_root_ = p;
  }
  return _impl_.state_root_;
}
inline ::hashdb::v1::Fea* LoadDBRequest::mutable_state_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.LoadDBRequest.state_root)
  return _msg;
}
inline void LoadDBRequest::set_allocated_state_root(::hashdb::v1::Fea* state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_root_;
  }
  if (state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state_root);
    if (message_arena != submessage_arena) {
      state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_root_ = state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.LoadDBRequest.state_root)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadProgramDBRequest

// map<string, bytes> input_program_db = 1;
inline int LoadProgramDBRequest::_internal_input_program_db_size() const {
  return _impl_.input_program_db_.size();
}
inline int LoadProgramDBRequest::input_program_db_size() const {
  return _internal_input_program_db_size();
}
inline void LoadProgramDBRequest::clear_input_program_db() {
  _impl_.input_program_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::_internal_input_program_db() const {
  return _impl_.input_program_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::input_program_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_input_program_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::_internal_mutable_input_program_db() {
  return _impl_.input_program_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::mutable_input_program_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_mutable_input_program_db();
}

// bool persistent = 2;
inline void LoadProgramDBRequest::clear_persistent() {
  _impl_.persistent_ = false;
}
inline bool LoadProgramDBRequest::_internal_persistent() const {
  return _impl_.persistent_;
}
inline bool LoadProgramDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadProgramDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadProgramDBRequest::_internal_set_persistent(bool value) {
  
  _impl_.persistent_ = value;
}
inline void LoadProgramDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadProgramDBRequest.persistent)
}

// -------------------------------------------------------------------

// FlushRequest

// string batch_uuid = 1;
inline void FlushRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& FlushRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlushRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.batch_uuid)
}
inline std::string* FlushRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushRequest.batch_uuid)
  return _s;
}
inline const std::string& FlushRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void FlushRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* FlushRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* FlushRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void FlushRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushRequest.batch_uuid)
}

// string new_state_root = 2;
inline void FlushRequest::clear_new_state_root() {
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& FlushRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.new_state_root)
  return _internal_new_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlushRequest::set_new_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_state_root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.new_state_root)
}
inline std::string* FlushRequest::mutable_new_state_root() {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushRequest.new_state_root)
  return _s;
}
inline const std::string& FlushRequest::_internal_new_state_root() const {
  return _impl_.new_state_root_.Get();
}
inline void FlushRequest::_internal_set_new_state_root(const std::string& value) {
  
  _impl_.new_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* FlushRequest::_internal_mutable_new_state_root() {
  
  return _impl_.new_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* FlushRequest::release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushRequest.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void FlushRequest::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_state_root_.SetAllocated(new_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_state_root_.IsDefault()) {
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void FlushRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence FlushRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence FlushRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushRequest.persistence)
  return _internal_persistence();
}
inline void FlushRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void FlushRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushRequest.persistence)
}

// -------------------------------------------------------------------

// FinishTxRequest

// string batch_uuid = 1;
inline void FinishTxRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& FinishTxRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FinishTxRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinishTxRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.FinishTxRequest.batch_uuid)
}
inline std::string* FinishTxRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FinishTxRequest.batch_uuid)
  return _s;
}
inline const std::string& FinishTxRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void FinishTxRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* FinishTxRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* FinishTxRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FinishTxRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void FinishTxRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FinishTxRequest.batch_uuid)
}

// string new_state_root = 2;
inline void FinishTxRequest::clear_new_state_root() {
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& FinishTxRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FinishTxRequest.new_state_root)
  return _internal_new_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinishTxRequest::set_new_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_state_root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.FinishTxRequest.new_state_root)
}
inline std::string* FinishTxRequest::mutable_new_state_root() {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FinishTxRequest.new_state_root)
  return _s;
}
inline const std::string& FinishTxRequest::_internal_new_state_root() const {
  return _impl_.new_state_root_.Get();
}
inline void FinishTxRequest::_internal_set_new_state_root(const std::string& value) {
  
  _impl_.new_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* FinishTxRequest::_internal_mutable_new_state_root() {
  
  return _impl_.new_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* FinishTxRequest::release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FinishTxRequest.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void FinishTxRequest::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_state_root_.SetAllocated(new_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_state_root_.IsDefault()) {
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FinishTxRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void FinishTxRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence FinishTxRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence FinishTxRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FinishTxRequest.persistence)
  return _internal_persistence();
}
inline void FinishTxRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void FinishTxRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FinishTxRequest.persistence)
}

// -------------------------------------------------------------------

// StartBlockRequest

// string batch_uuid = 1;
inline void StartBlockRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& StartBlockRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.StartBlockRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartBlockRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.StartBlockRequest.batch_uuid)
}
inline std::string* StartBlockRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.StartBlockRequest.batch_uuid)
  return _s;
}
inline const std::string& StartBlockRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void StartBlockRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* StartBlockRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* StartBlockRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.StartBlockRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void StartBlockRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.StartBlockRequest.batch_uuid)
}

// string old_state_root = 2;
inline void StartBlockRequest::clear_old_state_root() {
  _impl_.old_state_root_.ClearToEmpty();
}
inline const std::string& StartBlockRequest::old_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.StartBlockRequest.old_state_root)
  return _internal_old_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartBlockRequest::set_old_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_state_root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.StartBlockRequest.old_state_root)
}
inline std::string* StartBlockRequest::mutable_old_state_root() {
  std::string* _s = _internal_mutable_old_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.StartBlockRequest.old_state_root)
  return _s;
}
inline const std::string& StartBlockRequest::_internal_old_state_root() const {
  return _impl_.old_state_root_.Get();
}
inline void StartBlockRequest::_internal_set_old_state_root(const std::string& value) {
  
  _impl_.old_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* StartBlockRequest::_internal_mutable_old_state_root() {
  
  return _impl_.old_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* StartBlockRequest::release_old_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.StartBlockRequest.old_state_root)
  return _impl_.old_state_root_.Release();
}
inline void StartBlockRequest::set_allocated_old_state_root(std::string* old_state_root) {
  if (old_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.old_state_root_.SetAllocated(old_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_state_root_.IsDefault()) {
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.StartBlockRequest.old_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void StartBlockRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence StartBlockRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence StartBlockRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.StartBlockRequest.persistence)
  return _internal_persistence();
}
inline void StartBlockRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void StartBlockRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.StartBlockRequest.persistence)
}

// -------------------------------------------------------------------

// FinishBlockRequest

// string batch_uuid = 1;
inline void FinishBlockRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& FinishBlockRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FinishBlockRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinishBlockRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.FinishBlockRequest.batch_uuid)
}
inline std::string* FinishBlockRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FinishBlockRequest.batch_uuid)
  return _s;
}
inline const std::string& FinishBlockRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void FinishBlockRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* FinishBlockRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* FinishBlockRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FinishBlockRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void FinishBlockRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FinishBlockRequest.batch_uuid)
}

// string new_state_root = 2;
inline void FinishBlockRequest::clear_new_state_root() {
  _impl_.new_state_root_.ClearToEmpty();
}
inline const std::string& FinishBlockRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FinishBlockRequest.new_state_root)
  return _internal_new_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FinishBlockRequest::set_new_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_state_root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.FinishBlockRequest.new_state_root)
}
inline std::string* FinishBlockRequest::mutable_new_state_root() {
  std::string* _s = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FinishBlockRequest.new_state_root)
  return _s;
}
inline const std::string& FinishBlockRequest::_internal_new_state_root() const {
  return _impl_.new_state_root_.Get();
}
inline void FinishBlockRequest::_internal_set_new_state_root(const std::string& value) {
  
  _impl_.new_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* FinishBlockRequest::_internal_mutable_new_state_root() {
  
  return _impl_.new_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* FinishBlockRequest::release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FinishBlockRequest.new_state_root)
  return _impl_.new_state_root_.Release();
}
inline void FinishBlockRequest::set_allocated_new_state_root(std::string* new_state_root) {
  if (new_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.new_state_root_.SetAllocated(new_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_state_root_.IsDefault()) {
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FinishBlockRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void FinishBlockRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence FinishBlockRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence FinishBlockRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FinishBlockRequest.persistence)
  return _internal_persistence();
}
inline void FinishBlockRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void FinishBlockRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FinishBlockRequest.persistence)
}

// -------------------------------------------------------------------

// GetFlushDataRequest

// uint64 flush_id = 1;
inline void GetFlushDataRequest::clear_flush_id() {
  _impl_.flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushDataRequest::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline uint64_t GetFlushDataRequest::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataRequest.flush_id)
  return _internal_flush_id();
}
inline void GetFlushDataRequest::_internal_set_flush_id(uint64_t value) {
  
  _impl_.flush_id_ = value;
}
inline void GetFlushDataRequest::set_flush_id(uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataRequest.flush_id)
}

// -------------------------------------------------------------------

// ConsolidateStateRequest

// .hashdb.v1.Fea virtual_state_root = 1;
inline bool ConsolidateStateRequest::_internal_has_virtual_state_root() const {
  return this != internal_default_instance() && _impl_.virtual_state_root_ != nullptr;
}
inline bool ConsolidateStateRequest::has_virtual_state_root() const {
  return _internal_has_virtual_state_root();
}
inline void ConsolidateStateRequest::clear_virtual_state_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.virtual_state_root_ != nullptr) {
    delete _impl_.virtual_state_root_;
  }
  _impl_.virtual_state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& ConsolidateStateRequest::_internal_virtual_state_root() const {
  const ::hashdb::v1::Fea* p = _impl_.virtual_state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& ConsolidateStateRequest::virtual_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
  return _internal_virtual_state_root();
}
inline void ConsolidateStateRequest::unsafe_arena_set_allocated_virtual_state_root(
    ::hashdb::v1::Fea* virtual_state_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.virtual_state_root_);
  }
  _impl_.virtual_state_root_ = virtual_state_root;
  if (virtual_state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::release_virtual_state_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.virtual_state_root_;
  _impl_.virtual_state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::unsafe_arena_release_virtual_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
  
  ::hashdb::v1::Fea* temp = _impl_.virtual_state_root_;
  _impl_.virtual_state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::_internal_mutable_virtual_state_root() {
  
  if (_impl_.virtual_state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.virtual_state_root_ = p;
  }
  return _impl_.virtual_state_root_;
}
inline ::hashdb::v1::Fea* ConsolidateStateRequest::mutable_virtual_state_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_virtual_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
  return _msg;
}
inline void ConsolidateStateRequest::set_allocated_virtual_state_root(::hashdb::v1::Fea* virtual_state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.virtual_state_root_;
  }
  if (virtual_state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(virtual_state_root);
    if (message_arena != submessage_arena) {
      virtual_state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_state_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.virtual_state_root_ = virtual_state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ConsolidateStateRequest.virtual_state_root)
}

// .hashdb.v1.Persistence persistence = 2;
inline void ConsolidateStateRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence ConsolidateStateRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence ConsolidateStateRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateRequest.persistence)
  return _internal_persistence();
}
inline void ConsolidateStateRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void ConsolidateStateRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ConsolidateStateRequest.persistence)
}

// -------------------------------------------------------------------

// PurgeRequest

// string batch_uuid = 1;
inline void PurgeRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& PurgeRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PurgeRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.PurgeRequest.batch_uuid)
}
inline std::string* PurgeRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.PurgeRequest.batch_uuid)
  return _s;
}
inline const std::string& PurgeRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void PurgeRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* PurgeRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* PurgeRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.PurgeRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void PurgeRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.PurgeRequest.batch_uuid)
}

// .hashdb.v1.Fea new_state_root = 2;
inline bool PurgeRequest::_internal_has_new_state_root() const {
  return this != internal_default_instance() && _impl_.new_state_root_ != nullptr;
}
inline bool PurgeRequest::has_new_state_root() const {
  return _internal_has_new_state_root();
}
inline void PurgeRequest::clear_new_state_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.new_state_root_ != nullptr) {
    delete _impl_.new_state_root_;
  }
  _impl_.new_state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& PurgeRequest::_internal_new_state_root() const {
  const ::hashdb::v1::Fea* p = _impl_.new_state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& PurgeRequest::new_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeRequest.new_state_root)
  return _internal_new_state_root();
}
inline void PurgeRequest::unsafe_arena_set_allocated_new_state_root(
    ::hashdb::v1::Fea* new_state_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_state_root_);
  }
  _impl_.new_state_root_ = new_state_root;
  if (new_state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.PurgeRequest.new_state_root)
}
inline ::hashdb::v1::Fea* PurgeRequest::release_new_state_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.new_state_root_;
  _impl_.new_state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* PurgeRequest::unsafe_arena_release_new_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.PurgeRequest.new_state_root)
  
  ::hashdb::v1::Fea* temp = _impl_.new_state_root_;
  _impl_.new_state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* PurgeRequest::_internal_mutable_new_state_root() {
  
  if (_impl_.new_state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.new_state_root_ = p;
  }
  return _impl_.new_state_root_;
}
inline ::hashdb::v1::Fea* PurgeRequest::mutable_new_state_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_new_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.PurgeRequest.new_state_root)
  return _msg;
}
inline void PurgeRequest::set_allocated_new_state_root(::hashdb::v1::Fea* new_state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.new_state_root_;
  }
  if (new_state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_state_root);
    if (message_arena != submessage_arena) {
      new_state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_state_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_state_root_ = new_state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.PurgeRequest.new_state_root)
}

// .hashdb.v1.Persistence persistence = 3;
inline void PurgeRequest::clear_persistence() {
  _impl_.persistence_ = 0;
}
inline ::hashdb::v1::Persistence PurgeRequest::_internal_persistence() const {
  return static_cast< ::hashdb::v1::Persistence >(_impl_.persistence_);
}
inline ::hashdb::v1::Persistence PurgeRequest::persistence() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeRequest.persistence)
  return _internal_persistence();
}
inline void PurgeRequest::_internal_set_persistence(::hashdb::v1::Persistence value) {
  
  _impl_.persistence_ = value;
}
inline void PurgeRequest::set_persistence(::hashdb::v1::Persistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.PurgeRequest.persistence)
}

// -------------------------------------------------------------------

// ReadTreeRequest

// .hashdb.v1.Fea state_root = 1;
inline bool ReadTreeRequest::_internal_has_state_root() const {
  return this != internal_default_instance() && _impl_.state_root_ != nullptr;
}
inline bool ReadTreeRequest::has_state_root() const {
  return _internal_has_state_root();
}
inline void ReadTreeRequest::clear_state_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_root_ != nullptr) {
    delete _impl_.state_root_;
  }
  _impl_.state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::_internal_state_root() const {
  const ::hashdb::v1::Fea* p = _impl_.state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeRequest.state_root)
  return _internal_state_root();
}
inline void ReadTreeRequest::unsafe_arena_set_allocated_state_root(
    ::hashdb::v1::Fea* state_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_root_);
  }
  _impl_.state_root_ = state_root;
  if (state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ReadTreeRequest.state_root)
}
inline ::hashdb::v1::Fea* ReadTreeRequest::release_state_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* ReadTreeRequest::unsafe_arena_release_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ReadTreeRequest.state_root)
  
  ::hashdb::v1::Fea* temp = _impl_.state_root_;
  _impl_.state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* ReadTreeRequest::_internal_mutable_state_root() {
  
  if (_impl_.state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.state_root_ = p;
  }
  return _impl_.state_root_;
}
inline ::hashdb::v1::Fea* ReadTreeRequest::mutable_state_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeRequest.state_root)
  return _msg;
}
inline void ReadTreeRequest::set_allocated_state_root(::hashdb::v1::Fea* state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_root_;
  }
  if (state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state_root);
    if (message_arena != submessage_arena) {
      state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_root_ = state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ReadTreeRequest.state_root)
}

// repeated .hashdb.v1.Fea keys = 2;
inline int ReadTreeRequest::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int ReadTreeRequest::keys_size() const {
  return _internal_keys_size();
}
inline void ReadTreeRequest::clear_keys() {
  _impl_.keys_.Clear();
}
inline ::hashdb::v1::Fea* ReadTreeRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeRequest.keys)
  return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >*
ReadTreeRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.ReadTreeRequest.keys)
  return &_impl_.keys_;
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const ::hashdb::v1::Fea& ReadTreeRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeRequest.keys)
  return _internal_keys(index);
}
inline ::hashdb::v1::Fea* ReadTreeRequest::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline ::hashdb::v1::Fea* ReadTreeRequest::add_keys() {
  ::hashdb::v1::Fea* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:hashdb.v1.ReadTreeRequest.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::Fea >&
ReadTreeRequest::keys() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.ReadTreeRequest.keys)
  return _impl_.keys_;
}

// -------------------------------------------------------------------

// CancelBatchRequest

// string batch_uuid = 1;
inline void CancelBatchRequest::clear_batch_uuid() {
  _impl_.batch_uuid_.ClearToEmpty();
}
inline const std::string& CancelBatchRequest::batch_uuid() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.CancelBatchRequest.batch_uuid)
  return _internal_batch_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelBatchRequest::set_batch_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.batch_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.CancelBatchRequest.batch_uuid)
}
inline std::string* CancelBatchRequest::mutable_batch_uuid() {
  std::string* _s = _internal_mutable_batch_uuid();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.CancelBatchRequest.batch_uuid)
  return _s;
}
inline const std::string& CancelBatchRequest::_internal_batch_uuid() const {
  return _impl_.batch_uuid_.Get();
}
inline void CancelBatchRequest::_internal_set_batch_uuid(const std::string& value) {
  
  _impl_.batch_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelBatchRequest::_internal_mutable_batch_uuid() {
  
  return _impl_.batch_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelBatchRequest::release_batch_uuid() {
  // @@protoc_insertion_point(field_release:hashdb.v1.CancelBatchRequest.batch_uuid)
  return _impl_.batch_uuid_.Release();
}
inline void CancelBatchRequest::set_allocated_batch_uuid(std::string* batch_uuid) {
  if (batch_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.batch_uuid_.SetAllocated(batch_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.batch_uuid_.IsDefault()) {
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.CancelBatchRequest.batch_uuid)
}

// -------------------------------------------------------------------

// GetLatestStateRootResponse

// .hashdb.v1.Fea latest_root = 1;
inline bool GetLatestStateRootResponse::_internal_has_latest_root() const {
  return this != internal_default_instance() && _impl_.latest_root_ != nullptr;
}
inline bool GetLatestStateRootResponse::has_latest_root() const {
  return _internal_has_latest_root();
}
inline void GetLatestStateRootResponse::clear_latest_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.latest_root_ != nullptr) {
    delete _impl_.latest_root_;
  }
  _impl_.latest_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetLatestStateRootResponse::_internal_latest_root() const {
  const ::hashdb::v1::Fea* p = _impl_.latest_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetLatestStateRootResponse::latest_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetLatestStateRootResponse.latest_root)
  return _internal_latest_root();
}
inline void GetLatestStateRootResponse::unsafe_arena_set_allocated_latest_root(
    ::hashdb::v1::Fea* latest_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_root_);
  }
  _impl_.latest_root_ = latest_root;
  if (latest_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetLatestStateRootResponse.latest_root)
}
inline ::hashdb::v1::Fea* GetLatestStateRootResponse::release_latest_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.latest_root_;
  _impl_.latest_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetLatestStateRootResponse::unsafe_arena_release_latest_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetLatestStateRootResponse.latest_root)
  
  ::hashdb::v1::Fea* temp = _impl_.latest_root_;
  _impl_.latest_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetLatestStateRootResponse::_internal_mutable_latest_root() {
  
  if (_impl_.latest_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.latest_root_ = p;
  }
  return _impl_.latest_root_;
}
inline ::hashdb::v1::Fea* GetLatestStateRootResponse::mutable_latest_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_latest_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetLatestStateRootResponse.latest_root)
  return _msg;
}
inline void GetLatestStateRootResponse::set_allocated_latest_root(::hashdb::v1::Fea* latest_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.latest_root_;
  }
  if (latest_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(latest_root);
    if (message_arena != submessage_arena) {
      latest_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latest_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.latest_root_ = latest_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetLatestStateRootResponse.latest_root)
}

// .hashdb.v1.ResultCode result = 2;
inline bool GetLatestStateRootResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool GetLatestStateRootResponse::has_result() const {
  return _internal_has_result();
}
inline void GetLatestStateRootResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetLatestStateRootResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetLatestStateRootResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetLatestStateRootResponse.result)
  return _internal_result();
}
inline void GetLatestStateRootResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetLatestStateRootResponse.result)
}
inline ::hashdb::v1::ResultCode* GetLatestStateRootResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* GetLatestStateRootResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetLatestStateRootResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetLatestStateRootResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* GetLatestStateRootResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetLatestStateRootResponse.result)
  return _msg;
}
inline void GetLatestStateRootResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetLatestStateRootResponse.result)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetResponse

// .hashdb.v1.Fea old_root = 1;
inline bool SetResponse::_internal_has_old_root() const {
  return this != internal_default_instance() && _impl_.old_root_ != nullptr;
}
inline bool SetResponse::has_old_root() const {
  return _internal_has_old_root();
}
inline void SetResponse::clear_old_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.old_root_ != nullptr) {
    delete _impl_.old_root_;
  }
  _impl_.old_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = _impl_.old_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_root)
  return _internal_old_root();
}
inline void SetResponse::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_root_);
  }
  _impl_.old_root_ = old_root;
  if (old_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.old_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_old_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_root)
  
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_old_root() {
  
  if (_impl_.old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.old_root_ = p;
  }
  return _impl_.old_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_old_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_old_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_root)
  return _msg;
}
inline void SetResponse::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_root)
}

// .hashdb.v1.Fea new_root = 2;
inline bool SetResponse::_internal_has_new_root() const {
  return this != internal_default_instance() && _impl_.new_root_ != nullptr;
}
inline bool SetResponse::has_new_root() const {
  return _internal_has_new_root();
}
inline void SetResponse::clear_new_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.new_root_ != nullptr) {
    delete _impl_.new_root_;
  }
  _impl_.new_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_new_root() const {
  const ::hashdb::v1::Fea* p = _impl_.new_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::new_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_root)
  return _internal_new_root();
}
inline void SetResponse::unsafe_arena_set_allocated_new_root(
    ::hashdb::v1::Fea* new_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_root_);
  }
  _impl_.new_root_ = new_root;
  if (new_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.new_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_new_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.new_root_;
  _impl_.new_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_new_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_root)
  
  ::hashdb::v1::Fea* temp = _impl_.new_root_;
  _impl_.new_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_new_root() {
  
  if (_impl_.new_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.new_root_ = p;
  }
  return _impl_.new_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_new_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_new_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_root)
  return _msg;
}
inline void SetResponse::set_allocated_new_root(::hashdb::v1::Fea* new_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.new_root_;
  }
  if (new_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_root);
    if (message_arena != submessage_arena) {
      new_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_root_ = new_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_root)
}

// .hashdb.v1.Fea key = 3;
inline bool SetResponse::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool SetResponse::has_key() const {
  return _internal_has_key();
}
inline void SetResponse::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.key)
  return _internal_key();
}
inline void SetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.key)
}
inline ::hashdb::v1::Fea* SetResponse::release_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.key)
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.key)
  return _msg;
}
inline void SetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 4;
inline int SetResponse::_internal_siblings_size() const {
  return _impl_.siblings_.size();
}
inline int SetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void SetResponse::clear_siblings() {
  _impl_.siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
SetResponse::_internal_siblings() const {
  return _impl_.siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
SetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
SetResponse::_internal_mutable_siblings() {
  return _impl_.siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
SetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 5;
inline bool SetResponse::_internal_has_ins_key() const {
  return this != internal_default_instance() && _impl_.ins_key_ != nullptr;
}
inline bool SetResponse::has_ins_key() const {
  return _internal_has_ins_key();
}
inline void SetResponse::clear_ins_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.ins_key_ != nullptr) {
    delete _impl_.ins_key_;
  }
  _impl_.ins_key_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = _impl_.ins_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_key)
  return _internal_ins_key();
}
inline void SetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ins_key_);
  }
  _impl_.ins_key_ = ins_key;
  if (ins_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.ins_key)
}
inline ::hashdb::v1::Fea* SetResponse::release_ins_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_key)
  
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_ins_key() {
  
  if (_impl_.ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.ins_key_ = p;
  }
  return _impl_.ins_key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_ins_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_ins_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_key)
  return _msg;
}
inline void SetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_key)
}

// string ins_value = 6;
inline void SetResponse::clear_ins_value() {
  _impl_.ins_value_.ClearToEmpty();
}
inline const std::string& SetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_value)
  return _internal_ins_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetResponse::set_ins_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ins_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::mutable_ins_value() {
  std::string* _s = _internal_mutable_ins_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_value)
  return _s;
}
inline const std::string& SetResponse::_internal_ins_value() const {
  return _impl_.ins_value_.Get();
}
inline void SetResponse::_internal_set_ins_value(const std::string& value) {
  
  _impl_.ins_value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_ins_value() {
  
  return _impl_.ins_value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_value)
  return _impl_.ins_value_.Release();
}
inline void SetResponse::set_allocated_ins_value(std::string* ins_value) {
  if (ins_value != nullptr) {
    
  } else {
    
  }
  _impl_.ins_value_.SetAllocated(ins_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ins_value_.IsDefault()) {
    _impl_.ins_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_value)
}

// bool is_old0 = 7;
inline void SetResponse::clear_is_old0() {
  _impl_.is_old0_ = false;
}
inline bool SetResponse::_internal_is_old0() const {
  return _impl_.is_old0_;
}
inline bool SetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.is_old0)
  return _internal_is_old0();
}
inline void SetResponse::_internal_set_is_old0(bool value) {
  
  _impl_.is_old0_ = value;
}
inline void SetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.is_old0)
}

// string old_value = 8;
inline void SetResponse::clear_old_value() {
  _impl_.old_value_.ClearToEmpty();
}
inline const std::string& SetResponse::old_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_value)
  return _internal_old_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetResponse::set_old_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.old_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::mutable_old_value() {
  std::string* _s = _internal_mutable_old_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_value)
  return _s;
}
inline const std::string& SetResponse::_internal_old_value() const {
  return _impl_.old_value_.Get();
}
inline void SetResponse::_internal_set_old_value(const std::string& value) {
  
  _impl_.old_value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_old_value() {
  
  return _impl_.old_value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetResponse::release_old_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_value)
  return _impl_.old_value_.Release();
}
inline void SetResponse::set_allocated_old_value(std::string* old_value) {
  if (old_value != nullptr) {
    
  } else {
    
  }
  _impl_.old_value_.SetAllocated(old_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.old_value_.IsDefault()) {
    _impl_.old_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_value)
}

// string new_value = 9;
inline void SetResponse::clear_new_value() {
  _impl_.new_value_.ClearToEmpty();
}
inline const std::string& SetResponse::new_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_value)
  return _internal_new_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetResponse::set_new_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::mutable_new_value() {
  std::string* _s = _internal_mutable_new_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_value)
  return _s;
}
inline const std::string& SetResponse::_internal_new_value() const {
  return _impl_.new_value_.Get();
}
inline void SetResponse::_internal_set_new_value(const std::string& value) {
  
  _impl_.new_value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_new_value() {
  
  return _impl_.new_value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetResponse::release_new_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_value)
  return _impl_.new_value_.Release();
}
inline void SetResponse::set_allocated_new_value(std::string* new_value) {
  if (new_value != nullptr) {
    
  } else {
    
  }
  _impl_.new_value_.SetAllocated(new_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_value_.IsDefault()) {
    _impl_.new_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_value)
}

// string mode = 10;
inline void SetResponse::clear_mode() {
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& SetResponse::mode() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.mode)
  return _internal_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetResponse::set_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.mode)
  return _s;
}
inline const std::string& SetResponse::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void SetResponse::_internal_set_mode(const std::string& value) {
  
  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_mode() {
  
  return _impl_.mode_.Mutable(GetArenaForAllocation());
}
inline std::string* SetResponse::release_mode() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.mode)
  return _impl_.mode_.Release();
}
inline void SetResponse::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  _impl_.mode_.SetAllocated(mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_.IsDefault()) {
    _impl_.mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.mode)
}

// uint64 proof_hash_counter = 11;
inline void SetResponse::clear_proof_hash_counter() {
  _impl_.proof_hash_counter_ = uint64_t{0u};
}
inline uint64_t SetResponse::_internal_proof_hash_counter() const {
  return _impl_.proof_hash_counter_;
}
inline uint64_t SetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void SetResponse::_internal_set_proof_hash_counter(uint64_t value) {
  
  _impl_.proof_hash_counter_ = value;
}
inline void SetResponse::set_proof_hash_counter(uint64_t value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.proof_hash_counter)
}

// map<string, .hashdb.v1.FeList> db_read_log = 12;
inline int SetResponse::_internal_db_read_log_size() const {
  return _impl_.db_read_log_.size();
}
inline int SetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void SetResponse::clear_db_read_log() {
  _impl_.db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::_internal_db_read_log() const {
  return _impl_.db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::_internal_mutable_db_read_log() {
  return _impl_.db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 13;
inline bool SetResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool SetResponse::has_result() const {
  return _internal_has_result();
}
inline void SetResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& SetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.result)
  return _internal_result();
}
inline void SetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.result)
}
inline ::hashdb::v1::ResultCode* SetResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* SetResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.result)
  return _msg;
}
inline void SetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.result)
}

// .hashdb.v1.Fea sibling_left_child = 14;
inline bool SetResponse::_internal_has_sibling_left_child() const {
  return this != internal_default_instance() && _impl_.sibling_left_child_ != nullptr;
}
inline bool SetResponse::has_sibling_left_child() const {
  return _internal_has_sibling_left_child();
}
inline void SetResponse::clear_sibling_left_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.sibling_left_child_ != nullptr) {
    delete _impl_.sibling_left_child_;
  }
  _impl_.sibling_left_child_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_sibling_left_child() const {
  const ::hashdb::v1::Fea* p = _impl_.sibling_left_child_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::sibling_left_child() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.sibling_left_child)
  return _internal_sibling_left_child();
}
inline void SetResponse::unsafe_arena_set_allocated_sibling_left_child(
    ::hashdb::v1::Fea* sibling_left_child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sibling_left_child_);
  }
  _impl_.sibling_left_child_ = sibling_left_child;
  if (sibling_left_child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.sibling_left_child)
}
inline ::hashdb::v1::Fea* SetResponse::release_sibling_left_child() {
  
  ::hashdb::v1::Fea* temp = _impl_.sibling_left_child_;
  _impl_.sibling_left_child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_sibling_left_child() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.sibling_left_child)
  
  ::hashdb::v1::Fea* temp = _impl_.sibling_left_child_;
  _impl_.sibling_left_child_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_sibling_left_child() {
  
  if (_impl_.sibling_left_child_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.sibling_left_child_ = p;
  }
  return _impl_.sibling_left_child_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_sibling_left_child() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_sibling_left_child();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.sibling_left_child)
  return _msg;
}
inline void SetResponse::set_allocated_sibling_left_child(::hashdb::v1::Fea* sibling_left_child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sibling_left_child_;
  }
  if (sibling_left_child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sibling_left_child);
    if (message_arena != submessage_arena) {
      sibling_left_child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sibling_left_child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sibling_left_child_ = sibling_left_child;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.sibling_left_child)
}

// .hashdb.v1.Fea sibling_right_child = 15;
inline bool SetResponse::_internal_has_sibling_right_child() const {
  return this != internal_default_instance() && _impl_.sibling_right_child_ != nullptr;
}
inline bool SetResponse::has_sibling_right_child() const {
  return _internal_has_sibling_right_child();
}
inline void SetResponse::clear_sibling_right_child() {
  if (GetArenaForAllocation() == nullptr && _impl_.sibling_right_child_ != nullptr) {
    delete _impl_.sibling_right_child_;
  }
  _impl_.sibling_right_child_ = nullptr;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_sibling_right_child() const {
  const ::hashdb::v1::Fea* p = _impl_.sibling_right_child_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::sibling_right_child() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.sibling_right_child)
  return _internal_sibling_right_child();
}
inline void SetResponse::unsafe_arena_set_allocated_sibling_right_child(
    ::hashdb::v1::Fea* sibling_right_child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sibling_right_child_);
  }
  _impl_.sibling_right_child_ = sibling_right_child;
  if (sibling_right_child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.sibling_right_child)
}
inline ::hashdb::v1::Fea* SetResponse::release_sibling_right_child() {
  
  ::hashdb::v1::Fea* temp = _impl_.sibling_right_child_;
  _impl_.sibling_right_child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_sibling_right_child() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.sibling_right_child)
  
  ::hashdb::v1::Fea* temp = _impl_.sibling_right_child_;
  _impl_.sibling_right_child_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_sibling_right_child() {
  
  if (_impl_.sibling_right_child_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.sibling_right_child_ = p;
  }
  return _impl_.sibling_right_child_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_sibling_right_child() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_sibling_right_child();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.sibling_right_child)
  return _msg;
}
inline void SetResponse::set_allocated_sibling_right_child(::hashdb::v1::Fea* sibling_right_child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sibling_right_child_;
  }
  if (sibling_right_child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sibling_right_child);
    if (message_arena != submessage_arena) {
      sibling_right_child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sibling_right_child, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sibling_right_child_ = sibling_right_child;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.sibling_right_child)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetResponse

// .hashdb.v1.Fea root = 1;
inline bool GetResponse::_internal_has_root() const {
  return this != internal_default_instance() && _impl_.root_ != nullptr;
}
inline bool GetResponse::has_root() const {
  return _internal_has_root();
}
inline void GetResponse::clear_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.root_ != nullptr) {
    delete _impl_.root_;
  }
  _impl_.root_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_root() const {
  const ::hashdb::v1::Fea* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.root)
  return _internal_root();
}
inline void GetResponse::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.root)
}
inline ::hashdb::v1::Fea* GetResponse::release_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.root)
  
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_root() {
  
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.root)
  return _msg;
}
inline void GetResponse::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetResponse::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool GetResponse::has_key() const {
  return _internal_has_key();
}
inline void GetResponse::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.key)
  return _internal_key();
}
inline void GetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.key)
}
inline ::hashdb::v1::Fea* GetResponse::release_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.key)
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.key)
  return _msg;
}
inline void GetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 3;
inline int GetResponse::_internal_siblings_size() const {
  return _impl_.siblings_.size();
}
inline int GetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void GetResponse::clear_siblings() {
  _impl_.siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
GetResponse::_internal_siblings() const {
  return _impl_.siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >&
GetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
GetResponse::_internal_mutable_siblings() {
  return _impl_.siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >*
GetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 4;
inline bool GetResponse::_internal_has_ins_key() const {
  return this != internal_default_instance() && _impl_.ins_key_ != nullptr;
}
inline bool GetResponse::has_ins_key() const {
  return _internal_has_ins_key();
}
inline void GetResponse::clear_ins_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.ins_key_ != nullptr) {
    delete _impl_.ins_key_;
  }
  _impl_.ins_key_ = nullptr;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = _impl_.ins_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_key)
  return _internal_ins_key();
}
inline void GetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ins_key_);
  }
  _impl_.ins_key_ = ins_key;
  if (ins_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.ins_key)
}
inline ::hashdb::v1::Fea* GetResponse::release_ins_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_key)
  
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_ins_key() {
  
  if (_impl_.ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.ins_key_ = p;
  }
  return _impl_.ins_key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_ins_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_ins_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_key)
  return _msg;
}
inline void GetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_key)
}

// string ins_value = 5;
inline void GetResponse::clear_ins_value() {
  _impl_.ins_value_.ClearToEmpty();
}
inline const std::string& GetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_value)
  return _internal_ins_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponse::set_ins_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ins_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::mutable_ins_value() {
  std::string* _s = _internal_mutable_ins_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_value)
  return _s;
}
inline const std::string& GetResponse::_internal_ins_value() const {
  return _impl_.ins_value_.Get();
}
inline void GetResponse::_internal_set_ins_value(const std::string& value) {
  
  _impl_.ins_value_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_ins_value() {
  
  return _impl_.ins_value_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_value)
  return _impl_.ins_value_.Release();
}
inline void GetResponse::set_allocated_ins_value(std::string* ins_value) {
  if (ins_value != nullptr) {
    
  } else {
    
  }
  _impl_.ins_value_.SetAllocated(ins_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ins_value_.IsDefault()) {
    _impl_.ins_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_value)
}

// bool is_old0 = 6;
inline void GetResponse::clear_is_old0() {
  _impl_.is_old0_ = false;
}
inline bool GetResponse::_internal_is_old0() const {
  return _impl_.is_old0_;
}
inline bool GetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.is_old0)
  return _internal_is_old0();
}
inline void GetResponse::_internal_set_is_old0(bool value) {
  
  _impl_.is_old0_ = value;
}
inline void GetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.is_old0)
}

// string value = 7;
inline void GetResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.value)
  return _s;
}
inline const std::string& GetResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void GetResponse::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.value)
  return _impl_.value_.Release();
}
inline void GetResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.value)
}

// uint64 proof_hash_counter = 8;
inline void GetResponse::clear_proof_hash_counter() {
  _impl_.proof_hash_counter_ = uint64_t{0u};
}
inline uint64_t GetResponse::_internal_proof_hash_counter() const {
  return _impl_.proof_hash_counter_;
}
inline uint64_t GetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void GetResponse::_internal_set_proof_hash_counter(uint64_t value) {
  
  _impl_.proof_hash_counter_ = value;
}
inline void GetResponse::set_proof_hash_counter(uint64_t value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.proof_hash_counter)
}

// map<string, .hashdb.v1.FeList> db_read_log = 9;
inline int GetResponse::_internal_db_read_log_size() const {
  return _impl_.db_read_log_.size();
}
inline int GetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void GetResponse::clear_db_read_log() {
  _impl_.db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::_internal_db_read_log() const {
  return _impl_.db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::_internal_mutable_db_read_log() {
  return _impl_.db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 10;
inline bool GetResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool GetResponse::has_result() const {
  return _internal_has_result();
}
inline void GetResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.result)
  return _internal_result();
}
inline void GetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.result)
}
inline ::hashdb::v1::ResultCode* GetResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* GetResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.result)
  return _msg;
}
inline void GetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.result)
}

// -------------------------------------------------------------------

// SetProgramResponse

// .hashdb.v1.ResultCode result = 1;
inline bool SetProgramResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool SetProgramResponse::has_result() const {
  return _internal_has_result();
}
inline void SetProgramResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramResponse.result)
  return _internal_result();
}
inline void SetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramResponse.result)
  return _msg;
}
inline void SetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramResponse.result)
}

// -------------------------------------------------------------------

// GetProgramResponse

// bytes data = 1;
inline void GetProgramResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& GetProgramResponse::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetProgramResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.data)
  return _s;
}
inline const std::string& GetProgramResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void GetProgramResponse::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProgramResponse::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetProgramResponse::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.data)
  return _impl_.data_.Release();
}
inline void GetProgramResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.data)
}

// .hashdb.v1.ResultCode result = 2;
inline bool GetProgramResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool GetProgramResponse::has_result() const {
  return _internal_has_result();
}
inline void GetProgramResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.result)
  return _internal_result();
}
inline void GetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.result)
  return _msg;
}
inline void GetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.result)
}

// -------------------------------------------------------------------

// FlushResponse

// uint64 flush_id = 1;
inline void FlushResponse::clear_flush_id() {
  _impl_.flush_id_ = uint64_t{0u};
}
inline uint64_t FlushResponse::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline uint64_t FlushResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.flush_id)
  return _internal_flush_id();
}
inline void FlushResponse::_internal_set_flush_id(uint64_t value) {
  
  _impl_.flush_id_ = value;
}
inline void FlushResponse::set_flush_id(uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.flush_id)
}

// uint64 stored_flush_id = 2;
inline void FlushResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t FlushResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t FlushResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void FlushResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void FlushResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.stored_flush_id)
}

// .hashdb.v1.ResultCode result = 3;
inline bool FlushResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool FlushResponse::has_result() const {
  return _internal_has_result();
}
inline void FlushResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& FlushResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& FlushResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.result)
  return _internal_result();
}
inline void FlushResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushResponse.result)
}
inline ::hashdb::v1::ResultCode* FlushResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* FlushResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushResponse.result)
  return _msg;
}
inline void FlushResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushResponse.result)
}

// -------------------------------------------------------------------

// GetFlushStatusResponse

// uint64 stored_flush_id = 1;
inline void GetFlushStatusResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t GetFlushStatusResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
}

// uint64 storing_flush_id = 2;
inline void GetFlushStatusResponse::clear_storing_flush_id() {
  _impl_.storing_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_flush_id() const {
  return _impl_.storing_flush_id_;
}
inline uint64_t GetFlushStatusResponse::storing_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
  return _internal_storing_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_storing_flush_id(uint64_t value) {
  
  _impl_.storing_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_storing_flush_id(uint64_t value) {
  _internal_set_storing_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
}

// uint64 last_flush_id = 3;
inline void GetFlushStatusResponse::clear_last_flush_id() {
  _impl_.last_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_last_flush_id() const {
  return _impl_.last_flush_id_;
}
inline uint64_t GetFlushStatusResponse::last_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.last_flush_id)
  return _internal_last_flush_id();
}
inline void GetFlushStatusResponse::_internal_set_last_flush_id(uint64_t value) {
  
  _impl_.last_flush_id_ = value;
}
inline void GetFlushStatusResponse::set_last_flush_id(uint64_t value) {
  _internal_set_last_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.last_flush_id)
}

// uint64 pending_to_flush_nodes = 4;
inline void GetFlushStatusResponse::clear_pending_to_flush_nodes() {
  _impl_.pending_to_flush_nodes_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_pending_to_flush_nodes() const {
  return _impl_.pending_to_flush_nodes_;
}
inline uint64_t GetFlushStatusResponse::pending_to_flush_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
  return _internal_pending_to_flush_nodes();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_nodes(uint64_t value) {
  
  _impl_.pending_to_flush_nodes_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_nodes(uint64_t value) {
  _internal_set_pending_to_flush_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
}

// uint64 pending_to_flush_program = 5;
inline void GetFlushStatusResponse::clear_pending_to_flush_program() {
  _impl_.pending_to_flush_program_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_pending_to_flush_program() const {
  return _impl_.pending_to_flush_program_;
}
inline uint64_t GetFlushStatusResponse::pending_to_flush_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
  return _internal_pending_to_flush_program();
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_program(uint64_t value) {
  
  _impl_.pending_to_flush_program_ = value;
}
inline void GetFlushStatusResponse::set_pending_to_flush_program(uint64_t value) {
  _internal_set_pending_to_flush_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
}

// uint64 storing_nodes = 6;
inline void GetFlushStatusResponse::clear_storing_nodes() {
  _impl_.storing_nodes_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_nodes() const {
  return _impl_.storing_nodes_;
}
inline uint64_t GetFlushStatusResponse::storing_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_nodes)
  return _internal_storing_nodes();
}
inline void GetFlushStatusResponse::_internal_set_storing_nodes(uint64_t value) {
  
  _impl_.storing_nodes_ = value;
}
inline void GetFlushStatusResponse::set_storing_nodes(uint64_t value) {
  _internal_set_storing_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_nodes)
}

// uint64 storing_program = 7;
inline void GetFlushStatusResponse::clear_storing_program() {
  _impl_.storing_program_ = uint64_t{0u};
}
inline uint64_t GetFlushStatusResponse::_internal_storing_program() const {
  return _impl_.storing_program_;
}
inline uint64_t GetFlushStatusResponse::storing_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_program)
  return _internal_storing_program();
}
inline void GetFlushStatusResponse::_internal_set_storing_program(uint64_t value) {
  
  _impl_.storing_program_ = value;
}
inline void GetFlushStatusResponse::set_storing_program(uint64_t value) {
  _internal_set_storing_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_program)
}

// string prover_id = 8;
inline void GetFlushStatusResponse::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& GetFlushStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _internal_prover_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFlushStatusResponse::set_prover_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prover_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _s;
}
inline const std::string& GetFlushStatusResponse::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void GetFlushStatusResponse::_internal_set_prover_id(const std::string& value) {
  
  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::_internal_mutable_prover_id() {
  
  return _impl_.prover_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void GetFlushStatusResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  _impl_.prover_id_.SetAllocated(prover_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prover_id_.IsDefault()) {
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushStatusResponse.prover_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetFlushDataResponse

// uint64 stored_flush_id = 1;
inline void GetFlushDataResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t GetFlushDataResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t GetFlushDataResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushDataResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void GetFlushDataResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.stored_flush_id)
}

// map<string, string> nodes = 2;
inline int GetFlushDataResponse::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int GetFlushDataResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetFlushDataResponse::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_nodes() const {
  return _impl_.nodes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::nodes() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_nodes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_nodes() {
  return _impl_.nodes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_mutable_nodes();
}

// map<string, string> program = 3;
inline int GetFlushDataResponse::_internal_program_size() const {
  return _impl_.program_.size();
}
inline int GetFlushDataResponse::program_size() const {
  return _internal_program_size();
}
inline void GetFlushDataResponse::clear_program() {
  _impl_.program_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_program() const {
  return _impl_.program_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::program() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_program();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_program() {
  return _impl_.program_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_program() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_mutable_program();
}

// string nodes_state_root = 4;
inline void GetFlushDataResponse::clear_nodes_state_root() {
  _impl_.nodes_state_root_.ClearToEmpty();
}
inline const std::string& GetFlushDataResponse::nodes_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _internal_nodes_state_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFlushDataResponse::set_nodes_state_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nodes_state_root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::mutable_nodes_state_root() {
  std::string* _s = _internal_mutable_nodes_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _s;
}
inline const std::string& GetFlushDataResponse::_internal_nodes_state_root() const {
  return _impl_.nodes_state_root_.Get();
}
inline void GetFlushDataResponse::_internal_set_nodes_state_root(const std::string& value) {
  
  _impl_.nodes_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlushDataResponse::_internal_mutable_nodes_state_root() {
  
  return _impl_.nodes_state_root_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFlushDataResponse::release_nodes_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _impl_.nodes_state_root_.Release();
}
inline void GetFlushDataResponse::set_allocated_nodes_state_root(std::string* nodes_state_root) {
  if (nodes_state_root != nullptr) {
    
  } else {
    
  }
  _impl_.nodes_state_root_.SetAllocated(nodes_state_root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nodes_state_root_.IsDefault()) {
    _impl_.nodes_state_root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}

// .hashdb.v1.ResultCode result = 5;
inline bool GetFlushDataResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool GetFlushDataResponse::has_result() const {
  return _internal_has_result();
}
inline void GetFlushDataResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.result)
  return _internal_result();
}
inline void GetFlushDataResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.result)
  return _msg;
}
inline void GetFlushDataResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}

// -------------------------------------------------------------------

// ConsolidateStateResponse

// .hashdb.v1.Fea consolidated_state_root = 1;
inline bool ConsolidateStateResponse::_internal_has_consolidated_state_root() const {
  return this != internal_default_instance() && _impl_.consolidated_state_root_ != nullptr;
}
inline bool ConsolidateStateResponse::has_consolidated_state_root() const {
  return _internal_has_consolidated_state_root();
}
inline void ConsolidateStateResponse::clear_consolidated_state_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.consolidated_state_root_ != nullptr) {
    delete _impl_.consolidated_state_root_;
  }
  _impl_.consolidated_state_root_ = nullptr;
}
inline const ::hashdb::v1::Fea& ConsolidateStateResponse::_internal_consolidated_state_root() const {
  const ::hashdb::v1::Fea* p = _impl_.consolidated_state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& ConsolidateStateResponse::consolidated_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
  return _internal_consolidated_state_root();
}
inline void ConsolidateStateResponse::unsafe_arena_set_allocated_consolidated_state_root(
    ::hashdb::v1::Fea* consolidated_state_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consolidated_state_root_);
  }
  _impl_.consolidated_state_root_ = consolidated_state_root;
  if (consolidated_state_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::release_consolidated_state_root() {
  
  ::hashdb::v1::Fea* temp = _impl_.consolidated_state_root_;
  _impl_.consolidated_state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::unsafe_arena_release_consolidated_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
  
  ::hashdb::v1::Fea* temp = _impl_.consolidated_state_root_;
  _impl_.consolidated_state_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::_internal_mutable_consolidated_state_root() {
  
  if (_impl_.consolidated_state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.consolidated_state_root_ = p;
  }
  return _impl_.consolidated_state_root_;
}
inline ::hashdb::v1::Fea* ConsolidateStateResponse::mutable_consolidated_state_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_consolidated_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
  return _msg;
}
inline void ConsolidateStateResponse::set_allocated_consolidated_state_root(::hashdb::v1::Fea* consolidated_state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consolidated_state_root_;
  }
  if (consolidated_state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consolidated_state_root);
    if (message_arena != submessage_arena) {
      consolidated_state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consolidated_state_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.consolidated_state_root_ = consolidated_state_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ConsolidateStateResponse.consolidated_state_root)
}

// uint64 flush_id = 2;
inline void ConsolidateStateResponse::clear_flush_id() {
  _impl_.flush_id_ = uint64_t{0u};
}
inline uint64_t ConsolidateStateResponse::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline uint64_t ConsolidateStateResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.flush_id)
  return _internal_flush_id();
}
inline void ConsolidateStateResponse::_internal_set_flush_id(uint64_t value) {
  
  _impl_.flush_id_ = value;
}
inline void ConsolidateStateResponse::set_flush_id(uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ConsolidateStateResponse.flush_id)
}

// uint64 stored_flush_id = 3;
inline void ConsolidateStateResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = uint64_t{0u};
}
inline uint64_t ConsolidateStateResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline uint64_t ConsolidateStateResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void ConsolidateStateResponse::_internal_set_stored_flush_id(uint64_t value) {
  
  _impl_.stored_flush_id_ = value;
}
inline void ConsolidateStateResponse::set_stored_flush_id(uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ConsolidateStateResponse.stored_flush_id)
}

// .hashdb.v1.ResultCode result = 4;
inline bool ConsolidateStateResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool ConsolidateStateResponse::has_result() const {
  return _internal_has_result();
}
inline void ConsolidateStateResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& ConsolidateStateResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& ConsolidateStateResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ConsolidateStateResponse.result)
  return _internal_result();
}
inline void ConsolidateStateResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ConsolidateStateResponse.result)
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ConsolidateStateResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* ConsolidateStateResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ConsolidateStateResponse.result)
  return _msg;
}
inline void ConsolidateStateResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ConsolidateStateResponse.result)
}

// -------------------------------------------------------------------

// PurgeResponse

// .hashdb.v1.ResultCode result = 1;
inline bool PurgeResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool PurgeResponse::has_result() const {
  return _internal_has_result();
}
inline void PurgeResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& PurgeResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& PurgeResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.PurgeResponse.result)
  return _internal_result();
}
inline void PurgeResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.PurgeResponse.result)
}
inline ::hashdb::v1::ResultCode* PurgeResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* PurgeResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.PurgeResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* PurgeResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* PurgeResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.PurgeResponse.result)
  return _msg;
}
inline void PurgeResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.PurgeResponse.result)
}

// -------------------------------------------------------------------

// ReadTreeResponse

// repeated .hashdb.v1.KeyValue key_value = 1;
inline int ReadTreeResponse::_internal_key_value_size() const {
  return _impl_.key_value_.size();
}
inline int ReadTreeResponse::key_value_size() const {
  return _internal_key_value_size();
}
inline void ReadTreeResponse::clear_key_value() {
  _impl_.key_value_.Clear();
}
inline ::hashdb::v1::KeyValue* ReadTreeResponse::mutable_key_value(int index) {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeResponse.key_value)
  return _impl_.key_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >*
ReadTreeResponse::mutable_key_value() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.ReadTreeResponse.key_value)
  return &_impl_.key_value_;
}
inline const ::hashdb::v1::KeyValue& ReadTreeResponse::_internal_key_value(int index) const {
  return _impl_.key_value_.Get(index);
}
inline const ::hashdb::v1::KeyValue& ReadTreeResponse::key_value(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeResponse.key_value)
  return _internal_key_value(index);
}
inline ::hashdb::v1::KeyValue* ReadTreeResponse::_internal_add_key_value() {
  return _impl_.key_value_.Add();
}
inline ::hashdb::v1::KeyValue* ReadTreeResponse::add_key_value() {
  ::hashdb::v1::KeyValue* _add = _internal_add_key_value();
  // @@protoc_insertion_point(field_add:hashdb.v1.ReadTreeResponse.key_value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::KeyValue >&
ReadTreeResponse::key_value() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.ReadTreeResponse.key_value)
  return _impl_.key_value_;
}

// repeated .hashdb.v1.HashValueGL hash_value = 2;
inline int ReadTreeResponse::_internal_hash_value_size() const {
  return _impl_.hash_value_.size();
}
inline int ReadTreeResponse::hash_value_size() const {
  return _internal_hash_value_size();
}
inline void ReadTreeResponse::clear_hash_value() {
  _impl_.hash_value_.Clear();
}
inline ::hashdb::v1::HashValueGL* ReadTreeResponse::mutable_hash_value(int index) {
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeResponse.hash_value)
  return _impl_.hash_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >*
ReadTreeResponse::mutable_hash_value() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.ReadTreeResponse.hash_value)
  return &_impl_.hash_value_;
}
inline const ::hashdb::v1::HashValueGL& ReadTreeResponse::_internal_hash_value(int index) const {
  return _impl_.hash_value_.Get(index);
}
inline const ::hashdb::v1::HashValueGL& ReadTreeResponse::hash_value(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeResponse.hash_value)
  return _internal_hash_value(index);
}
inline ::hashdb::v1::HashValueGL* ReadTreeResponse::_internal_add_hash_value() {
  return _impl_.hash_value_.Add();
}
inline ::hashdb::v1::HashValueGL* ReadTreeResponse::add_hash_value() {
  ::hashdb::v1::HashValueGL* _add = _internal_add_hash_value();
  // @@protoc_insertion_point(field_add:hashdb.v1.ReadTreeResponse.hash_value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hashdb::v1::HashValueGL >&
ReadTreeResponse::hash_value() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.ReadTreeResponse.hash_value)
  return _impl_.hash_value_;
}

// .hashdb.v1.ResultCode result = 3;
inline bool ReadTreeResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool ReadTreeResponse::has_result() const {
  return _internal_has_result();
}
inline void ReadTreeResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& ReadTreeResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& ReadTreeResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ReadTreeResponse.result)
  return _internal_result();
}
inline void ReadTreeResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ReadTreeResponse.result)
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ReadTreeResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* ReadTreeResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ReadTreeResponse.result)
  return _msg;
}
inline void ReadTreeResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ReadTreeResponse.result)
}

// -------------------------------------------------------------------

// CancelBatchResponse

// .hashdb.v1.ResultCode result = 1;
inline bool CancelBatchResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool CancelBatchResponse::has_result() const {
  return _internal_has_result();
}
inline void CancelBatchResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& CancelBatchResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& CancelBatchResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.CancelBatchResponse.result)
  return _internal_result();
}
inline void CancelBatchResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.CancelBatchResponse.result)
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.CancelBatchResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* CancelBatchResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.CancelBatchResponse.result)
  return _msg;
}
inline void CancelBatchResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.CancelBatchResponse.result)
}

// -------------------------------------------------------------------

// ResetDBResponse

// .hashdb.v1.ResultCode result = 1;
inline bool ResetDBResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool ResetDBResponse::has_result() const {
  return _internal_has_result();
}
inline void ResetDBResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::hashdb::v1::ResultCode& ResetDBResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& ResetDBResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ResetDBResponse.result)
  return _internal_result();
}
inline void ResetDBResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.ResetDBResponse.result)
}
inline ::hashdb::v1::ResultCode* ResetDBResponse::release_result() {
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* ResetDBResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.ResetDBResponse.result)
  
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* ResetDBResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* ResetDBResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.ResetDBResponse.result)
  return _msg;
}
inline void ResetDBResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.ResetDBResponse.result)
}

// -------------------------------------------------------------------

// Fea

// uint64 fe0 = 1;
inline void Fea::clear_fe0() {
  _impl_.fe0_ = uint64_t{0u};
}
inline uint64_t Fea::_internal_fe0() const {
  return _impl_.fe0_;
}
inline uint64_t Fea::fe0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe0)
  return _internal_fe0();
}
inline void Fea::_internal_set_fe0(uint64_t value) {
  
  _impl_.fe0_ = value;
}
inline void Fea::set_fe0(uint64_t value) {
  _internal_set_fe0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe0)
}

// uint64 fe1 = 2;
inline void Fea::clear_fe1() {
  _impl_.fe1_ = uint64_t{0u};
}
inline uint64_t Fea::_internal_fe1() const {
  return _impl_.fe1_;
}
inline uint64_t Fea::fe1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe1)
  return _internal_fe1();
}
inline void Fea::_internal_set_fe1(uint64_t value) {
  
  _impl_.fe1_ = value;
}
inline void Fea::set_fe1(uint64_t value) {
  _internal_set_fe1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe1)
}

// uint64 fe2 = 3;
inline void Fea::clear_fe2() {
  _impl_.fe2_ = uint64_t{0u};
}
inline uint64_t Fea::_internal_fe2() const {
  return _impl_.fe2_;
}
inline uint64_t Fea::fe2() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe2)
  return _internal_fe2();
}
inline void Fea::_internal_set_fe2(uint64_t value) {
  
  _impl_.fe2_ = value;
}
inline void Fea::set_fe2(uint64_t value) {
  _internal_set_fe2(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe2)
}

// uint64 fe3 = 4;
inline void Fea::clear_fe3() {
  _impl_.fe3_ = uint64_t{0u};
}
inline uint64_t Fea::_internal_fe3() const {
  return _impl_.fe3_;
}
inline uint64_t Fea::fe3() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe3)
  return _internal_fe3();
}
inline void Fea::_internal_set_fe3(uint64_t value) {
  
  _impl_.fe3_ = value;
}
inline void Fea::set_fe3(uint64_t value) {
  _internal_set_fe3(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe3)
}

// -------------------------------------------------------------------

// Fea12

// uint64 fe0 = 1;
inline void Fea12::clear_fe0() {
  _impl_.fe0_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe0() const {
  return _impl_.fe0_;
}
inline uint64_t Fea12::fe0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe0)
  return _internal_fe0();
}
inline void Fea12::_internal_set_fe0(uint64_t value) {
  
  _impl_.fe0_ = value;
}
inline void Fea12::set_fe0(uint64_t value) {
  _internal_set_fe0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe0)
}

// uint64 fe1 = 2;
inline void Fea12::clear_fe1() {
  _impl_.fe1_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe1() const {
  return _impl_.fe1_;
}
inline uint64_t Fea12::fe1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe1)
  return _internal_fe1();
}
inline void Fea12::_internal_set_fe1(uint64_t value) {
  
  _impl_.fe1_ = value;
}
inline void Fea12::set_fe1(uint64_t value) {
  _internal_set_fe1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe1)
}

// uint64 fe2 = 3;
inline void Fea12::clear_fe2() {
  _impl_.fe2_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe2() const {
  return _impl_.fe2_;
}
inline uint64_t Fea12::fe2() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe2)
  return _internal_fe2();
}
inline void Fea12::_internal_set_fe2(uint64_t value) {
  
  _impl_.fe2_ = value;
}
inline void Fea12::set_fe2(uint64_t value) {
  _internal_set_fe2(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe2)
}

// uint64 fe3 = 4;
inline void Fea12::clear_fe3() {
  _impl_.fe3_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe3() const {
  return _impl_.fe3_;
}
inline uint64_t Fea12::fe3() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe3)
  return _internal_fe3();
}
inline void Fea12::_internal_set_fe3(uint64_t value) {
  
  _impl_.fe3_ = value;
}
inline void Fea12::set_fe3(uint64_t value) {
  _internal_set_fe3(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe3)
}

// uint64 fe4 = 5;
inline void Fea12::clear_fe4() {
  _impl_.fe4_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe4() const {
  return _impl_.fe4_;
}
inline uint64_t Fea12::fe4() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe4)
  return _internal_fe4();
}
inline void Fea12::_internal_set_fe4(uint64_t value) {
  
  _impl_.fe4_ = value;
}
inline void Fea12::set_fe4(uint64_t value) {
  _internal_set_fe4(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe4)
}

// uint64 fe5 = 6;
inline void Fea12::clear_fe5() {
  _impl_.fe5_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe5() const {
  return _impl_.fe5_;
}
inline uint64_t Fea12::fe5() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe5)
  return _internal_fe5();
}
inline void Fea12::_internal_set_fe5(uint64_t value) {
  
  _impl_.fe5_ = value;
}
inline void Fea12::set_fe5(uint64_t value) {
  _internal_set_fe5(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe5)
}

// uint64 fe6 = 7;
inline void Fea12::clear_fe6() {
  _impl_.fe6_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe6() const {
  return _impl_.fe6_;
}
inline uint64_t Fea12::fe6() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe6)
  return _internal_fe6();
}
inline void Fea12::_internal_set_fe6(uint64_t value) {
  
  _impl_.fe6_ = value;
}
inline void Fea12::set_fe6(uint64_t value) {
  _internal_set_fe6(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe6)
}

// uint64 fe7 = 8;
inline void Fea12::clear_fe7() {
  _impl_.fe7_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe7() const {
  return _impl_.fe7_;
}
inline uint64_t Fea12::fe7() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe7)
  return _internal_fe7();
}
inline void Fea12::_internal_set_fe7(uint64_t value) {
  
  _impl_.fe7_ = value;
}
inline void Fea12::set_fe7(uint64_t value) {
  _internal_set_fe7(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe7)
}

// uint64 fe8 = 9;
inline void Fea12::clear_fe8() {
  _impl_.fe8_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe8() const {
  return _impl_.fe8_;
}
inline uint64_t Fea12::fe8() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe8)
  return _internal_fe8();
}
inline void Fea12::_internal_set_fe8(uint64_t value) {
  
  _impl_.fe8_ = value;
}
inline void Fea12::set_fe8(uint64_t value) {
  _internal_set_fe8(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe8)
}

// uint64 fe9 = 10;
inline void Fea12::clear_fe9() {
  _impl_.fe9_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe9() const {
  return _impl_.fe9_;
}
inline uint64_t Fea12::fe9() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe9)
  return _internal_fe9();
}
inline void Fea12::_internal_set_fe9(uint64_t value) {
  
  _impl_.fe9_ = value;
}
inline void Fea12::set_fe9(uint64_t value) {
  _internal_set_fe9(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe9)
}

// uint64 fe10 = 11;
inline void Fea12::clear_fe10() {
  _impl_.fe10_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe10() const {
  return _impl_.fe10_;
}
inline uint64_t Fea12::fe10() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe10)
  return _internal_fe10();
}
inline void Fea12::_internal_set_fe10(uint64_t value) {
  
  _impl_.fe10_ = value;
}
inline void Fea12::set_fe10(uint64_t value) {
  _internal_set_fe10(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe10)
}

// uint64 fe11 = 12;
inline void Fea12::clear_fe11() {
  _impl_.fe11_ = uint64_t{0u};
}
inline uint64_t Fea12::_internal_fe11() const {
  return _impl_.fe11_;
}
inline uint64_t Fea12::fe11() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea12.fe11)
  return _internal_fe11();
}
inline void Fea12::_internal_set_fe11(uint64_t value) {
  
  _impl_.fe11_ = value;
}
inline void Fea12::set_fe11(uint64_t value) {
  _internal_set_fe11(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea12.fe11)
}

// -------------------------------------------------------------------

// HashValueGL

// .hashdb.v1.Fea hash = 1;
inline bool HashValueGL::_internal_has_hash() const {
  return this != internal_default_instance() && _impl_.hash_ != nullptr;
}
inline bool HashValueGL::has_hash() const {
  return _internal_has_hash();
}
inline void HashValueGL::clear_hash() {
  if (GetArenaForAllocation() == nullptr && _impl_.hash_ != nullptr) {
    delete _impl_.hash_;
  }
  _impl_.hash_ = nullptr;
}
inline const ::hashdb::v1::Fea& HashValueGL::_internal_hash() const {
  const ::hashdb::v1::Fea* p = _impl_.hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& HashValueGL::hash() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.HashValueGL.hash)
  return _internal_hash();
}
inline void HashValueGL::unsafe_arena_set_allocated_hash(
    ::hashdb::v1::Fea* hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hash_);
  }
  _impl_.hash_ = hash;
  if (hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.HashValueGL.hash)
}
inline ::hashdb::v1::Fea* HashValueGL::release_hash() {
  
  ::hashdb::v1::Fea* temp = _impl_.hash_;
  _impl_.hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* HashValueGL::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_release:hashdb.v1.HashValueGL.hash)
  
  ::hashdb::v1::Fea* temp = _impl_.hash_;
  _impl_.hash_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* HashValueGL::_internal_mutable_hash() {
  
  if (_impl_.hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.hash_ = p;
  }
  return _impl_.hash_;
}
inline ::hashdb::v1::Fea* HashValueGL::mutable_hash() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.HashValueGL.hash)
  return _msg;
}
inline void HashValueGL::set_allocated_hash(::hashdb::v1::Fea* hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hash_;
  }
  if (hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hash);
    if (message_arena != submessage_arena) {
      hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hash_ = hash;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.HashValueGL.hash)
}

// .hashdb.v1.Fea12 value = 2;
inline bool HashValueGL::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool HashValueGL::has_value() const {
  return _internal_has_value();
}
inline void HashValueGL::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::hashdb::v1::Fea12& HashValueGL::_internal_value() const {
  const ::hashdb::v1::Fea12* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea12&>(
      ::hashdb::v1::_Fea12_default_instance_);
}
inline const ::hashdb::v1::Fea12& HashValueGL::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.HashValueGL.value)
  return _internal_value();
}
inline void HashValueGL::unsafe_arena_set_allocated_value(
    ::hashdb::v1::Fea12* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.HashValueGL.value)
}
inline ::hashdb::v1::Fea12* HashValueGL::release_value() {
  
  ::hashdb::v1::Fea12* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea12* HashValueGL::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.HashValueGL.value)
  
  ::hashdb::v1::Fea12* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea12* HashValueGL::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea12>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::hashdb::v1::Fea12* HashValueGL::mutable_value() {
  ::hashdb::v1::Fea12* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.HashValueGL.value)
  return _msg;
}
inline void HashValueGL::set_allocated_value(::hashdb::v1::Fea12* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.HashValueGL.value)
}

// -------------------------------------------------------------------

// KeyValue

// .hashdb.v1.Fea key = 1;
inline bool KeyValue::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool KeyValue::has_key() const {
  return _internal_has_key();
}
inline void KeyValue::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::hashdb::v1::Fea& KeyValue::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.KeyValue.key)
  return _internal_key();
}
inline void KeyValue::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.KeyValue.key)
}
inline ::hashdb::v1::Fea* KeyValue::release_key() {
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* KeyValue::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.KeyValue.key)
  
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* KeyValue::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* KeyValue::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.KeyValue.key)
  return _msg;
}
inline void KeyValue::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.KeyValue.key)
}

// string value = 2;
inline void KeyValue::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.KeyValue.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValue::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.KeyValue.value)
}
inline std::string* KeyValue::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.KeyValue.value)
  return _s;
}
inline const std::string& KeyValue::_internal_value() const {
  return _impl_.value_.Get();
}
inline void KeyValue::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValue::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.KeyValue.value)
  return _impl_.value_.Release();
}
inline void KeyValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.KeyValue.value)
}

// -------------------------------------------------------------------

// FeList

// repeated uint64 fe = 1;
inline int FeList::_internal_fe_size() const {
  return _impl_.fe_.size();
}
inline int FeList::fe_size() const {
  return _internal_fe_size();
}
inline void FeList::clear_fe() {
  _impl_.fe_.Clear();
}
inline uint64_t FeList::_internal_fe(int index) const {
  return _impl_.fe_.Get(index);
}
inline uint64_t FeList::fe(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FeList.fe)
  return _internal_fe(index);
}
inline void FeList::set_fe(int index, uint64_t value) {
  _impl_.fe_.Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FeList.fe)
}
inline void FeList::_internal_add_fe(uint64_t value) {
  _impl_.fe_.Add(value);
}
inline void FeList::add_fe(uint64_t value) {
  _internal_add_fe(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.FeList.fe)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
FeList::_internal_fe() const {
  return _impl_.fe_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
FeList::fe() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.FeList.fe)
  return _internal_fe();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
FeList::_internal_mutable_fe() {
  return &_impl_.fe_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
FeList::mutable_fe() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.FeList.fe)
  return _internal_mutable_fe();
}

// -------------------------------------------------------------------

// SiblingList

// repeated uint64 sibling = 1;
inline int SiblingList::_internal_sibling_size() const {
  return _impl_.sibling_.size();
}
inline int SiblingList::sibling_size() const {
  return _internal_sibling_size();
}
inline void SiblingList::clear_sibling() {
  _impl_.sibling_.Clear();
}
inline uint64_t SiblingList::_internal_sibling(int index) const {
  return _impl_.sibling_.Get(index);
}
inline uint64_t SiblingList::sibling(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SiblingList.sibling)
  return _internal_sibling(index);
}
inline void SiblingList::set_sibling(int index, uint64_t value) {
  _impl_.sibling_.Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SiblingList.sibling)
}
inline void SiblingList::_internal_add_sibling(uint64_t value) {
  _impl_.sibling_.Add(value);
}
inline void SiblingList::add_sibling(uint64_t value) {
  _internal_add_sibling(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.SiblingList.sibling)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SiblingList::_internal_sibling() const {
  return _impl_.sibling_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SiblingList::sibling() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.SiblingList.sibling)
  return _internal_sibling();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SiblingList::_internal_mutable_sibling() {
  return &_impl_.sibling_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SiblingList::mutable_sibling() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.SiblingList.sibling)
  return _internal_mutable_sibling();
}

// -------------------------------------------------------------------

// ResultCode

// .hashdb.v1.ResultCode.Code code = 1;
inline void ResultCode::clear_code() {
  _impl_.code_ = 0;
}
inline ::hashdb::v1::ResultCode_Code ResultCode::_internal_code() const {
  return static_cast< ::hashdb::v1::ResultCode_Code >(_impl_.code_);
}
inline ::hashdb::v1::ResultCode_Code ResultCode::code() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ResultCode.code)
  return _internal_code();
}
inline void ResultCode::_internal_set_code(::hashdb::v1::ResultCode_Code value) {
  
  _impl_.code_ = value;
}
inline void ResultCode::set_code(::hashdb::v1::ResultCode_Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ResultCode.code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace hashdb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hashdb::v1::ResultCode_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hashdb::v1::ResultCode_Code>() {
  return ::hashdb::v1::ResultCode_Code_descriptor();
}
template <> struct is_proto_enum< ::hashdb::v1::Persistence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hashdb::v1::Persistence>() {
  return ::hashdb::v1::Persistence_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto
