// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hashdb.proto

#include "hashdb.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace hashdb {
namespace v1 {
PROTOBUF_CONSTEXPR Version::Version(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v0_0_1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;
PROTOBUF_CONSTEXPR SetRequest::SetRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_root_)*/nullptr
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_.details_)*/false
  , /*decltype(_impl_.get_db_read_log_)*/false
  , /*decltype(_impl_.tx_index_)*/uint64_t{0u}
  , /*decltype(_impl_.block_index_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetRequestDefaultTypeInternal() {}
  union {
    SetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetRequestDefaultTypeInternal _SetRequest_default_instance_;
PROTOBUF_CONSTEXPR GetRequest::GetRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.root_)*/nullptr
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.details_)*/false
  , /*decltype(_impl_.get_db_read_log_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetRequestDefaultTypeInternal() {}
  union {
    GetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetRequestDefaultTypeInternal _GetRequest_default_instance_;
PROTOBUF_CONSTEXPR SetProgramRequest::SetProgramRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.tx_index_)*/uint64_t{0u}
  , /*decltype(_impl_.block_index_)*/uint64_t{0u}
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetProgramRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetProgramRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetProgramRequestDefaultTypeInternal() {}
  union {
    SetProgramRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetProgramRequestDefaultTypeInternal _SetProgramRequest_default_instance_;
PROTOBUF_CONSTEXPR GetProgramRequest::GetProgramRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetProgramRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetProgramRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetProgramRequestDefaultTypeInternal() {}
  union {
    GetProgramRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetProgramRequestDefaultTypeInternal _GetProgramRequest_default_instance_;
PROTOBUF_CONSTEXPR LoadDBRequest_InputDbEntry_DoNotUse::LoadDBRequest_InputDbEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LoadDBRequest_InputDbEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal _LoadDBRequest_InputDbEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LoadDBRequest::LoadDBRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_db_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.state_root_)*/nullptr
  , /*decltype(_impl_.persistent_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoadDBRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadDBRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadDBRequestDefaultTypeInternal() {}
  union {
    LoadDBRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadDBRequestDefaultTypeInternal _LoadDBRequest_default_instance_;
PROTOBUF_CONSTEXPR LoadProgramDBRequest_InputProgramDbEntry_DoNotUse::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal() {}
  union {
    LoadProgramDBRequest_InputProgramDbEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal _LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR LoadProgramDBRequest::LoadProgramDBRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_program_db_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.persistent_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoadProgramDBRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadProgramDBRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadProgramDBRequestDefaultTypeInternal() {}
  union {
    LoadProgramDBRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadProgramDBRequestDefaultTypeInternal _LoadProgramDBRequest_default_instance_;
PROTOBUF_CONSTEXPR FlushRequest::FlushRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_state_root_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlushRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushRequestDefaultTypeInternal() {}
  union {
    FlushRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushRequestDefaultTypeInternal _FlushRequest_default_instance_;
PROTOBUF_CONSTEXPR FinishTxRequest::FinishTxRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_state_root_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FinishTxRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FinishTxRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FinishTxRequestDefaultTypeInternal() {}
  union {
    FinishTxRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FinishTxRequestDefaultTypeInternal _FinishTxRequest_default_instance_;
PROTOBUF_CONSTEXPR StartBlockRequest::StartBlockRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_state_root_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StartBlockRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartBlockRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartBlockRequestDefaultTypeInternal() {}
  union {
    StartBlockRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartBlockRequestDefaultTypeInternal _StartBlockRequest_default_instance_;
PROTOBUF_CONSTEXPR FinishBlockRequest::FinishBlockRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_state_root_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FinishBlockRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FinishBlockRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FinishBlockRequestDefaultTypeInternal() {}
  union {
    FinishBlockRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FinishBlockRequestDefaultTypeInternal _FinishBlockRequest_default_instance_;
PROTOBUF_CONSTEXPR GetFlushDataRequest::GetFlushDataRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetFlushDataRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetFlushDataRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetFlushDataRequestDefaultTypeInternal() {}
  union {
    GetFlushDataRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetFlushDataRequestDefaultTypeInternal _GetFlushDataRequest_default_instance_;
PROTOBUF_CONSTEXPR ConsolidateStateRequest::ConsolidateStateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.virtual_state_root_)*/nullptr
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConsolidateStateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConsolidateStateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConsolidateStateRequestDefaultTypeInternal() {}
  union {
    ConsolidateStateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConsolidateStateRequestDefaultTypeInternal _ConsolidateStateRequest_default_instance_;
PROTOBUF_CONSTEXPR PurgeRequest::PurgeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_state_root_)*/nullptr
  , /*decltype(_impl_.persistence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PurgeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PurgeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PurgeRequestDefaultTypeInternal() {}
  union {
    PurgeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PurgeRequestDefaultTypeInternal _PurgeRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadTreeRequest::ReadTreeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.state_root_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadTreeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadTreeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadTreeRequestDefaultTypeInternal() {}
  union {
    ReadTreeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadTreeRequestDefaultTypeInternal _ReadTreeRequest_default_instance_;
PROTOBUF_CONSTEXPR CancelBatchRequest::CancelBatchRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.batch_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CancelBatchRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CancelBatchRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CancelBatchRequestDefaultTypeInternal() {}
  union {
    CancelBatchRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CancelBatchRequestDefaultTypeInternal _CancelBatchRequest_default_instance_;
PROTOBUF_CONSTEXPR GetLatestStateRootResponse::GetLatestStateRootResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.latest_root_)*/nullptr
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetLatestStateRootResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetLatestStateRootResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetLatestStateRootResponseDefaultTypeInternal() {}
  union {
    GetLatestStateRootResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetLatestStateRootResponseDefaultTypeInternal _GetLatestStateRootResponse_default_instance_;
PROTOBUF_CONSTEXPR SetResponse_SiblingsEntry_DoNotUse::SetResponse_SiblingsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SetResponse_SiblingsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _SetResponse_SiblingsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SetResponse_DbReadLogEntry_DoNotUse::SetResponse_DbReadLogEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SetResponse_DbReadLogEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _SetResponse_DbReadLogEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SetResponse::SetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.siblings_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.db_read_log_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.ins_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.new_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_root_)*/nullptr
  , /*decltype(_impl_.new_root_)*/nullptr
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.ins_key_)*/nullptr
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_.sibling_left_child_)*/nullptr
  , /*decltype(_impl_.sibling_right_child_)*/nullptr
  , /*decltype(_impl_.proof_hash_counter_)*/uint64_t{0u}
  , /*decltype(_impl_.is_old0_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetResponseDefaultTypeInternal() {}
  union {
    SetResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetResponseDefaultTypeInternal _SetResponse_default_instance_;
PROTOBUF_CONSTEXPR GetResponse_SiblingsEntry_DoNotUse::GetResponse_SiblingsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    GetResponse_SiblingsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _GetResponse_SiblingsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR GetResponse_DbReadLogEntry_DoNotUse::GetResponse_DbReadLogEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal() {}
  union {
    GetResponse_DbReadLogEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _GetResponse_DbReadLogEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR GetResponse::GetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.siblings_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.db_read_log_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.ins_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.root_)*/nullptr
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.ins_key_)*/nullptr
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_.proof_hash_counter_)*/uint64_t{0u}
  , /*decltype(_impl_.is_old0_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetResponseDefaultTypeInternal() {}
  union {
    GetResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetResponseDefaultTypeInternal _GetResponse_default_instance_;
PROTOBUF_CONSTEXPR SetProgramResponse::SetProgramResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetProgramResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetProgramResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetProgramResponseDefaultTypeInternal() {}
  union {
    SetProgramResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetProgramResponseDefaultTypeInternal _SetProgramResponse_default_instance_;
PROTOBUF_CONSTEXPR GetProgramResponse::GetProgramResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetProgramResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetProgramResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetProgramResponseDefaultTypeInternal() {}
  union {
    GetProgramResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetProgramResponseDefaultTypeInternal _GetProgramResponse_default_instance_;
PROTOBUF_CONSTEXPR FlushResponse::FlushResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_.flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_.stored_flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlushResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushResponseDefaultTypeInternal() {}
  union {
    FlushResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushResponseDefaultTypeInternal _FlushResponse_default_instance_;
PROTOBUF_CONSTEXPR GetFlushStatusResponse::GetFlushStatusResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.prover_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stored_flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_.storing_flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_.last_flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_.pending_to_flush_nodes_)*/uint64_t{0u}
  , /*decltype(_impl_.pending_to_flush_program_)*/uint64_t{0u}
  , /*decltype(_impl_.storing_nodes_)*/uint64_t{0u}
  , /*decltype(_impl_.storing_program_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetFlushStatusResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetFlushStatusResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetFlushStatusResponseDefaultTypeInternal() {}
  union {
    GetFlushStatusResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetFlushStatusResponseDefaultTypeInternal _GetFlushStatusResponse_default_instance_;
PROTOBUF_CONSTEXPR GetFlushDataResponse_NodesEntry_DoNotUse::GetFlushDataResponse_NodesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    GetFlushDataResponse_NodesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR GetFlushDataResponse_ProgramEntry_DoNotUse::GetFlushDataResponse_ProgramEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal() {}
  union {
    GetFlushDataResponse_ProgramEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR GetFlushDataResponse::GetFlushDataResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.program_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.nodes_state_root_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_.stored_flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetFlushDataResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetFlushDataResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetFlushDataResponseDefaultTypeInternal() {}
  union {
    GetFlushDataResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetFlushDataResponseDefaultTypeInternal _GetFlushDataResponse_default_instance_;
PROTOBUF_CONSTEXPR ConsolidateStateResponse::ConsolidateStateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.consolidated_state_root_)*/nullptr
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_.flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_.stored_flush_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConsolidateStateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConsolidateStateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConsolidateStateResponseDefaultTypeInternal() {}
  union {
    ConsolidateStateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConsolidateStateResponseDefaultTypeInternal _ConsolidateStateResponse_default_instance_;
PROTOBUF_CONSTEXPR PurgeResponse::PurgeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PurgeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PurgeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PurgeResponseDefaultTypeInternal() {}
  union {
    PurgeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PurgeResponseDefaultTypeInternal _PurgeResponse_default_instance_;
PROTOBUF_CONSTEXPR ReadTreeResponse::ReadTreeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_value_)*/{}
  , /*decltype(_impl_.hash_value_)*/{}
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadTreeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadTreeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadTreeResponseDefaultTypeInternal() {}
  union {
    ReadTreeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadTreeResponseDefaultTypeInternal _ReadTreeResponse_default_instance_;
PROTOBUF_CONSTEXPR CancelBatchResponse::CancelBatchResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CancelBatchResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CancelBatchResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CancelBatchResponseDefaultTypeInternal() {}
  union {
    CancelBatchResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CancelBatchResponseDefaultTypeInternal _CancelBatchResponse_default_instance_;
PROTOBUF_CONSTEXPR ResetDBResponse::ResetDBResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResetDBResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetDBResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetDBResponseDefaultTypeInternal() {}
  union {
    ResetDBResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetDBResponseDefaultTypeInternal _ResetDBResponse_default_instance_;
PROTOBUF_CONSTEXPR Fea::Fea(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fe0_)*/uint64_t{0u}
  , /*decltype(_impl_.fe1_)*/uint64_t{0u}
  , /*decltype(_impl_.fe2_)*/uint64_t{0u}
  , /*decltype(_impl_.fe3_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeaDefaultTypeInternal() {}
  union {
    Fea _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeaDefaultTypeInternal _Fea_default_instance_;
PROTOBUF_CONSTEXPR Fea12::Fea12(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fe0_)*/uint64_t{0u}
  , /*decltype(_impl_.fe1_)*/uint64_t{0u}
  , /*decltype(_impl_.fe2_)*/uint64_t{0u}
  , /*decltype(_impl_.fe3_)*/uint64_t{0u}
  , /*decltype(_impl_.fe4_)*/uint64_t{0u}
  , /*decltype(_impl_.fe5_)*/uint64_t{0u}
  , /*decltype(_impl_.fe6_)*/uint64_t{0u}
  , /*decltype(_impl_.fe7_)*/uint64_t{0u}
  , /*decltype(_impl_.fe8_)*/uint64_t{0u}
  , /*decltype(_impl_.fe9_)*/uint64_t{0u}
  , /*decltype(_impl_.fe10_)*/uint64_t{0u}
  , /*decltype(_impl_.fe11_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Fea12DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fea12DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fea12DefaultTypeInternal() {}
  union {
    Fea12 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fea12DefaultTypeInternal _Fea12_default_instance_;
PROTOBUF_CONSTEXPR HashValueGL::HashValueGL(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash_)*/nullptr
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HashValueGLDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashValueGLDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashValueGLDefaultTypeInternal() {}
  union {
    HashValueGL _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashValueGLDefaultTypeInternal _HashValueGL_default_instance_;
PROTOBUF_CONSTEXPR KeyValue::KeyValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyValueDefaultTypeInternal() {}
  union {
    KeyValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyValueDefaultTypeInternal _KeyValue_default_instance_;
PROTOBUF_CONSTEXPR FeList::FeList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fe_)*/{}
  , /*decltype(_impl_._fe_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FeListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeListDefaultTypeInternal() {}
  union {
    FeList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeListDefaultTypeInternal _FeList_default_instance_;
PROTOBUF_CONSTEXPR SiblingList::SiblingList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sibling_)*/{}
  , /*decltype(_impl_._sibling_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SiblingListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SiblingListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SiblingListDefaultTypeInternal() {}
  union {
    SiblingList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SiblingListDefaultTypeInternal _SiblingList_default_instance_;
PROTOBUF_CONSTEXPR ResultCode::ResultCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResultCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResultCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResultCodeDefaultTypeInternal() {}
  union {
    ResultCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResultCodeDefaultTypeInternal _ResultCode_default_instance_;
}  // namespace v1
}  // namespace hashdb
static ::_pb::Metadata file_level_metadata_hashdb_2eproto[44];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_hashdb_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_hashdb_2eproto = nullptr;

const uint32_t TableStruct_hashdb_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Version, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Version, _impl_.v0_0_1_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.old_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.persistence_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.details_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.get_db_read_log_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.tx_index_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetRequest, _impl_.block_index_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetRequest, _impl_.root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetRequest, _impl_.details_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetRequest, _impl_.get_db_read_log_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetRequest, _impl_.batch_uuid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramRequest, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramRequest, _impl_.persistence_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramRequest, _impl_.tx_index_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramRequest, _impl_.block_index_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetProgramRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetProgramRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetProgramRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest, _impl_.input_db_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest, _impl_.persistent_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadDBRequest, _impl_.state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadProgramDBRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadProgramDBRequest, _impl_.input_program_db_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::LoadProgramDBRequest, _impl_.persistent_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushRequest, _impl_.new_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushRequest, _impl_.persistence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishTxRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishTxRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishTxRequest, _impl_.new_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishTxRequest, _impl_.persistence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::StartBlockRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::StartBlockRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::StartBlockRequest, _impl_.old_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::StartBlockRequest, _impl_.persistence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishBlockRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishBlockRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishBlockRequest, _impl_.new_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FinishBlockRequest, _impl_.persistence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataRequest, _impl_.flush_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateRequest, _impl_.virtual_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateRequest, _impl_.persistence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::PurgeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::PurgeRequest, _impl_.batch_uuid_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::PurgeRequest, _impl_.new_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::PurgeRequest, _impl_.persistence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ReadTreeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ReadTreeRequest, _impl_.state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ReadTreeRequest, _impl_.keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::CancelBatchRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::CancelBatchRequest, _impl_.batch_uuid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetLatestStateRootResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetLatestStateRootResponse, _impl_.latest_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetLatestStateRootResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.old_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.new_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.siblings_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.ins_key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.ins_value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.is_old0_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.old_value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.new_value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.proof_hash_counter_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.db_read_log_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.sibling_left_child_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetResponse, _impl_.sibling_right_child_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.siblings_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.ins_key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.ins_value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.is_old0_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.proof_hash_counter_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.db_read_log_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SetProgramResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetProgramResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetProgramResponse, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetProgramResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushResponse, _impl_.flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushResponse, _impl_.stored_flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FlushResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.stored_flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.storing_flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.last_flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.pending_to_flush_nodes_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.pending_to_flush_program_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.storing_nodes_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.storing_program_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushStatusResponse, _impl_.prover_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse, _impl_.stored_flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse, _impl_.program_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse, _impl_.nodes_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::GetFlushDataResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateResponse, _impl_.consolidated_state_root_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateResponse, _impl_.flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateResponse, _impl_.stored_flush_id_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ConsolidateStateResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::PurgeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::PurgeResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ReadTreeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ReadTreeResponse, _impl_.key_value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ReadTreeResponse, _impl_.hash_value_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ReadTreeResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::CancelBatchResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::CancelBatchResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ResetDBResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ResetDBResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea, _impl_.fe0_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea, _impl_.fe1_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea, _impl_.fe2_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea, _impl_.fe3_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe0_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe1_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe2_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe3_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe4_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe5_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe6_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe7_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe8_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe9_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe10_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::Fea12, _impl_.fe11_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::HashValueGL, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::HashValueGL, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::HashValueGL, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::KeyValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::KeyValue, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::KeyValue, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FeList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::FeList, _impl_.fe_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SiblingList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::SiblingList, _impl_.sibling_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ResultCode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hashdb::v1::ResultCode, _impl_.code_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::hashdb::v1::Version)},
  { 7, -1, -1, sizeof(::hashdb::v1::SetRequest)},
  { 22, -1, -1, sizeof(::hashdb::v1::GetRequest)},
  { 33, -1, -1, sizeof(::hashdb::v1::SetProgramRequest)},
  { 45, -1, -1, sizeof(::hashdb::v1::GetProgramRequest)},
  { 53, 61, -1, sizeof(::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse)},
  { 63, -1, -1, sizeof(::hashdb::v1::LoadDBRequest)},
  { 72, 80, -1, sizeof(::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse)},
  { 82, -1, -1, sizeof(::hashdb::v1::LoadProgramDBRequest)},
  { 90, -1, -1, sizeof(::hashdb::v1::FlushRequest)},
  { 99, -1, -1, sizeof(::hashdb::v1::FinishTxRequest)},
  { 108, -1, -1, sizeof(::hashdb::v1::StartBlockRequest)},
  { 117, -1, -1, sizeof(::hashdb::v1::FinishBlockRequest)},
  { 126, -1, -1, sizeof(::hashdb::v1::GetFlushDataRequest)},
  { 133, -1, -1, sizeof(::hashdb::v1::ConsolidateStateRequest)},
  { 141, -1, -1, sizeof(::hashdb::v1::PurgeRequest)},
  { 150, -1, -1, sizeof(::hashdb::v1::ReadTreeRequest)},
  { 158, -1, -1, sizeof(::hashdb::v1::CancelBatchRequest)},
  { 165, -1, -1, sizeof(::hashdb::v1::GetLatestStateRootResponse)},
  { 173, 181, -1, sizeof(::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse)},
  { 183, 191, -1, sizeof(::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse)},
  { 193, -1, -1, sizeof(::hashdb::v1::SetResponse)},
  { 214, 222, -1, sizeof(::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse)},
  { 224, 232, -1, sizeof(::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse)},
  { 234, -1, -1, sizeof(::hashdb::v1::GetResponse)},
  { 250, -1, -1, sizeof(::hashdb::v1::SetProgramResponse)},
  { 257, -1, -1, sizeof(::hashdb::v1::GetProgramResponse)},
  { 265, -1, -1, sizeof(::hashdb::v1::FlushResponse)},
  { 274, -1, -1, sizeof(::hashdb::v1::GetFlushStatusResponse)},
  { 288, 296, -1, sizeof(::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse)},
  { 298, 306, -1, sizeof(::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse)},
  { 308, -1, -1, sizeof(::hashdb::v1::GetFlushDataResponse)},
  { 319, -1, -1, sizeof(::hashdb::v1::ConsolidateStateResponse)},
  { 329, -1, -1, sizeof(::hashdb::v1::PurgeResponse)},
  { 336, -1, -1, sizeof(::hashdb::v1::ReadTreeResponse)},
  { 345, -1, -1, sizeof(::hashdb::v1::CancelBatchResponse)},
  { 352, -1, -1, sizeof(::hashdb::v1::ResetDBResponse)},
  { 359, -1, -1, sizeof(::hashdb::v1::Fea)},
  { 369, -1, -1, sizeof(::hashdb::v1::Fea12)},
  { 387, -1, -1, sizeof(::hashdb::v1::HashValueGL)},
  { 395, -1, -1, sizeof(::hashdb::v1::KeyValue)},
  { 403, -1, -1, sizeof(::hashdb::v1::FeList)},
  { 410, -1, -1, sizeof(::hashdb::v1::SiblingList)},
  { 417, -1, -1, sizeof(::hashdb::v1::ResultCode)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::hashdb::v1::_Version_default_instance_._instance,
  &::hashdb::v1::_SetRequest_default_instance_._instance,
  &::hashdb::v1::_GetRequest_default_instance_._instance,
  &::hashdb::v1::_SetProgramRequest_default_instance_._instance,
  &::hashdb::v1::_GetProgramRequest_default_instance_._instance,
  &::hashdb::v1::_LoadDBRequest_InputDbEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_LoadDBRequest_default_instance_._instance,
  &::hashdb::v1::_LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_LoadProgramDBRequest_default_instance_._instance,
  &::hashdb::v1::_FlushRequest_default_instance_._instance,
  &::hashdb::v1::_FinishTxRequest_default_instance_._instance,
  &::hashdb::v1::_StartBlockRequest_default_instance_._instance,
  &::hashdb::v1::_FinishBlockRequest_default_instance_._instance,
  &::hashdb::v1::_GetFlushDataRequest_default_instance_._instance,
  &::hashdb::v1::_ConsolidateStateRequest_default_instance_._instance,
  &::hashdb::v1::_PurgeRequest_default_instance_._instance,
  &::hashdb::v1::_ReadTreeRequest_default_instance_._instance,
  &::hashdb::v1::_CancelBatchRequest_default_instance_._instance,
  &::hashdb::v1::_GetLatestStateRootResponse_default_instance_._instance,
  &::hashdb::v1::_SetResponse_SiblingsEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_SetResponse_DbReadLogEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_SetResponse_default_instance_._instance,
  &::hashdb::v1::_GetResponse_SiblingsEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_GetResponse_DbReadLogEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_GetResponse_default_instance_._instance,
  &::hashdb::v1::_SetProgramResponse_default_instance_._instance,
  &::hashdb::v1::_GetProgramResponse_default_instance_._instance,
  &::hashdb::v1::_FlushResponse_default_instance_._instance,
  &::hashdb::v1::_GetFlushStatusResponse_default_instance_._instance,
  &::hashdb::v1::_GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_._instance,
  &::hashdb::v1::_GetFlushDataResponse_default_instance_._instance,
  &::hashdb::v1::_ConsolidateStateResponse_default_instance_._instance,
  &::hashdb::v1::_PurgeResponse_default_instance_._instance,
  &::hashdb::v1::_ReadTreeResponse_default_instance_._instance,
  &::hashdb::v1::_CancelBatchResponse_default_instance_._instance,
  &::hashdb::v1::_ResetDBResponse_default_instance_._instance,
  &::hashdb::v1::_Fea_default_instance_._instance,
  &::hashdb::v1::_Fea12_default_instance_._instance,
  &::hashdb::v1::_HashValueGL_default_instance_._instance,
  &::hashdb::v1::_KeyValue_default_instance_._instance,
  &::hashdb::v1::_FeList_default_instance_._instance,
  &::hashdb::v1::_SiblingList_default_instance_._instance,
  &::hashdb::v1::_ResultCode_default_instance_._instance,
};

const char descriptor_table_protodef_hashdb_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014hashdb.proto\022\thashdb.v1\032\033google/protob"
  "uf/empty.proto\"\031\n\007Version\022\016\n\006v0_0_1\030\001 \001("
  "\t\"\354\001\n\nSetRequest\022 \n\010old_root\030\001 \001(\0132\016.has"
  "hdb.v1.Fea\022\033\n\003key\030\002 \001(\0132\016.hashdb.v1.Fea\022"
  "\r\n\005value\030\003 \001(\t\022+\n\013persistence\030\004 \001(\0162\026.ha"
  "shdb.v1.Persistence\022\017\n\007details\030\005 \001(\010\022\027\n\017"
  "get_db_read_log\030\006 \001(\010\022\022\n\nbatch_uuid\030\007 \001("
  "\t\022\020\n\010tx_index\030\010 \001(\004\022\023\n\013block_index\030\t \001(\004"
  "\"\205\001\n\nGetRequest\022\034\n\004root\030\001 \001(\0132\016.hashdb.v"
  "1.Fea\022\033\n\003key\030\002 \001(\0132\016.hashdb.v1.Fea\022\017\n\007de"
  "tails\030\003 \001(\010\022\027\n\017get_db_read_log\030\004 \001(\010\022\022\n\n"
  "batch_uuid\030\005 \001(\t\"\246\001\n\021SetProgramRequest\022\033"
  "\n\003key\030\001 \001(\0132\016.hashdb.v1.Fea\022\014\n\004data\030\002 \001("
  "\014\022+\n\013persistence\030\003 \001(\0162\026.hashdb.v1.Persi"
  "stence\022\022\n\nbatch_uuid\030\004 \001(\t\022\020\n\010tx_index\030\005"
  " \001(\004\022\023\n\013block_index\030\006 \001(\004\"D\n\021GetProgramR"
  "equest\022\033\n\003key\030\001 \001(\0132\016.hashdb.v1.Fea\022\022\n\nb"
  "atch_uuid\030\002 \001(\t\"\303\001\n\rLoadDBRequest\0227\n\010inp"
  "ut_db\030\001 \003(\0132%.hashdb.v1.LoadDBRequest.In"
  "putDbEntry\022\022\n\npersistent\030\002 \001(\010\022\"\n\nstate_"
  "root\030\003 \001(\0132\016.hashdb.v1.Fea\032A\n\014InputDbEnt"
  "ry\022\013\n\003key\030\001 \001(\t\022 \n\005value\030\002 \001(\0132\021.hashdb."
  "v1.FeList:\0028\001\"\260\001\n\024LoadProgramDBRequest\022M"
  "\n\020input_program_db\030\001 \003(\01323.hashdb.v1.Loa"
  "dProgramDBRequest.InputProgramDbEntry\022\022\n"
  "\npersistent\030\002 \001(\010\0325\n\023InputProgramDbEntry"
  "\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\014:\0028\001\"g\n\014Flus"
  "hRequest\022\022\n\nbatch_uuid\030\001 \001(\t\022\026\n\016new_stat"
  "e_root\030\002 \001(\t\022+\n\013persistence\030\003 \001(\0162\026.hash"
  "db.v1.Persistence\"j\n\017FinishTxRequest\022\022\n\n"
  "batch_uuid\030\001 \001(\t\022\026\n\016new_state_root\030\002 \001(\t"
  "\022+\n\013persistence\030\003 \001(\0162\026.hashdb.v1.Persis"
  "tence\"l\n\021StartBlockRequest\022\022\n\nbatch_uuid"
  "\030\001 \001(\t\022\026\n\016old_state_root\030\002 \001(\t\022+\n\013persis"
  "tence\030\003 \001(\0162\026.hashdb.v1.Persistence\"m\n\022F"
  "inishBlockRequest\022\022\n\nbatch_uuid\030\001 \001(\t\022\026\n"
  "\016new_state_root\030\002 \001(\t\022+\n\013persistence\030\003 \001"
  "(\0162\026.hashdb.v1.Persistence\"\'\n\023GetFlushDa"
  "taRequest\022\020\n\010flush_id\030\001 \001(\004\"r\n\027Consolida"
  "teStateRequest\022*\n\022virtual_state_root\030\001 \001"
  "(\0132\016.hashdb.v1.Fea\022+\n\013persistence\030\002 \001(\0162"
  "\026.hashdb.v1.Persistence\"w\n\014PurgeRequest\022"
  "\022\n\nbatch_uuid\030\001 \001(\t\022&\n\016new_state_root\030\002 "
  "\001(\0132\016.hashdb.v1.Fea\022+\n\013persistence\030\003 \001(\016"
  "2\026.hashdb.v1.Persistence\"S\n\017ReadTreeRequ"
  "est\022\"\n\nstate_root\030\001 \001(\0132\016.hashdb.v1.Fea\022"
  "\034\n\004keys\030\002 \003(\0132\016.hashdb.v1.Fea\"(\n\022CancelB"
  "atchRequest\022\022\n\nbatch_uuid\030\001 \001(\t\"h\n\032GetLa"
  "testStateRootResponse\022#\n\013latest_root\030\001 \001"
  "(\0132\016.hashdb.v1.Fea\022%\n\006result\030\002 \001(\0132\025.has"
  "hdb.v1.ResultCode\"\205\005\n\013SetResponse\022 \n\010old"
  "_root\030\001 \001(\0132\016.hashdb.v1.Fea\022 \n\010new_root\030"
  "\002 \001(\0132\016.hashdb.v1.Fea\022\033\n\003key\030\003 \001(\0132\016.has"
  "hdb.v1.Fea\0226\n\010siblings\030\004 \003(\0132$.hashdb.v1"
  ".SetResponse.SiblingsEntry\022\037\n\007ins_key\030\005 "
  "\001(\0132\016.hashdb.v1.Fea\022\021\n\tins_value\030\006 \001(\t\022\017"
  "\n\007is_old0\030\007 \001(\010\022\021\n\told_value\030\010 \001(\t\022\021\n\tne"
  "w_value\030\t \001(\t\022\014\n\004mode\030\n \001(\t\022\032\n\022proof_has"
  "h_counter\030\013 \001(\004\022:\n\013db_read_log\030\014 \003(\0132%.h"
  "ashdb.v1.SetResponse.DbReadLogEntry\022%\n\006r"
  "esult\030\r \001(\0132\025.hashdb.v1.ResultCode\022*\n\022si"
  "bling_left_child\030\016 \001(\0132\016.hashdb.v1.Fea\022+"
  "\n\023sibling_right_child\030\017 \001(\0132\016.hashdb.v1."
  "Fea\032G\n\rSiblingsEntry\022\013\n\003key\030\001 \001(\004\022%\n\005val"
  "ue\030\002 \001(\0132\026.hashdb.v1.SiblingList:\0028\001\032C\n\016"
  "DbReadLogEntry\022\013\n\003key\030\001 \001(\t\022 \n\005value\030\002 \001"
  "(\0132\021.hashdb.v1.FeList:\0028\001\"\341\003\n\013GetRespons"
  "e\022\034\n\004root\030\001 \001(\0132\016.hashdb.v1.Fea\022\033\n\003key\030\002"
  " \001(\0132\016.hashdb.v1.Fea\0226\n\010siblings\030\003 \003(\0132$"
  ".hashdb.v1.GetResponse.SiblingsEntry\022\037\n\007"
  "ins_key\030\004 \001(\0132\016.hashdb.v1.Fea\022\021\n\tins_val"
  "ue\030\005 \001(\t\022\017\n\007is_old0\030\006 \001(\010\022\r\n\005value\030\007 \001(\t"
  "\022\032\n\022proof_hash_counter\030\010 \001(\004\022:\n\013db_read_"
  "log\030\t \003(\0132%.hashdb.v1.GetResponse.DbRead"
  "LogEntry\022%\n\006result\030\n \001(\0132\025.hashdb.v1.Res"
  "ultCode\032G\n\rSiblingsEntry\022\013\n\003key\030\001 \001(\004\022%\n"
  "\005value\030\002 \001(\0132\026.hashdb.v1.SiblingList:\0028\001"
  "\032C\n\016DbReadLogEntry\022\013\n\003key\030\001 \001(\t\022 \n\005value"
  "\030\002 \001(\0132\021.hashdb.v1.FeList:\0028\001\";\n\022SetProg"
  "ramResponse\022%\n\006result\030\001 \001(\0132\025.hashdb.v1."
  "ResultCode\"I\n\022GetProgramResponse\022\014\n\004data"
  "\030\001 \001(\014\022%\n\006result\030\002 \001(\0132\025.hashdb.v1.Resul"
  "tCode\"a\n\rFlushResponse\022\020\n\010flush_id\030\001 \001(\004"
  "\022\027\n\017stored_flush_id\030\002 \001(\004\022%\n\006result\030\003 \001("
  "\0132\025.hashdb.v1.ResultCode\"\347\001\n\026GetFlushSta"
  "tusResponse\022\027\n\017stored_flush_id\030\001 \001(\004\022\030\n\020"
  "storing_flush_id\030\002 \001(\004\022\025\n\rlast_flush_id\030"
  "\003 \001(\004\022\036\n\026pending_to_flush_nodes\030\004 \001(\004\022 \n"
  "\030pending_to_flush_program\030\005 \001(\004\022\025\n\rstori"
  "ng_nodes\030\006 \001(\004\022\027\n\017storing_program\030\007 \001(\004\022"
  "\021\n\tprover_id\030\010 \001(\t\"\310\002\n\024GetFlushDataRespo"
  "nse\022\027\n\017stored_flush_id\030\001 \001(\004\0229\n\005nodes\030\002 "
  "\003(\0132*.hashdb.v1.GetFlushDataResponse.Nod"
  "esEntry\022=\n\007program\030\003 \003(\0132,.hashdb.v1.Get"
  "FlushDataResponse.ProgramEntry\022\030\n\020nodes_"
  "state_root\030\004 \001(\t\022%\n\006result\030\005 \001(\0132\025.hashd"
  "b.v1.ResultCode\032,\n\nNodesEntry\022\013\n\003key\030\001 \001"
  "(\t\022\r\n\005value\030\002 \001(\t:\0028\001\032.\n\014ProgramEntry\022\013\n"
  "\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\235\001\n\030Consol"
  "idateStateResponse\022/\n\027consolidated_state"
  "_root\030\001 \001(\0132\016.hashdb.v1.Fea\022\020\n\010flush_id\030"
  "\002 \001(\004\022\027\n\017stored_flush_id\030\003 \001(\004\022%\n\006result"
  "\030\004 \001(\0132\025.hashdb.v1.ResultCode\"6\n\rPurgeRe"
  "sponse\022%\n\006result\030\001 \001(\0132\025.hashdb.v1.Resul"
  "tCode\"\215\001\n\020ReadTreeResponse\022&\n\tkey_value\030"
  "\001 \003(\0132\023.hashdb.v1.KeyValue\022*\n\nhash_value"
  "\030\002 \003(\0132\026.hashdb.v1.HashValueGL\022%\n\006result"
  "\030\003 \001(\0132\025.hashdb.v1.ResultCode\"<\n\023CancelB"
  "atchResponse\022%\n\006result\030\001 \001(\0132\025.hashdb.v1"
  ".ResultCode\"8\n\017ResetDBResponse\022%\n\006result"
  "\030\001 \001(\0132\025.hashdb.v1.ResultCode\"9\n\003Fea\022\013\n\003"
  "fe0\030\001 \001(\004\022\013\n\003fe1\030\002 \001(\004\022\013\n\003fe2\030\003 \001(\004\022\013\n\003f"
  "e3\030\004 \001(\004\"\245\001\n\005Fea12\022\013\n\003fe0\030\001 \001(\004\022\013\n\003fe1\030\002"
  " \001(\004\022\013\n\003fe2\030\003 \001(\004\022\013\n\003fe3\030\004 \001(\004\022\013\n\003fe4\030\005 "
  "\001(\004\022\013\n\003fe5\030\006 \001(\004\022\013\n\003fe6\030\007 \001(\004\022\013\n\003fe7\030\010 \001"
  "(\004\022\013\n\003fe8\030\t \001(\004\022\013\n\003fe9\030\n \001(\004\022\014\n\004fe10\030\013 \001"
  "(\004\022\014\n\004fe11\030\014 \001(\004\"L\n\013HashValueGL\022\034\n\004hash\030"
  "\001 \001(\0132\016.hashdb.v1.Fea\022\037\n\005value\030\002 \001(\0132\020.h"
  "ashdb.v1.Fea12\"6\n\010KeyValue\022\033\n\003key\030\001 \001(\0132"
  "\016.hashdb.v1.Fea\022\r\n\005value\030\002 \001(\t\"\024\n\006FeList"
  "\022\n\n\002fe\030\001 \003(\004\"\036\n\013SiblingList\022\017\n\007sibling\030\001"
  " \003(\004\"\316\001\n\nResultCode\022(\n\004code\030\001 \001(\0162\032.hash"
  "db.v1.ResultCode.Code\"\225\001\n\004Code\022\024\n\020CODE_U"
  "NSPECIFIED\020\000\022\020\n\014CODE_SUCCESS\020\001\022\031\n\025CODE_D"
  "B_KEY_NOT_FOUND\020\002\022\021\n\rCODE_DB_ERROR\020\003\022\027\n\023"
  "CODE_INTERNAL_ERROR\020\004\022\036\n\032CODE_SMT_INVALI"
  "D_DATA_SIZE\020\016*e\n\013Persistence\022!\n\035PERSISTE"
  "NCE_CACHE_UNSPECIFIED\020\000\022\030\n\024PERSISTENCE_D"
  "ATABASE\020\001\022\031\n\025PERSISTENCE_TEMPORARY\020\0022\237\n\n"
  "\rHashDBService\022U\n\022GetLatestStateRoot\022\026.g"
  "oogle.protobuf.Empty\032%.hashdb.v1.GetLate"
  "stStateRootResponse\"\000\0226\n\003Set\022\025.hashdb.v1"
  ".SetRequest\032\026.hashdb.v1.SetResponse\"\000\0226\n"
  "\003Get\022\025.hashdb.v1.GetRequest\032\026.hashdb.v1."
  "GetResponse\"\000\022K\n\nSetProgram\022\034.hashdb.v1."
  "SetProgramRequest\032\035.hashdb.v1.SetProgram"
  "Response\"\000\022K\n\nGetProgram\022\034.hashdb.v1.Get"
  "ProgramRequest\032\035.hashdb.v1.GetProgramRes"
  "ponse\"\000\022<\n\006LoadDB\022\030.hashdb.v1.LoadDBRequ"
  "est\032\026.google.protobuf.Empty\"\000\022J\n\rLoadPro"
  "gramDB\022\037.hashdb.v1.LoadProgramDBRequest\032"
  "\026.google.protobuf.Empty\"\000\022@\n\010FinishTx\022\032."
  "hashdb.v1.FinishTxRequest\032\026.google.proto"
  "buf.Empty\"\000\022D\n\nStartBlock\022\034.hashdb.v1.St"
  "artBlockRequest\032\026.google.protobuf.Empty\""
  "\000\022F\n\013FinishBlock\022\035.hashdb.v1.FinishBlock"
  "Request\032\026.google.protobuf.Empty\"\000\022<\n\005Flu"
  "sh\022\027.hashdb.v1.FlushRequest\032\030.hashdb.v1."
  "FlushResponse\"\000\022M\n\016GetFlushStatus\022\026.goog"
  "le.protobuf.Empty\032!.hashdb.v1.GetFlushSt"
  "atusResponse\"\000\022Q\n\014GetFlushData\022\036.hashdb."
  "v1.GetFlushDataRequest\032\037.hashdb.v1.GetFl"
  "ushDataResponse\"\000\022]\n\020ConsolidateState\022\"."
  "hashdb.v1.ConsolidateStateRequest\032#.hash"
  "db.v1.ConsolidateStateResponse\"\000\022<\n\005Purg"
  "e\022\027.hashdb.v1.PurgeRequest\032\030.hashdb.v1.P"
  "urgeResponse\"\000\022E\n\010ReadTree\022\032.hashdb.v1.R"
  "eadTreeRequest\032\033.hashdb.v1.ReadTreeRespo"
  "nse\"\000\022N\n\013CancelBatch\022\035.hashdb.v1.CancelB"
  "atchRequest\032\036.hashdb.v1.CancelBatchRespo"
  "nse\"\000\022\?\n\007ResetDB\022\026.google.protobuf.Empty"
  "\032\032.hashdb.v1.ResetDBResponse\"\000B9Z7github"
  ".com/0xPolygonHermez/zkevm-node/merkletr"
  "ee/hashdbb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_hashdb_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
};
static ::_pbi::once_flag descriptor_table_hashdb_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_hashdb_2eproto = {
    false, false, 6537, descriptor_table_protodef_hashdb_2eproto,
    "hashdb.proto",
    &descriptor_table_hashdb_2eproto_once, descriptor_table_hashdb_2eproto_deps, 1, 44,
    schemas, file_default_instances, TableStruct_hashdb_2eproto::offsets,
    file_level_metadata_hashdb_2eproto, file_level_enum_descriptors_hashdb_2eproto,
    file_level_service_descriptors_hashdb_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_hashdb_2eproto_getter() {
  return &descriptor_table_hashdb_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_hashdb_2eproto(&descriptor_table_hashdb_2eproto);
namespace hashdb {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultCode_Code_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_hashdb_2eproto);
  return file_level_enum_descriptors_hashdb_2eproto[0];
}
bool ResultCode_Code_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 14:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ResultCode_Code ResultCode::CODE_UNSPECIFIED;
constexpr ResultCode_Code ResultCode::CODE_SUCCESS;
constexpr ResultCode_Code ResultCode::CODE_DB_KEY_NOT_FOUND;
constexpr ResultCode_Code ResultCode::CODE_DB_ERROR;
constexpr ResultCode_Code ResultCode::CODE_INTERNAL_ERROR;
constexpr ResultCode_Code ResultCode::CODE_SMT_INVALID_DATA_SIZE;
constexpr ResultCode_Code ResultCode::Code_MIN;
constexpr ResultCode_Code ResultCode::Code_MAX;
constexpr int ResultCode::Code_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Persistence_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_hashdb_2eproto);
  return file_level_enum_descriptors_hashdb_2eproto[1];
}
bool Persistence_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Version::_Internal {
 public:
};

Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Version* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v0_0_1_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.v0_0_1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.v0_0_1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_v0_0_1().empty()) {
    _this->_impl_.v0_0_1_.Set(from._internal_v0_0_1(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.Version)
}

inline void Version::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v0_0_1_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.v0_0_1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.v0_0_1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:hashdb.v1.Version)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.v0_0_1_.Destroy();
}

void Version::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.v0_0_1_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string v0_0_1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_v0_0_1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.Version.v0_0_1"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string v0_0_1 = 1;
  if (!this->_internal_v0_0_1().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_v0_0_1().data(), static_cast<int>(this->_internal_v0_0_1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.Version.v0_0_1");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_v0_0_1(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.Version)
  return target;
}

size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.Version)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string v0_0_1 = 1;
  if (!this->_internal_v0_0_1().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_v0_0_1());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Version::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Version::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Version::GetClassData() const { return &_class_data_; }


void Version::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Version*>(&to_msg);
  auto& from = static_cast<const Version&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.Version)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_v0_0_1().empty()) {
    _this->_internal_set_v0_0_1(from._internal_v0_0_1());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.v0_0_1_, lhs_arena,
      &other->_impl_.v0_0_1_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Version::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[0]);
}

// ===================================================================

class SetRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& old_root(const SetRequest* msg);
  static const ::hashdb::v1::Fea& key(const SetRequest* msg);
};

const ::hashdb::v1::Fea&
SetRequest::_Internal::old_root(const SetRequest* msg) {
  return *msg->_impl_.old_root_;
}
const ::hashdb::v1::Fea&
SetRequest::_Internal::key(const SetRequest* msg) {
  return *msg->_impl_.key_;
}
SetRequest::SetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.SetRequest)
}
SetRequest::SetRequest(const SetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.old_root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.persistence_){}
    , decltype(_impl_.details_){}
    , decltype(_impl_.get_db_read_log_){}
    , decltype(_impl_.tx_index_){}
    , decltype(_impl_.block_index_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_old_root()) {
    _this->_impl_.old_root_ = new ::hashdb::v1::Fea(*from._impl_.old_root_);
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hashdb::v1::Fea(*from._impl_.key_);
  }
  ::memcpy(&_impl_.persistence_, &from._impl_.persistence_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.block_index_) -
    reinterpret_cast<char*>(&_impl_.persistence_)) + sizeof(_impl_.block_index_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.SetRequest)
}

inline void SetRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.old_root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.persistence_){0}
    , decltype(_impl_.details_){false}
    , decltype(_impl_.get_db_read_log_){false}
    , decltype(_impl_.tx_index_){uint64_t{0u}}
    , decltype(_impl_.block_index_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetRequest::~SetRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.SetRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
  _impl_.batch_uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.old_root_;
  if (this != internal_default_instance()) delete _impl_.key_;
}

void SetRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.SetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _impl_.batch_uuid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.old_root_ != nullptr) {
    delete _impl_.old_root_;
  }
  _impl_.old_root_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  ::memset(&_impl_.persistence_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.block_index_) -
      reinterpret_cast<char*>(&_impl_.persistence_)) + sizeof(_impl_.block_index_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea old_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.SetRequest.value"));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      // bool details = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.details_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool get_db_read_log = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.get_db_read_log_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string batch_uuid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.SetRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.tx_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 block_index = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.block_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.SetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea old_root = 1;
  if (this->_internal_has_old_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::old_root(this),
        _Internal::old_root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea key = 2;
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // string value = 3;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.SetRequest.value");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_value(), target);
  }

  // .hashdb.v1.Persistence persistence = 4;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_persistence(), target);
  }

  // bool details = 5;
  if (this->_internal_details() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_details(), target);
  }

  // bool get_db_read_log = 6;
  if (this->_internal_get_db_read_log() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_get_db_read_log(), target);
  }

  // string batch_uuid = 7;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.SetRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_batch_uuid(), target);
  }

  // uint64 tx_index = 8;
  if (this->_internal_tx_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_tx_index(), target);
  }

  // uint64 block_index = 9;
  if (this->_internal_block_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_block_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.SetRequest)
  return target;
}

size_t SetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.SetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string value = 3;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // string batch_uuid = 7;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // .hashdb.v1.Fea old_root = 1;
  if (this->_internal_has_old_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_root_);
  }

  // .hashdb.v1.Fea key = 2;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  // .hashdb.v1.Persistence persistence = 4;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  // bool details = 5;
  if (this->_internal_details() != 0) {
    total_size += 1 + 1;
  }

  // bool get_db_read_log = 6;
  if (this->_internal_get_db_read_log() != 0) {
    total_size += 1 + 1;
  }

  // uint64 tx_index = 8;
  if (this->_internal_tx_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_index());
  }

  // uint64 block_index = 9;
  if (this->_internal_block_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetRequest::GetClassData() const { return &_class_data_; }


void SetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetRequest*>(&to_msg);
  auto& from = static_cast<const SetRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.SetRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (from._internal_has_old_root()) {
    _this->_internal_mutable_old_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_old_root());
  }
  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_key());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  if (from._internal_details() != 0) {
    _this->_internal_set_details(from._internal_details());
  }
  if (from._internal_get_db_read_log() != 0) {
    _this->_internal_set_get_db_read_log(from._internal_get_db_read_log());
  }
  if (from._internal_tx_index() != 0) {
    _this->_internal_set_tx_index(from._internal_tx_index());
  }
  if (from._internal_block_index() != 0) {
    _this->_internal_set_block_index(from._internal_block_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetRequest::CopyFrom(const SetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.SetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetRequest::IsInitialized() const {
  return true;
}

void SetRequest::InternalSwap(SetRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetRequest, _impl_.block_index_)
      + sizeof(SetRequest::_impl_.block_index_)
      - PROTOBUF_FIELD_OFFSET(SetRequest, _impl_.old_root_)>(
          reinterpret_cast<char*>(&_impl_.old_root_),
          reinterpret_cast<char*>(&other->_impl_.old_root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[1]);
}

// ===================================================================

class GetRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& root(const GetRequest* msg);
  static const ::hashdb::v1::Fea& key(const GetRequest* msg);
};

const ::hashdb::v1::Fea&
GetRequest::_Internal::root(const GetRequest* msg) {
  return *msg->_impl_.root_;
}
const ::hashdb::v1::Fea&
GetRequest::_Internal::key(const GetRequest* msg) {
  return *msg->_impl_.key_;
}
GetRequest::GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetRequest)
}
GetRequest::GetRequest(const GetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.details_){}
    , decltype(_impl_.get_db_read_log_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_root()) {
    _this->_impl_.root_ = new ::hashdb::v1::Fea(*from._impl_.root_);
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hashdb::v1::Fea(*from._impl_.key_);
  }
  ::memcpy(&_impl_.details_, &from._impl_.details_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.get_db_read_log_) -
    reinterpret_cast<char*>(&_impl_.details_)) + sizeof(_impl_.get_db_read_log_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetRequest)
}

inline void GetRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.details_){false}
    , decltype(_impl_.get_db_read_log_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetRequest::~GetRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.root_;
  if (this != internal_default_instance()) delete _impl_.key_;
}

void GetRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.root_ != nullptr) {
    delete _impl_.root_;
  }
  _impl_.root_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  ::memset(&_impl_.details_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.get_db_read_log_) -
      reinterpret_cast<char*>(&_impl_.details_)) + sizeof(_impl_.get_db_read_log_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool details = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.details_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool get_db_read_log = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.get_db_read_log_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string batch_uuid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.GetRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea root = 1;
  if (this->_internal_has_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::root(this),
        _Internal::root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea key = 2;
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // bool details = 3;
  if (this->_internal_details() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_details(), target);
  }

  // bool get_db_read_log = 4;
  if (this->_internal_get_db_read_log() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_get_db_read_log(), target);
  }

  // string batch_uuid = 5;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.GetRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_batch_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetRequest)
  return target;
}

size_t GetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 5;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // .hashdb.v1.Fea root = 1;
  if (this->_internal_has_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.root_);
  }

  // .hashdb.v1.Fea key = 2;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  // bool details = 3;
  if (this->_internal_details() != 0) {
    total_size += 1 + 1;
  }

  // bool get_db_read_log = 4;
  if (this->_internal_get_db_read_log() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetRequest::GetClassData() const { return &_class_data_; }


void GetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetRequest*>(&to_msg);
  auto& from = static_cast<const GetRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (from._internal_has_root()) {
    _this->_internal_mutable_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_root());
  }
  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_key());
  }
  if (from._internal_details() != 0) {
    _this->_internal_set_details(from._internal_details());
  }
  if (from._internal_get_db_read_log() != 0) {
    _this->_internal_set_get_db_read_log(from._internal_get_db_read_log());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetRequest::CopyFrom(const GetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetRequest::IsInitialized() const {
  return true;
}

void GetRequest::InternalSwap(GetRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetRequest, _impl_.get_db_read_log_)
      + sizeof(GetRequest::_impl_.get_db_read_log_)
      - PROTOBUF_FIELD_OFFSET(GetRequest, _impl_.root_)>(
          reinterpret_cast<char*>(&_impl_.root_),
          reinterpret_cast<char*>(&other->_impl_.root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[2]);
}

// ===================================================================

class SetProgramRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& key(const SetProgramRequest* msg);
};

const ::hashdb::v1::Fea&
SetProgramRequest::_Internal::key(const SetProgramRequest* msg) {
  return *msg->_impl_.key_;
}
SetProgramRequest::SetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.SetProgramRequest)
}
SetProgramRequest::SetProgramRequest(const SetProgramRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetProgramRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.tx_index_){}
    , decltype(_impl_.block_index_){}
    , decltype(_impl_.persistence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hashdb::v1::Fea(*from._impl_.key_);
  }
  ::memcpy(&_impl_.tx_index_, &from._impl_.tx_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.persistence_) -
    reinterpret_cast<char*>(&_impl_.tx_index_)) + sizeof(_impl_.persistence_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.SetProgramRequest)
}

inline void SetProgramRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.tx_index_){uint64_t{0u}}
    , decltype(_impl_.block_index_){uint64_t{0u}}
    , decltype(_impl_.persistence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetProgramRequest::~SetProgramRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.SetProgramRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetProgramRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
  _impl_.batch_uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.key_;
}

void SetProgramRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetProgramRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.SetProgramRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  _impl_.batch_uuid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  ::memset(&_impl_.tx_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.persistence_) -
      reinterpret_cast<char*>(&_impl_.tx_index_)) + sizeof(_impl_.persistence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetProgramRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      // string batch_uuid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.SetProgramRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      // uint64 tx_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.tx_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 block_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.block_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetProgramRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.SetProgramRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea key = 1;
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_persistence(), target);
  }

  // string batch_uuid = 4;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.SetProgramRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_batch_uuid(), target);
  }

  // uint64 tx_index = 5;
  if (this->_internal_tx_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_tx_index(), target);
  }

  // uint64 block_index = 6;
  if (this->_internal_block_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_block_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.SetProgramRequest)
  return target;
}

size_t SetProgramRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.SetProgramRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string batch_uuid = 4;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // .hashdb.v1.Fea key = 1;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  // uint64 tx_index = 5;
  if (this->_internal_tx_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tx_index());
  }

  // uint64 block_index = 6;
  if (this->_internal_block_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block_index());
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetProgramRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetProgramRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetProgramRequest::GetClassData() const { return &_class_data_; }


void SetProgramRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetProgramRequest*>(&to_msg);
  auto& from = static_cast<const SetProgramRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.SetProgramRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_key());
  }
  if (from._internal_tx_index() != 0) {
    _this->_internal_set_tx_index(from._internal_tx_index());
  }
  if (from._internal_block_index() != 0) {
    _this->_internal_set_block_index(from._internal_block_index());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetProgramRequest::CopyFrom(const SetProgramRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.SetProgramRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetProgramRequest::IsInitialized() const {
  return true;
}

void SetProgramRequest::InternalSwap(SetProgramRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetProgramRequest, _impl_.persistence_)
      + sizeof(SetProgramRequest::_impl_.persistence_)
      - PROTOBUF_FIELD_OFFSET(SetProgramRequest, _impl_.key_)>(
          reinterpret_cast<char*>(&_impl_.key_),
          reinterpret_cast<char*>(&other->_impl_.key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetProgramRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[3]);
}

// ===================================================================

class GetProgramRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& key(const GetProgramRequest* msg);
};

const ::hashdb::v1::Fea&
GetProgramRequest::_Internal::key(const GetProgramRequest* msg) {
  return *msg->_impl_.key_;
}
GetProgramRequest::GetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetProgramRequest)
}
GetProgramRequest::GetProgramRequest(const GetProgramRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetProgramRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.key_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hashdb::v1::Fea(*from._impl_.key_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetProgramRequest)
}

inline void GetProgramRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.key_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetProgramRequest::~GetProgramRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetProgramRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetProgramRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.key_;
}

void GetProgramRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetProgramRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetProgramRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetProgramRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string batch_uuid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.GetProgramRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetProgramRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetProgramRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea key = 1;
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // string batch_uuid = 2;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.GetProgramRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_batch_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetProgramRequest)
  return target;
}

size_t GetProgramRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetProgramRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 2;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // .hashdb.v1.Fea key = 1;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetProgramRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetProgramRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetProgramRequest::GetClassData() const { return &_class_data_; }


void GetProgramRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetProgramRequest*>(&to_msg);
  auto& from = static_cast<const GetProgramRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetProgramRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetProgramRequest::CopyFrom(const GetProgramRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetProgramRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetProgramRequest::IsInitialized() const {
  return true;
}

void GetProgramRequest::InternalSwap(GetProgramRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  swap(_impl_.key_, other->_impl_.key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetProgramRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[4]);
}

// ===================================================================

LoadDBRequest_InputDbEntry_DoNotUse::LoadDBRequest_InputDbEntry_DoNotUse() {}
LoadDBRequest_InputDbEntry_DoNotUse::LoadDBRequest_InputDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LoadDBRequest_InputDbEntry_DoNotUse::MergeFrom(const LoadDBRequest_InputDbEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LoadDBRequest_InputDbEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[5]);
}

// ===================================================================

class LoadDBRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& state_root(const LoadDBRequest* msg);
};

const ::hashdb::v1::Fea&
LoadDBRequest::_Internal::state_root(const LoadDBRequest* msg) {
  return *msg->_impl_.state_root_;
}
LoadDBRequest::LoadDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &LoadDBRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.LoadDBRequest)
}
LoadDBRequest::LoadDBRequest(const LoadDBRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadDBRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_db_)*/{}
    , decltype(_impl_.state_root_){nullptr}
    , decltype(_impl_.persistent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.input_db_.MergeFrom(from._impl_.input_db_);
  if (from._internal_has_state_root()) {
    _this->_impl_.state_root_ = new ::hashdb::v1::Fea(*from._impl_.state_root_);
  }
  _this->_impl_.persistent_ = from._impl_.persistent_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.LoadDBRequest)
}

inline void LoadDBRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_db_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.state_root_){nullptr}
    , decltype(_impl_.persistent_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoadDBRequest::~LoadDBRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.LoadDBRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void LoadDBRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_db_.Destruct();
  _impl_.input_db_.~MapField();
  if (this != internal_default_instance()) delete _impl_.state_root_;
}

void LoadDBRequest::ArenaDtor(void* object) {
  LoadDBRequest* _this = reinterpret_cast< LoadDBRequest* >(object);
  _this->_impl_.input_db_.Destruct();
}
void LoadDBRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadDBRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.LoadDBRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_db_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.state_root_ != nullptr) {
    delete _impl_.state_root_;
  }
  _impl_.state_root_ = nullptr;
  _impl_.persistent_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadDBRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .hashdb.v1.FeList> input_db = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.input_db_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool persistent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.persistent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea state_root = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_state_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadDBRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.LoadDBRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .hashdb.v1.FeList> input_db = 1;
  if (!this->_internal_input_db().empty()) {
    using MapType = ::_pb::Map<std::string, ::hashdb::v1::FeList>;
    using WireHelper = LoadDBRequest_InputDbEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_input_db();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.LoadDBRequest.InputDbEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // bool persistent = 2;
  if (this->_internal_persistent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_persistent(), target);
  }

  // .hashdb.v1.Fea state_root = 3;
  if (this->_internal_has_state_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::state_root(this),
        _Internal::state_root(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.LoadDBRequest)
  return target;
}

size_t LoadDBRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.LoadDBRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .hashdb.v1.FeList> input_db = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_db_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >::const_iterator
      it = this->_internal_input_db().begin();
      it != this->_internal_input_db().end(); ++it) {
    total_size += LoadDBRequest_InputDbEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .hashdb.v1.Fea state_root = 3;
  if (this->_internal_has_state_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.state_root_);
  }

  // bool persistent = 2;
  if (this->_internal_persistent() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadDBRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadDBRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadDBRequest::GetClassData() const { return &_class_data_; }


void LoadDBRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadDBRequest*>(&to_msg);
  auto& from = static_cast<const LoadDBRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.LoadDBRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_db_.MergeFrom(from._impl_.input_db_);
  if (from._internal_has_state_root()) {
    _this->_internal_mutable_state_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_state_root());
  }
  if (from._internal_persistent() != 0) {
    _this->_internal_set_persistent(from._internal_persistent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadDBRequest::CopyFrom(const LoadDBRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.LoadDBRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadDBRequest::IsInitialized() const {
  return true;
}

void LoadDBRequest::InternalSwap(LoadDBRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.input_db_.InternalSwap(&other->_impl_.input_db_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoadDBRequest, _impl_.persistent_)
      + sizeof(LoadDBRequest::_impl_.persistent_)
      - PROTOBUF_FIELD_OFFSET(LoadDBRequest, _impl_.state_root_)>(
          reinterpret_cast<char*>(&_impl_.state_root_),
          reinterpret_cast<char*>(&other->_impl_.state_root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadDBRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[6]);
}

// ===================================================================

LoadProgramDBRequest_InputProgramDbEntry_DoNotUse::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse() {}
LoadProgramDBRequest_InputProgramDbEntry_DoNotUse::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void LoadProgramDBRequest_InputProgramDbEntry_DoNotUse::MergeFrom(const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata LoadProgramDBRequest_InputProgramDbEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[7]);
}

// ===================================================================

class LoadProgramDBRequest::_Internal {
 public:
};

LoadProgramDBRequest::LoadProgramDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &LoadProgramDBRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.LoadProgramDBRequest)
}
LoadProgramDBRequest::LoadProgramDBRequest(const LoadProgramDBRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadProgramDBRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_program_db_)*/{}
    , decltype(_impl_.persistent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.input_program_db_.MergeFrom(from._impl_.input_program_db_);
  _this->_impl_.persistent_ = from._impl_.persistent_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.LoadProgramDBRequest)
}

inline void LoadProgramDBRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.input_program_db_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.persistent_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoadProgramDBRequest::~LoadProgramDBRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.LoadProgramDBRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void LoadProgramDBRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_program_db_.Destruct();
  _impl_.input_program_db_.~MapField();
}

void LoadProgramDBRequest::ArenaDtor(void* object) {
  LoadProgramDBRequest* _this = reinterpret_cast< LoadProgramDBRequest* >(object);
  _this->_impl_.input_program_db_.Destruct();
}
void LoadProgramDBRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadProgramDBRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.LoadProgramDBRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_program_db_.Clear();
  _impl_.persistent_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadProgramDBRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, bytes> input_program_db = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.input_program_db_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool persistent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.persistent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadProgramDBRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.LoadProgramDBRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, bytes> input_program_db = 1;
  if (!this->_internal_input_program_db().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = LoadProgramDBRequest_InputProgramDbEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_input_program_db();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.LoadProgramDBRequest.InputProgramDbEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // bool persistent = 2;
  if (this->_internal_persistent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_persistent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.LoadProgramDBRequest)
  return target;
}

size_t LoadProgramDBRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.LoadProgramDBRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> input_program_db = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_input_program_db_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_input_program_db().begin();
      it != this->_internal_input_program_db().end(); ++it) {
    total_size += LoadProgramDBRequest_InputProgramDbEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // bool persistent = 2;
  if (this->_internal_persistent() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadProgramDBRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadProgramDBRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadProgramDBRequest::GetClassData() const { return &_class_data_; }


void LoadProgramDBRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadProgramDBRequest*>(&to_msg);
  auto& from = static_cast<const LoadProgramDBRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.LoadProgramDBRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_program_db_.MergeFrom(from._impl_.input_program_db_);
  if (from._internal_persistent() != 0) {
    _this->_internal_set_persistent(from._internal_persistent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadProgramDBRequest::CopyFrom(const LoadProgramDBRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.LoadProgramDBRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadProgramDBRequest::IsInitialized() const {
  return true;
}

void LoadProgramDBRequest::InternalSwap(LoadProgramDBRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.input_program_db_.InternalSwap(&other->_impl_.input_program_db_);
  swap(_impl_.persistent_, other->_impl_.persistent_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadProgramDBRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[8]);
}

// ===================================================================

class FlushRequest::_Internal {
 public:
};

FlushRequest::FlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.FlushRequest)
}
FlushRequest::FlushRequest(const FlushRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlushRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){}
    , decltype(_impl_.persistence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_new_state_root().empty()) {
    _this->_impl_.new_state_root_.Set(from._internal_new_state_root(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.persistence_ = from._impl_.persistence_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.FlushRequest)
}

inline void FlushRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){}
    , decltype(_impl_.persistence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlushRequest::~FlushRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.FlushRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
  _impl_.new_state_root_.Destroy();
}

void FlushRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlushRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.FlushRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  _impl_.new_state_root_.ClearToEmpty();
  _impl_.persistence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlushRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string batch_uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.FlushRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      // string new_state_root = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_state_root();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.FlushRequest.new_state_root"));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.FlushRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.FlushRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_batch_uuid(), target);
  }

  // string new_state_root = 2;
  if (!this->_internal_new_state_root().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_new_state_root().data(), static_cast<int>(this->_internal_new_state_root().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.FlushRequest.new_state_root");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_state_root(), target);
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.FlushRequest)
  return target;
}

size_t FlushRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.FlushRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // string new_state_root = 2;
  if (!this->_internal_new_state_root().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_new_state_root());
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlushRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlushRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlushRequest::GetClassData() const { return &_class_data_; }


void FlushRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlushRequest*>(&to_msg);
  auto& from = static_cast<const FlushRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.FlushRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (!from._internal_new_state_root().empty()) {
    _this->_internal_set_new_state_root(from._internal_new_state_root());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlushRequest::CopyFrom(const FlushRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.FlushRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushRequest::IsInitialized() const {
  return true;
}

void FlushRequest::InternalSwap(FlushRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_state_root_, lhs_arena,
      &other->_impl_.new_state_root_, rhs_arena
  );
  swap(_impl_.persistence_, other->_impl_.persistence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlushRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[9]);
}

// ===================================================================

class FinishTxRequest::_Internal {
 public:
};

FinishTxRequest::FinishTxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.FinishTxRequest)
}
FinishTxRequest::FinishTxRequest(const FinishTxRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FinishTxRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){}
    , decltype(_impl_.persistence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_new_state_root().empty()) {
    _this->_impl_.new_state_root_.Set(from._internal_new_state_root(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.persistence_ = from._impl_.persistence_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.FinishTxRequest)
}

inline void FinishTxRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){}
    , decltype(_impl_.persistence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FinishTxRequest::~FinishTxRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.FinishTxRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FinishTxRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
  _impl_.new_state_root_.Destroy();
}

void FinishTxRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FinishTxRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.FinishTxRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  _impl_.new_state_root_.ClearToEmpty();
  _impl_.persistence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FinishTxRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string batch_uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.FinishTxRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      // string new_state_root = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_state_root();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.FinishTxRequest.new_state_root"));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FinishTxRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.FinishTxRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.FinishTxRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_batch_uuid(), target);
  }

  // string new_state_root = 2;
  if (!this->_internal_new_state_root().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_new_state_root().data(), static_cast<int>(this->_internal_new_state_root().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.FinishTxRequest.new_state_root");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_state_root(), target);
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.FinishTxRequest)
  return target;
}

size_t FinishTxRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.FinishTxRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // string new_state_root = 2;
  if (!this->_internal_new_state_root().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_new_state_root());
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FinishTxRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FinishTxRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FinishTxRequest::GetClassData() const { return &_class_data_; }


void FinishTxRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FinishTxRequest*>(&to_msg);
  auto& from = static_cast<const FinishTxRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.FinishTxRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (!from._internal_new_state_root().empty()) {
    _this->_internal_set_new_state_root(from._internal_new_state_root());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FinishTxRequest::CopyFrom(const FinishTxRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.FinishTxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinishTxRequest::IsInitialized() const {
  return true;
}

void FinishTxRequest::InternalSwap(FinishTxRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_state_root_, lhs_arena,
      &other->_impl_.new_state_root_, rhs_arena
  );
  swap(_impl_.persistence_, other->_impl_.persistence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FinishTxRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[10]);
}

// ===================================================================

class StartBlockRequest::_Internal {
 public:
};

StartBlockRequest::StartBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.StartBlockRequest)
}
StartBlockRequest::StartBlockRequest(const StartBlockRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StartBlockRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.old_state_root_){}
    , decltype(_impl_.persistence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.old_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_old_state_root().empty()) {
    _this->_impl_.old_state_root_.Set(from._internal_old_state_root(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.persistence_ = from._impl_.persistence_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.StartBlockRequest)
}

inline void StartBlockRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.old_state_root_){}
    , decltype(_impl_.persistence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.old_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StartBlockRequest::~StartBlockRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.StartBlockRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StartBlockRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
  _impl_.old_state_root_.Destroy();
}

void StartBlockRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StartBlockRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.StartBlockRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  _impl_.old_state_root_.ClearToEmpty();
  _impl_.persistence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StartBlockRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string batch_uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.StartBlockRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      // string old_state_root = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_old_state_root();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.StartBlockRequest.old_state_root"));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartBlockRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.StartBlockRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.StartBlockRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_batch_uuid(), target);
  }

  // string old_state_root = 2;
  if (!this->_internal_old_state_root().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_old_state_root().data(), static_cast<int>(this->_internal_old_state_root().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.StartBlockRequest.old_state_root");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_old_state_root(), target);
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.StartBlockRequest)
  return target;
}

size_t StartBlockRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.StartBlockRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // string old_state_root = 2;
  if (!this->_internal_old_state_root().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_old_state_root());
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StartBlockRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StartBlockRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StartBlockRequest::GetClassData() const { return &_class_data_; }


void StartBlockRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StartBlockRequest*>(&to_msg);
  auto& from = static_cast<const StartBlockRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.StartBlockRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (!from._internal_old_state_root().empty()) {
    _this->_internal_set_old_state_root(from._internal_old_state_root());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StartBlockRequest::CopyFrom(const StartBlockRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.StartBlockRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartBlockRequest::IsInitialized() const {
  return true;
}

void StartBlockRequest::InternalSwap(StartBlockRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.old_state_root_, lhs_arena,
      &other->_impl_.old_state_root_, rhs_arena
  );
  swap(_impl_.persistence_, other->_impl_.persistence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StartBlockRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[11]);
}

// ===================================================================

class FinishBlockRequest::_Internal {
 public:
};

FinishBlockRequest::FinishBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.FinishBlockRequest)
}
FinishBlockRequest::FinishBlockRequest(const FinishBlockRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FinishBlockRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){}
    , decltype(_impl_.persistence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_new_state_root().empty()) {
    _this->_impl_.new_state_root_.Set(from._internal_new_state_root(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.persistence_ = from._impl_.persistence_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.FinishBlockRequest)
}

inline void FinishBlockRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){}
    , decltype(_impl_.persistence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FinishBlockRequest::~FinishBlockRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.FinishBlockRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FinishBlockRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
  _impl_.new_state_root_.Destroy();
}

void FinishBlockRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FinishBlockRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.FinishBlockRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  _impl_.new_state_root_.ClearToEmpty();
  _impl_.persistence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FinishBlockRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string batch_uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.FinishBlockRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      // string new_state_root = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_state_root();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.FinishBlockRequest.new_state_root"));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FinishBlockRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.FinishBlockRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.FinishBlockRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_batch_uuid(), target);
  }

  // string new_state_root = 2;
  if (!this->_internal_new_state_root().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_new_state_root().data(), static_cast<int>(this->_internal_new_state_root().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.FinishBlockRequest.new_state_root");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_state_root(), target);
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.FinishBlockRequest)
  return target;
}

size_t FinishBlockRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.FinishBlockRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // string new_state_root = 2;
  if (!this->_internal_new_state_root().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_new_state_root());
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FinishBlockRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FinishBlockRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FinishBlockRequest::GetClassData() const { return &_class_data_; }


void FinishBlockRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FinishBlockRequest*>(&to_msg);
  auto& from = static_cast<const FinishBlockRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.FinishBlockRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (!from._internal_new_state_root().empty()) {
    _this->_internal_set_new_state_root(from._internal_new_state_root());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FinishBlockRequest::CopyFrom(const FinishBlockRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.FinishBlockRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinishBlockRequest::IsInitialized() const {
  return true;
}

void FinishBlockRequest::InternalSwap(FinishBlockRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_state_root_, lhs_arena,
      &other->_impl_.new_state_root_, rhs_arena
  );
  swap(_impl_.persistence_, other->_impl_.persistence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FinishBlockRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[12]);
}

// ===================================================================

class GetFlushDataRequest::_Internal {
 public:
};

GetFlushDataRequest::GetFlushDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetFlushDataRequest)
}
GetFlushDataRequest::GetFlushDataRequest(const GetFlushDataRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetFlushDataRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flush_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flush_id_ = from._impl_.flush_id_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetFlushDataRequest)
}

inline void GetFlushDataRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flush_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetFlushDataRequest::~GetFlushDataRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetFlushDataRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetFlushDataRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetFlushDataRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetFlushDataRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetFlushDataRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flush_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFlushDataRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 flush_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFlushDataRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetFlushDataRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 flush_id = 1;
  if (this->_internal_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_flush_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetFlushDataRequest)
  return target;
}

size_t GetFlushDataRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetFlushDataRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 flush_id = 1;
  if (this->_internal_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flush_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFlushDataRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetFlushDataRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFlushDataRequest::GetClassData() const { return &_class_data_; }


void GetFlushDataRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetFlushDataRequest*>(&to_msg);
  auto& from = static_cast<const GetFlushDataRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetFlushDataRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_flush_id() != 0) {
    _this->_internal_set_flush_id(from._internal_flush_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFlushDataRequest::CopyFrom(const GetFlushDataRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetFlushDataRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFlushDataRequest::IsInitialized() const {
  return true;
}

void GetFlushDataRequest::InternalSwap(GetFlushDataRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flush_id_, other->_impl_.flush_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFlushDataRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[13]);
}

// ===================================================================

class ConsolidateStateRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& virtual_state_root(const ConsolidateStateRequest* msg);
};

const ::hashdb::v1::Fea&
ConsolidateStateRequest::_Internal::virtual_state_root(const ConsolidateStateRequest* msg) {
  return *msg->_impl_.virtual_state_root_;
}
ConsolidateStateRequest::ConsolidateStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.ConsolidateStateRequest)
}
ConsolidateStateRequest::ConsolidateStateRequest(const ConsolidateStateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConsolidateStateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.virtual_state_root_){nullptr}
    , decltype(_impl_.persistence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_virtual_state_root()) {
    _this->_impl_.virtual_state_root_ = new ::hashdb::v1::Fea(*from._impl_.virtual_state_root_);
  }
  _this->_impl_.persistence_ = from._impl_.persistence_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.ConsolidateStateRequest)
}

inline void ConsolidateStateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.virtual_state_root_){nullptr}
    , decltype(_impl_.persistence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConsolidateStateRequest::~ConsolidateStateRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.ConsolidateStateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConsolidateStateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.virtual_state_root_;
}

void ConsolidateStateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConsolidateStateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.ConsolidateStateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.virtual_state_root_ != nullptr) {
    delete _impl_.virtual_state_root_;
  }
  _impl_.virtual_state_root_ = nullptr;
  _impl_.persistence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConsolidateStateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea virtual_state_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_virtual_state_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConsolidateStateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.ConsolidateStateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea virtual_state_root = 1;
  if (this->_internal_has_virtual_state_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::virtual_state_root(this),
        _Internal::virtual_state_root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Persistence persistence = 2;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.ConsolidateStateRequest)
  return target;
}

size_t ConsolidateStateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.ConsolidateStateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.Fea virtual_state_root = 1;
  if (this->_internal_has_virtual_state_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.virtual_state_root_);
  }

  // .hashdb.v1.Persistence persistence = 2;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConsolidateStateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConsolidateStateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConsolidateStateRequest::GetClassData() const { return &_class_data_; }


void ConsolidateStateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConsolidateStateRequest*>(&to_msg);
  auto& from = static_cast<const ConsolidateStateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.ConsolidateStateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_virtual_state_root()) {
    _this->_internal_mutable_virtual_state_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_virtual_state_root());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConsolidateStateRequest::CopyFrom(const ConsolidateStateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.ConsolidateStateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConsolidateStateRequest::IsInitialized() const {
  return true;
}

void ConsolidateStateRequest::InternalSwap(ConsolidateStateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConsolidateStateRequest, _impl_.persistence_)
      + sizeof(ConsolidateStateRequest::_impl_.persistence_)
      - PROTOBUF_FIELD_OFFSET(ConsolidateStateRequest, _impl_.virtual_state_root_)>(
          reinterpret_cast<char*>(&_impl_.virtual_state_root_),
          reinterpret_cast<char*>(&other->_impl_.virtual_state_root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConsolidateStateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[14]);
}

// ===================================================================

class PurgeRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& new_state_root(const PurgeRequest* msg);
};

const ::hashdb::v1::Fea&
PurgeRequest::_Internal::new_state_root(const PurgeRequest* msg) {
  return *msg->_impl_.new_state_root_;
}
PurgeRequest::PurgeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.PurgeRequest)
}
PurgeRequest::PurgeRequest(const PurgeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PurgeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){nullptr}
    , decltype(_impl_.persistence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_new_state_root()) {
    _this->_impl_.new_state_root_ = new ::hashdb::v1::Fea(*from._impl_.new_state_root_);
  }
  _this->_impl_.persistence_ = from._impl_.persistence_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.PurgeRequest)
}

inline void PurgeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , decltype(_impl_.new_state_root_){nullptr}
    , decltype(_impl_.persistence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PurgeRequest::~PurgeRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.PurgeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PurgeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.new_state_root_;
}

void PurgeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PurgeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.PurgeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.new_state_root_ != nullptr) {
    delete _impl_.new_state_root_;
  }
  _impl_.new_state_root_ = nullptr;
  _impl_.persistence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PurgeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string batch_uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.PurgeRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea new_state_root = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_state_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Persistence persistence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_persistence(static_cast<::hashdb::v1::Persistence>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PurgeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.PurgeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.PurgeRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_batch_uuid(), target);
  }

  // .hashdb.v1.Fea new_state_root = 2;
  if (this->_internal_has_new_state_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::new_state_root(this),
        _Internal::new_state_root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.PurgeRequest)
  return target;
}

size_t PurgeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.PurgeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  // .hashdb.v1.Fea new_state_root = 2;
  if (this->_internal_has_new_state_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_state_root_);
  }

  // .hashdb.v1.Persistence persistence = 3;
  if (this->_internal_persistence() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_persistence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PurgeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PurgeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PurgeRequest::GetClassData() const { return &_class_data_; }


void PurgeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PurgeRequest*>(&to_msg);
  auto& from = static_cast<const PurgeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.PurgeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  if (from._internal_has_new_state_root()) {
    _this->_internal_mutable_new_state_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_new_state_root());
  }
  if (from._internal_persistence() != 0) {
    _this->_internal_set_persistence(from._internal_persistence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PurgeRequest::CopyFrom(const PurgeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.PurgeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurgeRequest::IsInitialized() const {
  return true;
}

void PurgeRequest::InternalSwap(PurgeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PurgeRequest, _impl_.persistence_)
      + sizeof(PurgeRequest::_impl_.persistence_)
      - PROTOBUF_FIELD_OFFSET(PurgeRequest, _impl_.new_state_root_)>(
          reinterpret_cast<char*>(&_impl_.new_state_root_),
          reinterpret_cast<char*>(&other->_impl_.new_state_root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PurgeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[15]);
}

// ===================================================================

class ReadTreeRequest::_Internal {
 public:
  static const ::hashdb::v1::Fea& state_root(const ReadTreeRequest* msg);
};

const ::hashdb::v1::Fea&
ReadTreeRequest::_Internal::state_root(const ReadTreeRequest* msg) {
  return *msg->_impl_.state_root_;
}
ReadTreeRequest::ReadTreeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.ReadTreeRequest)
}
ReadTreeRequest::ReadTreeRequest(const ReadTreeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadTreeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.state_root_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_state_root()) {
    _this->_impl_.state_root_ = new ::hashdb::v1::Fea(*from._impl_.state_root_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.ReadTreeRequest)
}

inline void ReadTreeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , decltype(_impl_.state_root_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadTreeRequest::~ReadTreeRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.ReadTreeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadTreeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.state_root_;
}

void ReadTreeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadTreeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.ReadTreeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.state_root_ != nullptr) {
    delete _impl_.state_root_;
  }
  _impl_.state_root_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadTreeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea state_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_state_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .hashdb.v1.Fea keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadTreeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.ReadTreeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea state_root = 1;
  if (this->_internal_has_state_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::state_root(this),
        _Internal::state_root(this).GetCachedSize(), target, stream);
  }

  // repeated .hashdb.v1.Fea keys = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.ReadTreeRequest)
  return target;
}

size_t ReadTreeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.ReadTreeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hashdb.v1.Fea keys = 2;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->_impl_.keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .hashdb.v1.Fea state_root = 1;
  if (this->_internal_has_state_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.state_root_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadTreeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadTreeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadTreeRequest::GetClassData() const { return &_class_data_; }


void ReadTreeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadTreeRequest*>(&to_msg);
  auto& from = static_cast<const ReadTreeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.ReadTreeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  if (from._internal_has_state_root()) {
    _this->_internal_mutable_state_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_state_root());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadTreeRequest::CopyFrom(const ReadTreeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.ReadTreeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadTreeRequest::IsInitialized() const {
  return true;
}

void ReadTreeRequest::InternalSwap(ReadTreeRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
  swap(_impl_.state_root_, other->_impl_.state_root_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadTreeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[16]);
}

// ===================================================================

class CancelBatchRequest::_Internal {
 public:
};

CancelBatchRequest::CancelBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.CancelBatchRequest)
}
CancelBatchRequest::CancelBatchRequest(const CancelBatchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CancelBatchRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_batch_uuid().empty()) {
    _this->_impl_.batch_uuid_.Set(from._internal_batch_uuid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.CancelBatchRequest)
}

inline void CancelBatchRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.batch_uuid_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.batch_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.batch_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CancelBatchRequest::~CancelBatchRequest() {
  // @@protoc_insertion_point(destructor:hashdb.v1.CancelBatchRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CancelBatchRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.batch_uuid_.Destroy();
}

void CancelBatchRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CancelBatchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.CancelBatchRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.batch_uuid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CancelBatchRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string batch_uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_batch_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.CancelBatchRequest.batch_uuid"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CancelBatchRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.CancelBatchRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_batch_uuid().data(), static_cast<int>(this->_internal_batch_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.CancelBatchRequest.batch_uuid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_batch_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.CancelBatchRequest)
  return target;
}

size_t CancelBatchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.CancelBatchRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string batch_uuid = 1;
  if (!this->_internal_batch_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_batch_uuid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CancelBatchRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CancelBatchRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CancelBatchRequest::GetClassData() const { return &_class_data_; }


void CancelBatchRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CancelBatchRequest*>(&to_msg);
  auto& from = static_cast<const CancelBatchRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.CancelBatchRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_batch_uuid().empty()) {
    _this->_internal_set_batch_uuid(from._internal_batch_uuid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CancelBatchRequest::CopyFrom(const CancelBatchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.CancelBatchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelBatchRequest::IsInitialized() const {
  return true;
}

void CancelBatchRequest::InternalSwap(CancelBatchRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.batch_uuid_, lhs_arena,
      &other->_impl_.batch_uuid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CancelBatchRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[17]);
}

// ===================================================================

class GetLatestStateRootResponse::_Internal {
 public:
  static const ::hashdb::v1::Fea& latest_root(const GetLatestStateRootResponse* msg);
  static const ::hashdb::v1::ResultCode& result(const GetLatestStateRootResponse* msg);
};

const ::hashdb::v1::Fea&
GetLatestStateRootResponse::_Internal::latest_root(const GetLatestStateRootResponse* msg) {
  return *msg->_impl_.latest_root_;
}
const ::hashdb::v1::ResultCode&
GetLatestStateRootResponse::_Internal::result(const GetLatestStateRootResponse* msg) {
  return *msg->_impl_.result_;
}
GetLatestStateRootResponse::GetLatestStateRootResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetLatestStateRootResponse)
}
GetLatestStateRootResponse::GetLatestStateRootResponse(const GetLatestStateRootResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetLatestStateRootResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_root_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_latest_root()) {
    _this->_impl_.latest_root_ = new ::hashdb::v1::Fea(*from._impl_.latest_root_);
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetLatestStateRootResponse)
}

inline void GetLatestStateRootResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.latest_root_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetLatestStateRootResponse::~GetLatestStateRootResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetLatestStateRootResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetLatestStateRootResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.latest_root_;
  if (this != internal_default_instance()) delete _impl_.result_;
}

void GetLatestStateRootResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetLatestStateRootResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetLatestStateRootResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.latest_root_ != nullptr) {
    delete _impl_.latest_root_;
  }
  _impl_.latest_root_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetLatestStateRootResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea latest_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_latest_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetLatestStateRootResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetLatestStateRootResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea latest_root = 1;
  if (this->_internal_has_latest_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::latest_root(this),
        _Internal::latest_root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.ResultCode result = 2;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetLatestStateRootResponse)
  return target;
}

size_t GetLatestStateRootResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetLatestStateRootResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.Fea latest_root = 1;
  if (this->_internal_has_latest_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.latest_root_);
  }

  // .hashdb.v1.ResultCode result = 2;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetLatestStateRootResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetLatestStateRootResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetLatestStateRootResponse::GetClassData() const { return &_class_data_; }


void GetLatestStateRootResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetLatestStateRootResponse*>(&to_msg);
  auto& from = static_cast<const GetLatestStateRootResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetLatestStateRootResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_latest_root()) {
    _this->_internal_mutable_latest_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_latest_root());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetLatestStateRootResponse::CopyFrom(const GetLatestStateRootResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetLatestStateRootResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLatestStateRootResponse::IsInitialized() const {
  return true;
}

void GetLatestStateRootResponse::InternalSwap(GetLatestStateRootResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetLatestStateRootResponse, _impl_.result_)
      + sizeof(GetLatestStateRootResponse::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(GetLatestStateRootResponse, _impl_.latest_root_)>(
          reinterpret_cast<char*>(&_impl_.latest_root_),
          reinterpret_cast<char*>(&other->_impl_.latest_root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetLatestStateRootResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[18]);
}

// ===================================================================

SetResponse_SiblingsEntry_DoNotUse::SetResponse_SiblingsEntry_DoNotUse() {}
SetResponse_SiblingsEntry_DoNotUse::SetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SetResponse_SiblingsEntry_DoNotUse::MergeFrom(const SetResponse_SiblingsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SetResponse_SiblingsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[19]);
}

// ===================================================================

SetResponse_DbReadLogEntry_DoNotUse::SetResponse_DbReadLogEntry_DoNotUse() {}
SetResponse_DbReadLogEntry_DoNotUse::SetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SetResponse_DbReadLogEntry_DoNotUse::MergeFrom(const SetResponse_DbReadLogEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SetResponse_DbReadLogEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[20]);
}

// ===================================================================

class SetResponse::_Internal {
 public:
  static const ::hashdb::v1::Fea& old_root(const SetResponse* msg);
  static const ::hashdb::v1::Fea& new_root(const SetResponse* msg);
  static const ::hashdb::v1::Fea& key(const SetResponse* msg);
  static const ::hashdb::v1::Fea& ins_key(const SetResponse* msg);
  static const ::hashdb::v1::ResultCode& result(const SetResponse* msg);
  static const ::hashdb::v1::Fea& sibling_left_child(const SetResponse* msg);
  static const ::hashdb::v1::Fea& sibling_right_child(const SetResponse* msg);
};

const ::hashdb::v1::Fea&
SetResponse::_Internal::old_root(const SetResponse* msg) {
  return *msg->_impl_.old_root_;
}
const ::hashdb::v1::Fea&
SetResponse::_Internal::new_root(const SetResponse* msg) {
  return *msg->_impl_.new_root_;
}
const ::hashdb::v1::Fea&
SetResponse::_Internal::key(const SetResponse* msg) {
  return *msg->_impl_.key_;
}
const ::hashdb::v1::Fea&
SetResponse::_Internal::ins_key(const SetResponse* msg) {
  return *msg->_impl_.ins_key_;
}
const ::hashdb::v1::ResultCode&
SetResponse::_Internal::result(const SetResponse* msg) {
  return *msg->_impl_.result_;
}
const ::hashdb::v1::Fea&
SetResponse::_Internal::sibling_left_child(const SetResponse* msg) {
  return *msg->_impl_.sibling_left_child_;
}
const ::hashdb::v1::Fea&
SetResponse::_Internal::sibling_right_child(const SetResponse* msg) {
  return *msg->_impl_.sibling_right_child_;
}
SetResponse::SetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &SetResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.SetResponse)
}
SetResponse::SetResponse(const SetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.siblings_)*/{}
    , /*decltype(_impl_.db_read_log_)*/{}
    , decltype(_impl_.ins_value_){}
    , decltype(_impl_.old_value_){}
    , decltype(_impl_.new_value_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.old_root_){nullptr}
    , decltype(_impl_.new_root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.ins_key_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.sibling_left_child_){nullptr}
    , decltype(_impl_.sibling_right_child_){nullptr}
    , decltype(_impl_.proof_hash_counter_){}
    , decltype(_impl_.is_old0_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.siblings_.MergeFrom(from._impl_.siblings_);
  _this->_impl_.db_read_log_.MergeFrom(from._impl_.db_read_log_);
  _impl_.ins_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ins_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ins_value().empty()) {
    _this->_impl_.ins_value_.Set(from._internal_ins_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.old_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_old_value().empty()) {
    _this->_impl_.old_value_.Set(from._internal_old_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.new_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_new_value().empty()) {
    _this->_impl_.new_value_.Set(from._internal_new_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mode().empty()) {
    _this->_impl_.mode_.Set(from._internal_mode(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_old_root()) {
    _this->_impl_.old_root_ = new ::hashdb::v1::Fea(*from._impl_.old_root_);
  }
  if (from._internal_has_new_root()) {
    _this->_impl_.new_root_ = new ::hashdb::v1::Fea(*from._impl_.new_root_);
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hashdb::v1::Fea(*from._impl_.key_);
  }
  if (from._internal_has_ins_key()) {
    _this->_impl_.ins_key_ = new ::hashdb::v1::Fea(*from._impl_.ins_key_);
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  if (from._internal_has_sibling_left_child()) {
    _this->_impl_.sibling_left_child_ = new ::hashdb::v1::Fea(*from._impl_.sibling_left_child_);
  }
  if (from._internal_has_sibling_right_child()) {
    _this->_impl_.sibling_right_child_ = new ::hashdb::v1::Fea(*from._impl_.sibling_right_child_);
  }
  ::memcpy(&_impl_.proof_hash_counter_, &from._impl_.proof_hash_counter_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_old0_) -
    reinterpret_cast<char*>(&_impl_.proof_hash_counter_)) + sizeof(_impl_.is_old0_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.SetResponse)
}

inline void SetResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.siblings_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.db_read_log_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.ins_value_){}
    , decltype(_impl_.old_value_){}
    , decltype(_impl_.new_value_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.old_root_){nullptr}
    , decltype(_impl_.new_root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.ins_key_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.sibling_left_child_){nullptr}
    , decltype(_impl_.sibling_right_child_){nullptr}
    , decltype(_impl_.proof_hash_counter_){uint64_t{0u}}
    , decltype(_impl_.is_old0_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ins_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ins_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.old_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.new_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetResponse::~SetResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.SetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void SetResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.siblings_.Destruct();
  _impl_.siblings_.~MapField();
  _impl_.db_read_log_.Destruct();
  _impl_.db_read_log_.~MapField();
  _impl_.ins_value_.Destroy();
  _impl_.old_value_.Destroy();
  _impl_.new_value_.Destroy();
  _impl_.mode_.Destroy();
  if (this != internal_default_instance()) delete _impl_.old_root_;
  if (this != internal_default_instance()) delete _impl_.new_root_;
  if (this != internal_default_instance()) delete _impl_.key_;
  if (this != internal_default_instance()) delete _impl_.ins_key_;
  if (this != internal_default_instance()) delete _impl_.result_;
  if (this != internal_default_instance()) delete _impl_.sibling_left_child_;
  if (this != internal_default_instance()) delete _impl_.sibling_right_child_;
}

void SetResponse::ArenaDtor(void* object) {
  SetResponse* _this = reinterpret_cast< SetResponse* >(object);
  _this->_impl_.siblings_.Destruct();
  _this->_impl_.db_read_log_.Destruct();
}
void SetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.SetResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.siblings_.Clear();
  _impl_.db_read_log_.Clear();
  _impl_.ins_value_.ClearToEmpty();
  _impl_.old_value_.ClearToEmpty();
  _impl_.new_value_.ClearToEmpty();
  _impl_.mode_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.old_root_ != nullptr) {
    delete _impl_.old_root_;
  }
  _impl_.old_root_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.new_root_ != nullptr) {
    delete _impl_.new_root_;
  }
  _impl_.new_root_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.ins_key_ != nullptr) {
    delete _impl_.ins_key_;
  }
  _impl_.ins_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.sibling_left_child_ != nullptr) {
    delete _impl_.sibling_left_child_;
  }
  _impl_.sibling_left_child_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.sibling_right_child_ != nullptr) {
    delete _impl_.sibling_right_child_;
  }
  _impl_.sibling_right_child_ = nullptr;
  ::memset(&_impl_.proof_hash_counter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_old0_) -
      reinterpret_cast<char*>(&_impl_.proof_hash_counter_)) + sizeof(_impl_.is_old0_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea old_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea new_root = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<uint64, .hashdb.v1.SiblingList> siblings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.siblings_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea ins_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ins_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ins_value = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_ins_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.SetResponse.ins_value"));
        } else
          goto handle_unusual;
        continue;
      // bool is_old0 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.is_old0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string old_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_old_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.SetResponse.old_value"));
        } else
          goto handle_unusual;
        continue;
      // string new_value = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_new_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.SetResponse.new_value"));
        } else
          goto handle_unusual;
        continue;
      // string mode = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.SetResponse.mode"));
        } else
          goto handle_unusual;
        continue;
      // uint64 proof_hash_counter = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.proof_hash_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .hashdb.v1.FeList> db_read_log = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.db_read_log_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea sibling_left_child = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_sibling_left_child(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea sibling_right_child = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_sibling_right_child(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.SetResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea old_root = 1;
  if (this->_internal_has_old_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::old_root(this),
        _Internal::old_root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea new_root = 2;
  if (this->_internal_has_new_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::new_root(this),
        _Internal::new_root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea key = 3;
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // map<uint64, .hashdb.v1.SiblingList> siblings = 4;
  if (!this->_internal_siblings().empty()) {
    using MapType = ::_pb::Map<uint64_t, ::hashdb::v1::SiblingList>;
    using WireHelper = SetResponse_SiblingsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_siblings();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
      }
    }
  }

  // .hashdb.v1.Fea ins_key = 5;
  if (this->_internal_has_ins_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::ins_key(this),
        _Internal::ins_key(this).GetCachedSize(), target, stream);
  }

  // string ins_value = 6;
  if (!this->_internal_ins_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ins_value().data(), static_cast<int>(this->_internal_ins_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.SetResponse.ins_value");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_ins_value(), target);
  }

  // bool is_old0 = 7;
  if (this->_internal_is_old0() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_old0(), target);
  }

  // string old_value = 8;
  if (!this->_internal_old_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_old_value().data(), static_cast<int>(this->_internal_old_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.SetResponse.old_value");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_old_value(), target);
  }

  // string new_value = 9;
  if (!this->_internal_new_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_new_value().data(), static_cast<int>(this->_internal_new_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.SetResponse.new_value");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_new_value(), target);
  }

  // string mode = 10;
  if (!this->_internal_mode().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mode().data(), static_cast<int>(this->_internal_mode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.SetResponse.mode");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_mode(), target);
  }

  // uint64 proof_hash_counter = 11;
  if (this->_internal_proof_hash_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_proof_hash_counter(), target);
  }

  // map<string, .hashdb.v1.FeList> db_read_log = 12;
  if (!this->_internal_db_read_log().empty()) {
    using MapType = ::_pb::Map<std::string, ::hashdb::v1::FeList>;
    using WireHelper = SetResponse_DbReadLogEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_db_read_log();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.SetResponse.DbReadLogEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(12, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .hashdb.v1.ResultCode result = 13;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea sibling_left_child = 14;
  if (this->_internal_has_sibling_left_child()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::sibling_left_child(this),
        _Internal::sibling_left_child(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea sibling_right_child = 15;
  if (this->_internal_has_sibling_right_child()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::sibling_right_child(this),
        _Internal::sibling_right_child(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.SetResponse)
  return target;
}

size_t SetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.SetResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<uint64, .hashdb.v1.SiblingList> siblings = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_siblings_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >::const_iterator
      it = this->_internal_siblings().begin();
      it != this->_internal_siblings().end(); ++it) {
    total_size += SetResponse_SiblingsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .hashdb.v1.FeList> db_read_log = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_db_read_log_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >::const_iterator
      it = this->_internal_db_read_log().begin();
      it != this->_internal_db_read_log().end(); ++it) {
    total_size += SetResponse_DbReadLogEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string ins_value = 6;
  if (!this->_internal_ins_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ins_value());
  }

  // string old_value = 8;
  if (!this->_internal_old_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_old_value());
  }

  // string new_value = 9;
  if (!this->_internal_new_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_new_value());
  }

  // string mode = 10;
  if (!this->_internal_mode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mode());
  }

  // .hashdb.v1.Fea old_root = 1;
  if (this->_internal_has_old_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_root_);
  }

  // .hashdb.v1.Fea new_root = 2;
  if (this->_internal_has_new_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_root_);
  }

  // .hashdb.v1.Fea key = 3;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  // .hashdb.v1.Fea ins_key = 5;
  if (this->_internal_has_ins_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ins_key_);
  }

  // .hashdb.v1.ResultCode result = 13;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  // .hashdb.v1.Fea sibling_left_child = 14;
  if (this->_internal_has_sibling_left_child()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sibling_left_child_);
  }

  // .hashdb.v1.Fea sibling_right_child = 15;
  if (this->_internal_has_sibling_right_child()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sibling_right_child_);
  }

  // uint64 proof_hash_counter = 11;
  if (this->_internal_proof_hash_counter() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_proof_hash_counter());
  }

  // bool is_old0 = 7;
  if (this->_internal_is_old0() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetResponse::GetClassData() const { return &_class_data_; }


void SetResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetResponse*>(&to_msg);
  auto& from = static_cast<const SetResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.SetResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.siblings_.MergeFrom(from._impl_.siblings_);
  _this->_impl_.db_read_log_.MergeFrom(from._impl_.db_read_log_);
  if (!from._internal_ins_value().empty()) {
    _this->_internal_set_ins_value(from._internal_ins_value());
  }
  if (!from._internal_old_value().empty()) {
    _this->_internal_set_old_value(from._internal_old_value());
  }
  if (!from._internal_new_value().empty()) {
    _this->_internal_set_new_value(from._internal_new_value());
  }
  if (!from._internal_mode().empty()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  if (from._internal_has_old_root()) {
    _this->_internal_mutable_old_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_old_root());
  }
  if (from._internal_has_new_root()) {
    _this->_internal_mutable_new_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_new_root());
  }
  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_key());
  }
  if (from._internal_has_ins_key()) {
    _this->_internal_mutable_ins_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_ins_key());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  if (from._internal_has_sibling_left_child()) {
    _this->_internal_mutable_sibling_left_child()->::hashdb::v1::Fea::MergeFrom(
        from._internal_sibling_left_child());
  }
  if (from._internal_has_sibling_right_child()) {
    _this->_internal_mutable_sibling_right_child()->::hashdb::v1::Fea::MergeFrom(
        from._internal_sibling_right_child());
  }
  if (from._internal_proof_hash_counter() != 0) {
    _this->_internal_set_proof_hash_counter(from._internal_proof_hash_counter());
  }
  if (from._internal_is_old0() != 0) {
    _this->_internal_set_is_old0(from._internal_is_old0());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetResponse::CopyFrom(const SetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.SetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetResponse::IsInitialized() const {
  return true;
}

void SetResponse::InternalSwap(SetResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.siblings_.InternalSwap(&other->_impl_.siblings_);
  _impl_.db_read_log_.InternalSwap(&other->_impl_.db_read_log_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ins_value_, lhs_arena,
      &other->_impl_.ins_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.old_value_, lhs_arena,
      &other->_impl_.old_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_value_, lhs_arena,
      &other->_impl_.new_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mode_, lhs_arena,
      &other->_impl_.mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetResponse, _impl_.is_old0_)
      + sizeof(SetResponse::_impl_.is_old0_)
      - PROTOBUF_FIELD_OFFSET(SetResponse, _impl_.old_root_)>(
          reinterpret_cast<char*>(&_impl_.old_root_),
          reinterpret_cast<char*>(&other->_impl_.old_root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[21]);
}

// ===================================================================

GetResponse_SiblingsEntry_DoNotUse::GetResponse_SiblingsEntry_DoNotUse() {}
GetResponse_SiblingsEntry_DoNotUse::GetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void GetResponse_SiblingsEntry_DoNotUse::MergeFrom(const GetResponse_SiblingsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata GetResponse_SiblingsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[22]);
}

// ===================================================================

GetResponse_DbReadLogEntry_DoNotUse::GetResponse_DbReadLogEntry_DoNotUse() {}
GetResponse_DbReadLogEntry_DoNotUse::GetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void GetResponse_DbReadLogEntry_DoNotUse::MergeFrom(const GetResponse_DbReadLogEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata GetResponse_DbReadLogEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[23]);
}

// ===================================================================

class GetResponse::_Internal {
 public:
  static const ::hashdb::v1::Fea& root(const GetResponse* msg);
  static const ::hashdb::v1::Fea& key(const GetResponse* msg);
  static const ::hashdb::v1::Fea& ins_key(const GetResponse* msg);
  static const ::hashdb::v1::ResultCode& result(const GetResponse* msg);
};

const ::hashdb::v1::Fea&
GetResponse::_Internal::root(const GetResponse* msg) {
  return *msg->_impl_.root_;
}
const ::hashdb::v1::Fea&
GetResponse::_Internal::key(const GetResponse* msg) {
  return *msg->_impl_.key_;
}
const ::hashdb::v1::Fea&
GetResponse::_Internal::ins_key(const GetResponse* msg) {
  return *msg->_impl_.ins_key_;
}
const ::hashdb::v1::ResultCode&
GetResponse::_Internal::result(const GetResponse* msg) {
  return *msg->_impl_.result_;
}
GetResponse::GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &GetResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetResponse)
}
GetResponse::GetResponse(const GetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.siblings_)*/{}
    , /*decltype(_impl_.db_read_log_)*/{}
    , decltype(_impl_.ins_value_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.ins_key_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.proof_hash_counter_){}
    , decltype(_impl_.is_old0_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.siblings_.MergeFrom(from._impl_.siblings_);
  _this->_impl_.db_read_log_.MergeFrom(from._impl_.db_read_log_);
  _impl_.ins_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ins_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ins_value().empty()) {
    _this->_impl_.ins_value_.Set(from._internal_ins_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_root()) {
    _this->_impl_.root_ = new ::hashdb::v1::Fea(*from._impl_.root_);
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hashdb::v1::Fea(*from._impl_.key_);
  }
  if (from._internal_has_ins_key()) {
    _this->_impl_.ins_key_ = new ::hashdb::v1::Fea(*from._impl_.ins_key_);
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  ::memcpy(&_impl_.proof_hash_counter_, &from._impl_.proof_hash_counter_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_old0_) -
    reinterpret_cast<char*>(&_impl_.proof_hash_counter_)) + sizeof(_impl_.is_old0_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetResponse)
}

inline void GetResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.siblings_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.db_read_log_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.ins_value_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.root_){nullptr}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.ins_key_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.proof_hash_counter_){uint64_t{0u}}
    , decltype(_impl_.is_old0_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ins_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ins_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetResponse::~GetResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void GetResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.siblings_.Destruct();
  _impl_.siblings_.~MapField();
  _impl_.db_read_log_.Destruct();
  _impl_.db_read_log_.~MapField();
  _impl_.ins_value_.Destroy();
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.root_;
  if (this != internal_default_instance()) delete _impl_.key_;
  if (this != internal_default_instance()) delete _impl_.ins_key_;
  if (this != internal_default_instance()) delete _impl_.result_;
}

void GetResponse::ArenaDtor(void* object) {
  GetResponse* _this = reinterpret_cast< GetResponse* >(object);
  _this->_impl_.siblings_.Destruct();
  _this->_impl_.db_read_log_.Destruct();
}
void GetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.siblings_.Clear();
  _impl_.db_read_log_.Clear();
  _impl_.ins_value_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.root_ != nullptr) {
    delete _impl_.root_;
  }
  _impl_.root_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.ins_key_ != nullptr) {
    delete _impl_.ins_key_;
  }
  _impl_.ins_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  ::memset(&_impl_.proof_hash_counter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_old0_) -
      reinterpret_cast<char*>(&_impl_.proof_hash_counter_)) + sizeof(_impl_.is_old0_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<uint64, .hashdb.v1.SiblingList> siblings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.siblings_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea ins_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ins_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ins_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ins_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.GetResponse.ins_value"));
        } else
          goto handle_unusual;
        continue;
      // bool is_old0 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.is_old0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.GetResponse.value"));
        } else
          goto handle_unusual;
        continue;
      // uint64 proof_hash_counter = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.proof_hash_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .hashdb.v1.FeList> db_read_log = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.db_read_log_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea root = 1;
  if (this->_internal_has_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::root(this),
        _Internal::root(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea key = 2;
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // map<uint64, .hashdb.v1.SiblingList> siblings = 3;
  if (!this->_internal_siblings().empty()) {
    using MapType = ::_pb::Map<uint64_t, ::hashdb::v1::SiblingList>;
    using WireHelper = GetResponse_SiblingsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_siblings();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    }
  }

  // .hashdb.v1.Fea ins_key = 4;
  if (this->_internal_has_ins_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ins_key(this),
        _Internal::ins_key(this).GetCachedSize(), target, stream);
  }

  // string ins_value = 5;
  if (!this->_internal_ins_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ins_value().data(), static_cast<int>(this->_internal_ins_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.GetResponse.ins_value");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ins_value(), target);
  }

  // bool is_old0 = 6;
  if (this->_internal_is_old0() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_old0(), target);
  }

  // string value = 7;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.GetResponse.value");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_value(), target);
  }

  // uint64 proof_hash_counter = 8;
  if (this->_internal_proof_hash_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_proof_hash_counter(), target);
  }

  // map<string, .hashdb.v1.FeList> db_read_log = 9;
  if (!this->_internal_db_read_log().empty()) {
    using MapType = ::_pb::Map<std::string, ::hashdb::v1::FeList>;
    using WireHelper = GetResponse_DbReadLogEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_db_read_log();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.GetResponse.DbReadLogEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(9, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(9, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .hashdb.v1.ResultCode result = 10;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetResponse)
  return target;
}

size_t GetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<uint64, .hashdb.v1.SiblingList> siblings = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_siblings_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::hashdb::v1::SiblingList >::const_iterator
      it = this->_internal_siblings().begin();
      it != this->_internal_siblings().end(); ++it) {
    total_size += GetResponse_SiblingsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, .hashdb.v1.FeList> db_read_log = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_db_read_log_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >::const_iterator
      it = this->_internal_db_read_log().begin();
      it != this->_internal_db_read_log().end(); ++it) {
    total_size += GetResponse_DbReadLogEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string ins_value = 5;
  if (!this->_internal_ins_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ins_value());
  }

  // string value = 7;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // .hashdb.v1.Fea root = 1;
  if (this->_internal_has_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.root_);
  }

  // .hashdb.v1.Fea key = 2;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  // .hashdb.v1.Fea ins_key = 4;
  if (this->_internal_has_ins_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ins_key_);
  }

  // .hashdb.v1.ResultCode result = 10;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  // uint64 proof_hash_counter = 8;
  if (this->_internal_proof_hash_counter() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_proof_hash_counter());
  }

  // bool is_old0 = 6;
  if (this->_internal_is_old0() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetResponse::GetClassData() const { return &_class_data_; }


void GetResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetResponse*>(&to_msg);
  auto& from = static_cast<const GetResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.siblings_.MergeFrom(from._impl_.siblings_);
  _this->_impl_.db_read_log_.MergeFrom(from._impl_.db_read_log_);
  if (!from._internal_ins_value().empty()) {
    _this->_internal_set_ins_value(from._internal_ins_value());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_has_root()) {
    _this->_internal_mutable_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_root());
  }
  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_key());
  }
  if (from._internal_has_ins_key()) {
    _this->_internal_mutable_ins_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_ins_key());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  if (from._internal_proof_hash_counter() != 0) {
    _this->_internal_set_proof_hash_counter(from._internal_proof_hash_counter());
  }
  if (from._internal_is_old0() != 0) {
    _this->_internal_set_is_old0(from._internal_is_old0());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetResponse::CopyFrom(const GetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetResponse::IsInitialized() const {
  return true;
}

void GetResponse::InternalSwap(GetResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.siblings_.InternalSwap(&other->_impl_.siblings_);
  _impl_.db_read_log_.InternalSwap(&other->_impl_.db_read_log_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ins_value_, lhs_arena,
      &other->_impl_.ins_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetResponse, _impl_.is_old0_)
      + sizeof(GetResponse::_impl_.is_old0_)
      - PROTOBUF_FIELD_OFFSET(GetResponse, _impl_.root_)>(
          reinterpret_cast<char*>(&_impl_.root_),
          reinterpret_cast<char*>(&other->_impl_.root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[24]);
}

// ===================================================================

class SetProgramResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const SetProgramResponse* msg);
};

const ::hashdb::v1::ResultCode&
SetProgramResponse::_Internal::result(const SetProgramResponse* msg) {
  return *msg->_impl_.result_;
}
SetProgramResponse::SetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.SetProgramResponse)
}
SetProgramResponse::SetProgramResponse(const SetProgramResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetProgramResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.SetProgramResponse)
}

inline void SetProgramResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetProgramResponse::~SetProgramResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.SetProgramResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetProgramResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.result_;
}

void SetProgramResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetProgramResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.SetProgramResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetProgramResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.ResultCode result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetProgramResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.SetProgramResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.SetProgramResponse)
  return target;
}

size_t SetProgramResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.SetProgramResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetProgramResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetProgramResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetProgramResponse::GetClassData() const { return &_class_data_; }


void SetProgramResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetProgramResponse*>(&to_msg);
  auto& from = static_cast<const SetProgramResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.SetProgramResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetProgramResponse::CopyFrom(const SetProgramResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.SetProgramResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetProgramResponse::IsInitialized() const {
  return true;
}

void SetProgramResponse::InternalSwap(SetProgramResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetProgramResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[25]);
}

// ===================================================================

class GetProgramResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const GetProgramResponse* msg);
};

const ::hashdb::v1::ResultCode&
GetProgramResponse::_Internal::result(const GetProgramResponse* msg) {
  return *msg->_impl_.result_;
}
GetProgramResponse::GetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetProgramResponse)
}
GetProgramResponse::GetProgramResponse(const GetProgramResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetProgramResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetProgramResponse)
}

inline void GetProgramResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetProgramResponse::~GetProgramResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetProgramResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetProgramResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.result_;
}

void GetProgramResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetProgramResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetProgramResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetProgramResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetProgramResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetProgramResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  // .hashdb.v1.ResultCode result = 2;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetProgramResponse)
  return target;
}

size_t GetProgramResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetProgramResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // .hashdb.v1.ResultCode result = 2;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetProgramResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetProgramResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetProgramResponse::GetClassData() const { return &_class_data_; }


void GetProgramResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetProgramResponse*>(&to_msg);
  auto& from = static_cast<const GetProgramResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetProgramResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetProgramResponse::CopyFrom(const GetProgramResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetProgramResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetProgramResponse::IsInitialized() const {
  return true;
}

void GetProgramResponse::InternalSwap(GetProgramResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetProgramResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[26]);
}

// ===================================================================

class FlushResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const FlushResponse* msg);
};

const ::hashdb::v1::ResultCode&
FlushResponse::_Internal::result(const FlushResponse* msg) {
  return *msg->_impl_.result_;
}
FlushResponse::FlushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.FlushResponse)
}
FlushResponse::FlushResponse(const FlushResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlushResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , decltype(_impl_.flush_id_){}
    , decltype(_impl_.stored_flush_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  ::memcpy(&_impl_.flush_id_, &from._impl_.flush_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stored_flush_id_) -
    reinterpret_cast<char*>(&_impl_.flush_id_)) + sizeof(_impl_.stored_flush_id_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.FlushResponse)
}

inline void FlushResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , decltype(_impl_.flush_id_){uint64_t{0u}}
    , decltype(_impl_.stored_flush_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlushResponse::~FlushResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.FlushResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.result_;
}

void FlushResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlushResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.FlushResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  ::memset(&_impl_.flush_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.stored_flush_id_) -
      reinterpret_cast<char*>(&_impl_.flush_id_)) + sizeof(_impl_.stored_flush_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlushResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 flush_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 stored_flush_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.stored_flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.FlushResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 flush_id = 1;
  if (this->_internal_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_flush_id(), target);
  }

  // uint64 stored_flush_id = 2;
  if (this->_internal_stored_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_stored_flush_id(), target);
  }

  // .hashdb.v1.ResultCode result = 3;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.FlushResponse)
  return target;
}

size_t FlushResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.FlushResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 3;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  // uint64 flush_id = 1;
  if (this->_internal_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flush_id());
  }

  // uint64 stored_flush_id = 2;
  if (this->_internal_stored_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stored_flush_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlushResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlushResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlushResponse::GetClassData() const { return &_class_data_; }


void FlushResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlushResponse*>(&to_msg);
  auto& from = static_cast<const FlushResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.FlushResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  if (from._internal_flush_id() != 0) {
    _this->_internal_set_flush_id(from._internal_flush_id());
  }
  if (from._internal_stored_flush_id() != 0) {
    _this->_internal_set_stored_flush_id(from._internal_stored_flush_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlushResponse::CopyFrom(const FlushResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.FlushResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushResponse::IsInitialized() const {
  return true;
}

void FlushResponse::InternalSwap(FlushResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlushResponse, _impl_.stored_flush_id_)
      + sizeof(FlushResponse::_impl_.stored_flush_id_)
      - PROTOBUF_FIELD_OFFSET(FlushResponse, _impl_.result_)>(
          reinterpret_cast<char*>(&_impl_.result_),
          reinterpret_cast<char*>(&other->_impl_.result_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlushResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[27]);
}

// ===================================================================

class GetFlushStatusResponse::_Internal {
 public:
};

GetFlushStatusResponse::GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetFlushStatusResponse)
}
GetFlushStatusResponse::GetFlushStatusResponse(const GetFlushStatusResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetFlushStatusResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.prover_id_){}
    , decltype(_impl_.stored_flush_id_){}
    , decltype(_impl_.storing_flush_id_){}
    , decltype(_impl_.last_flush_id_){}
    , decltype(_impl_.pending_to_flush_nodes_){}
    , decltype(_impl_.pending_to_flush_program_){}
    , decltype(_impl_.storing_nodes_){}
    , decltype(_impl_.storing_program_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.prover_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_prover_id().empty()) {
    _this->_impl_.prover_id_.Set(from._internal_prover_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.stored_flush_id_, &from._impl_.stored_flush_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.storing_program_) -
    reinterpret_cast<char*>(&_impl_.stored_flush_id_)) + sizeof(_impl_.storing_program_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetFlushStatusResponse)
}

inline void GetFlushStatusResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.prover_id_){}
    , decltype(_impl_.stored_flush_id_){uint64_t{0u}}
    , decltype(_impl_.storing_flush_id_){uint64_t{0u}}
    , decltype(_impl_.last_flush_id_){uint64_t{0u}}
    , decltype(_impl_.pending_to_flush_nodes_){uint64_t{0u}}
    , decltype(_impl_.pending_to_flush_program_){uint64_t{0u}}
    , decltype(_impl_.storing_nodes_){uint64_t{0u}}
    , decltype(_impl_.storing_program_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.prover_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prover_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetFlushStatusResponse::~GetFlushStatusResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetFlushStatusResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetFlushStatusResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prover_id_.Destroy();
}

void GetFlushStatusResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetFlushStatusResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetFlushStatusResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prover_id_.ClearToEmpty();
  ::memset(&_impl_.stored_flush_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.storing_program_) -
      reinterpret_cast<char*>(&_impl_.stored_flush_id_)) + sizeof(_impl_.storing_program_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFlushStatusResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 stored_flush_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.stored_flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 storing_flush_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.storing_flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 last_flush_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.last_flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 pending_to_flush_nodes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.pending_to_flush_nodes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 pending_to_flush_program = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.pending_to_flush_program_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 storing_nodes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.storing_nodes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 storing_program = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.storing_program_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string prover_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_prover_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.GetFlushStatusResponse.prover_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFlushStatusResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetFlushStatusResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 stored_flush_id = 1;
  if (this->_internal_stored_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_stored_flush_id(), target);
  }

  // uint64 storing_flush_id = 2;
  if (this->_internal_storing_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_storing_flush_id(), target);
  }

  // uint64 last_flush_id = 3;
  if (this->_internal_last_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_last_flush_id(), target);
  }

  // uint64 pending_to_flush_nodes = 4;
  if (this->_internal_pending_to_flush_nodes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pending_to_flush_nodes(), target);
  }

  // uint64 pending_to_flush_program = 5;
  if (this->_internal_pending_to_flush_program() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_pending_to_flush_program(), target);
  }

  // uint64 storing_nodes = 6;
  if (this->_internal_storing_nodes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_storing_nodes(), target);
  }

  // uint64 storing_program = 7;
  if (this->_internal_storing_program() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_storing_program(), target);
  }

  // string prover_id = 8;
  if (!this->_internal_prover_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_prover_id().data(), static_cast<int>(this->_internal_prover_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.GetFlushStatusResponse.prover_id");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_prover_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetFlushStatusResponse)
  return target;
}

size_t GetFlushStatusResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetFlushStatusResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string prover_id = 8;
  if (!this->_internal_prover_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_prover_id());
  }

  // uint64 stored_flush_id = 1;
  if (this->_internal_stored_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stored_flush_id());
  }

  // uint64 storing_flush_id = 2;
  if (this->_internal_storing_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_storing_flush_id());
  }

  // uint64 last_flush_id = 3;
  if (this->_internal_last_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_flush_id());
  }

  // uint64 pending_to_flush_nodes = 4;
  if (this->_internal_pending_to_flush_nodes() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pending_to_flush_nodes());
  }

  // uint64 pending_to_flush_program = 5;
  if (this->_internal_pending_to_flush_program() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pending_to_flush_program());
  }

  // uint64 storing_nodes = 6;
  if (this->_internal_storing_nodes() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_storing_nodes());
  }

  // uint64 storing_program = 7;
  if (this->_internal_storing_program() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_storing_program());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFlushStatusResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetFlushStatusResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFlushStatusResponse::GetClassData() const { return &_class_data_; }


void GetFlushStatusResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetFlushStatusResponse*>(&to_msg);
  auto& from = static_cast<const GetFlushStatusResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetFlushStatusResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_prover_id().empty()) {
    _this->_internal_set_prover_id(from._internal_prover_id());
  }
  if (from._internal_stored_flush_id() != 0) {
    _this->_internal_set_stored_flush_id(from._internal_stored_flush_id());
  }
  if (from._internal_storing_flush_id() != 0) {
    _this->_internal_set_storing_flush_id(from._internal_storing_flush_id());
  }
  if (from._internal_last_flush_id() != 0) {
    _this->_internal_set_last_flush_id(from._internal_last_flush_id());
  }
  if (from._internal_pending_to_flush_nodes() != 0) {
    _this->_internal_set_pending_to_flush_nodes(from._internal_pending_to_flush_nodes());
  }
  if (from._internal_pending_to_flush_program() != 0) {
    _this->_internal_set_pending_to_flush_program(from._internal_pending_to_flush_program());
  }
  if (from._internal_storing_nodes() != 0) {
    _this->_internal_set_storing_nodes(from._internal_storing_nodes());
  }
  if (from._internal_storing_program() != 0) {
    _this->_internal_set_storing_program(from._internal_storing_program());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFlushStatusResponse::CopyFrom(const GetFlushStatusResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetFlushStatusResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFlushStatusResponse::IsInitialized() const {
  return true;
}

void GetFlushStatusResponse::InternalSwap(GetFlushStatusResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prover_id_, lhs_arena,
      &other->_impl_.prover_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetFlushStatusResponse, _impl_.storing_program_)
      + sizeof(GetFlushStatusResponse::_impl_.storing_program_)
      - PROTOBUF_FIELD_OFFSET(GetFlushStatusResponse, _impl_.stored_flush_id_)>(
          reinterpret_cast<char*>(&_impl_.stored_flush_id_),
          reinterpret_cast<char*>(&other->_impl_.stored_flush_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFlushStatusResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[28]);
}

// ===================================================================

GetFlushDataResponse_NodesEntry_DoNotUse::GetFlushDataResponse_NodesEntry_DoNotUse() {}
GetFlushDataResponse_NodesEntry_DoNotUse::GetFlushDataResponse_NodesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void GetFlushDataResponse_NodesEntry_DoNotUse::MergeFrom(const GetFlushDataResponse_NodesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata GetFlushDataResponse_NodesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[29]);
}

// ===================================================================

GetFlushDataResponse_ProgramEntry_DoNotUse::GetFlushDataResponse_ProgramEntry_DoNotUse() {}
GetFlushDataResponse_ProgramEntry_DoNotUse::GetFlushDataResponse_ProgramEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void GetFlushDataResponse_ProgramEntry_DoNotUse::MergeFrom(const GetFlushDataResponse_ProgramEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata GetFlushDataResponse_ProgramEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[30]);
}

// ===================================================================

class GetFlushDataResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const GetFlushDataResponse* msg);
};

const ::hashdb::v1::ResultCode&
GetFlushDataResponse::_Internal::result(const GetFlushDataResponse* msg) {
  return *msg->_impl_.result_;
}
GetFlushDataResponse::GetFlushDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &GetFlushDataResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.GetFlushDataResponse)
}
GetFlushDataResponse::GetFlushDataResponse(const GetFlushDataResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetFlushDataResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.nodes_)*/{}
    , /*decltype(_impl_.program_)*/{}
    , decltype(_impl_.nodes_state_root_){}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.stored_flush_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_impl_.program_.MergeFrom(from._impl_.program_);
  _impl_.nodes_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodes_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nodes_state_root().empty()) {
    _this->_impl_.nodes_state_root_.Set(from._internal_nodes_state_root(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  _this->_impl_.stored_flush_id_ = from._impl_.stored_flush_id_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.GetFlushDataResponse)
}

inline void GetFlushDataResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.nodes_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.program_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.nodes_state_root_){}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.stored_flush_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nodes_state_root_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nodes_state_root_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetFlushDataResponse::~GetFlushDataResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.GetFlushDataResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void GetFlushDataResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.Destruct();
  _impl_.nodes_.~MapField();
  _impl_.program_.Destruct();
  _impl_.program_.~MapField();
  _impl_.nodes_state_root_.Destroy();
  if (this != internal_default_instance()) delete _impl_.result_;
}

void GetFlushDataResponse::ArenaDtor(void* object) {
  GetFlushDataResponse* _this = reinterpret_cast< GetFlushDataResponse* >(object);
  _this->_impl_.nodes_.Destruct();
  _this->_impl_.program_.Destruct();
}
void GetFlushDataResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetFlushDataResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.GetFlushDataResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _impl_.program_.Clear();
  _impl_.nodes_state_root_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _impl_.stored_flush_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFlushDataResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 stored_flush_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.stored_flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> nodes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.nodes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> program = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.program_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string nodes_state_root = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_nodes_state_root();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.GetFlushDataResponse.nodes_state_root"));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFlushDataResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.GetFlushDataResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 stored_flush_id = 1;
  if (this->_internal_stored_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_stored_flush_id(), target);
  }

  // map<string, string> nodes = 2;
  if (!this->_internal_nodes().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = GetFlushDataResponse_NodesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_nodes();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.GetFlushDataResponse.NodesEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.GetFlushDataResponse.NodesEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, string> program = 3;
  if (!this->_internal_program().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = GetFlushDataResponse_ProgramEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_program();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.GetFlushDataResponse.ProgramEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "hashdb.v1.GetFlushDataResponse.ProgramEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // string nodes_state_root = 4;
  if (!this->_internal_nodes_state_root().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nodes_state_root().data(), static_cast<int>(this->_internal_nodes_state_root().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.GetFlushDataResponse.nodes_state_root");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nodes_state_root(), target);
  }

  // .hashdb.v1.ResultCode result = 5;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.GetFlushDataResponse)
  return target;
}

size_t GetFlushDataResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.GetFlushDataResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> nodes = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_nodes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_nodes().begin();
      it != this->_internal_nodes().end(); ++it) {
    total_size += GetFlushDataResponse_NodesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> program = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_program_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_program().begin();
      it != this->_internal_program().end(); ++it) {
    total_size += GetFlushDataResponse_ProgramEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string nodes_state_root = 4;
  if (!this->_internal_nodes_state_root().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nodes_state_root());
  }

  // .hashdb.v1.ResultCode result = 5;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  // uint64 stored_flush_id = 1;
  if (this->_internal_stored_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stored_flush_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFlushDataResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetFlushDataResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFlushDataResponse::GetClassData() const { return &_class_data_; }


void GetFlushDataResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetFlushDataResponse*>(&to_msg);
  auto& from = static_cast<const GetFlushDataResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.GetFlushDataResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_impl_.program_.MergeFrom(from._impl_.program_);
  if (!from._internal_nodes_state_root().empty()) {
    _this->_internal_set_nodes_state_root(from._internal_nodes_state_root());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  if (from._internal_stored_flush_id() != 0) {
    _this->_internal_set_stored_flush_id(from._internal_stored_flush_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFlushDataResponse::CopyFrom(const GetFlushDataResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.GetFlushDataResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFlushDataResponse::IsInitialized() const {
  return true;
}

void GetFlushDataResponse::InternalSwap(GetFlushDataResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  _impl_.program_.InternalSwap(&other->_impl_.program_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nodes_state_root_, lhs_arena,
      &other->_impl_.nodes_state_root_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetFlushDataResponse, _impl_.stored_flush_id_)
      + sizeof(GetFlushDataResponse::_impl_.stored_flush_id_)
      - PROTOBUF_FIELD_OFFSET(GetFlushDataResponse, _impl_.result_)>(
          reinterpret_cast<char*>(&_impl_.result_),
          reinterpret_cast<char*>(&other->_impl_.result_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFlushDataResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[31]);
}

// ===================================================================

class ConsolidateStateResponse::_Internal {
 public:
  static const ::hashdb::v1::Fea& consolidated_state_root(const ConsolidateStateResponse* msg);
  static const ::hashdb::v1::ResultCode& result(const ConsolidateStateResponse* msg);
};

const ::hashdb::v1::Fea&
ConsolidateStateResponse::_Internal::consolidated_state_root(const ConsolidateStateResponse* msg) {
  return *msg->_impl_.consolidated_state_root_;
}
const ::hashdb::v1::ResultCode&
ConsolidateStateResponse::_Internal::result(const ConsolidateStateResponse* msg) {
  return *msg->_impl_.result_;
}
ConsolidateStateResponse::ConsolidateStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.ConsolidateStateResponse)
}
ConsolidateStateResponse::ConsolidateStateResponse(const ConsolidateStateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConsolidateStateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.consolidated_state_root_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.flush_id_){}
    , decltype(_impl_.stored_flush_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_consolidated_state_root()) {
    _this->_impl_.consolidated_state_root_ = new ::hashdb::v1::Fea(*from._impl_.consolidated_state_root_);
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  ::memcpy(&_impl_.flush_id_, &from._impl_.flush_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stored_flush_id_) -
    reinterpret_cast<char*>(&_impl_.flush_id_)) + sizeof(_impl_.stored_flush_id_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.ConsolidateStateResponse)
}

inline void ConsolidateStateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.consolidated_state_root_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , decltype(_impl_.flush_id_){uint64_t{0u}}
    , decltype(_impl_.stored_flush_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConsolidateStateResponse::~ConsolidateStateResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.ConsolidateStateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConsolidateStateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.consolidated_state_root_;
  if (this != internal_default_instance()) delete _impl_.result_;
}

void ConsolidateStateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConsolidateStateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.ConsolidateStateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.consolidated_state_root_ != nullptr) {
    delete _impl_.consolidated_state_root_;
  }
  _impl_.consolidated_state_root_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  ::memset(&_impl_.flush_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.stored_flush_id_) -
      reinterpret_cast<char*>(&_impl_.flush_id_)) + sizeof(_impl_.stored_flush_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConsolidateStateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea consolidated_state_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_consolidated_state_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 flush_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 stored_flush_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.stored_flush_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConsolidateStateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.ConsolidateStateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea consolidated_state_root = 1;
  if (this->_internal_has_consolidated_state_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::consolidated_state_root(this),
        _Internal::consolidated_state_root(this).GetCachedSize(), target, stream);
  }

  // uint64 flush_id = 2;
  if (this->_internal_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_flush_id(), target);
  }

  // uint64 stored_flush_id = 3;
  if (this->_internal_stored_flush_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_stored_flush_id(), target);
  }

  // .hashdb.v1.ResultCode result = 4;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.ConsolidateStateResponse)
  return target;
}

size_t ConsolidateStateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.ConsolidateStateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.Fea consolidated_state_root = 1;
  if (this->_internal_has_consolidated_state_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.consolidated_state_root_);
  }

  // .hashdb.v1.ResultCode result = 4;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  // uint64 flush_id = 2;
  if (this->_internal_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flush_id());
  }

  // uint64 stored_flush_id = 3;
  if (this->_internal_stored_flush_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stored_flush_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConsolidateStateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConsolidateStateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConsolidateStateResponse::GetClassData() const { return &_class_data_; }


void ConsolidateStateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConsolidateStateResponse*>(&to_msg);
  auto& from = static_cast<const ConsolidateStateResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.ConsolidateStateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_consolidated_state_root()) {
    _this->_internal_mutable_consolidated_state_root()->::hashdb::v1::Fea::MergeFrom(
        from._internal_consolidated_state_root());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  if (from._internal_flush_id() != 0) {
    _this->_internal_set_flush_id(from._internal_flush_id());
  }
  if (from._internal_stored_flush_id() != 0) {
    _this->_internal_set_stored_flush_id(from._internal_stored_flush_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConsolidateStateResponse::CopyFrom(const ConsolidateStateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.ConsolidateStateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConsolidateStateResponse::IsInitialized() const {
  return true;
}

void ConsolidateStateResponse::InternalSwap(ConsolidateStateResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConsolidateStateResponse, _impl_.stored_flush_id_)
      + sizeof(ConsolidateStateResponse::_impl_.stored_flush_id_)
      - PROTOBUF_FIELD_OFFSET(ConsolidateStateResponse, _impl_.consolidated_state_root_)>(
          reinterpret_cast<char*>(&_impl_.consolidated_state_root_),
          reinterpret_cast<char*>(&other->_impl_.consolidated_state_root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConsolidateStateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[32]);
}

// ===================================================================

class PurgeResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const PurgeResponse* msg);
};

const ::hashdb::v1::ResultCode&
PurgeResponse::_Internal::result(const PurgeResponse* msg) {
  return *msg->_impl_.result_;
}
PurgeResponse::PurgeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.PurgeResponse)
}
PurgeResponse::PurgeResponse(const PurgeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PurgeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.PurgeResponse)
}

inline void PurgeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PurgeResponse::~PurgeResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.PurgeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PurgeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.result_;
}

void PurgeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PurgeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.PurgeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PurgeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.ResultCode result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PurgeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.PurgeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.PurgeResponse)
  return target;
}

size_t PurgeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.PurgeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PurgeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PurgeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PurgeResponse::GetClassData() const { return &_class_data_; }


void PurgeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PurgeResponse*>(&to_msg);
  auto& from = static_cast<const PurgeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.PurgeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PurgeResponse::CopyFrom(const PurgeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.PurgeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurgeResponse::IsInitialized() const {
  return true;
}

void PurgeResponse::InternalSwap(PurgeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PurgeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[33]);
}

// ===================================================================

class ReadTreeResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const ReadTreeResponse* msg);
};

const ::hashdb::v1::ResultCode&
ReadTreeResponse::_Internal::result(const ReadTreeResponse* msg) {
  return *msg->_impl_.result_;
}
ReadTreeResponse::ReadTreeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.ReadTreeResponse)
}
ReadTreeResponse::ReadTreeResponse(const ReadTreeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadTreeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_value_){from._impl_.key_value_}
    , decltype(_impl_.hash_value_){from._impl_.hash_value_}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.ReadTreeResponse)
}

inline void ReadTreeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_value_){arena}
    , decltype(_impl_.hash_value_){arena}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadTreeResponse::~ReadTreeResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.ReadTreeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadTreeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_value_.~RepeatedPtrField();
  _impl_.hash_value_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.result_;
}

void ReadTreeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadTreeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.ReadTreeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_value_.Clear();
  _impl_.hash_value_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadTreeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .hashdb.v1.KeyValue key_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_key_value(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .hashdb.v1.HashValueGL hash_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hash_value(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.ResultCode result = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadTreeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.ReadTreeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hashdb.v1.KeyValue key_value = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_key_value_size()); i < n; i++) {
    const auto& repfield = this->_internal_key_value(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .hashdb.v1.HashValueGL hash_value = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hash_value_size()); i < n; i++) {
    const auto& repfield = this->_internal_hash_value(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .hashdb.v1.ResultCode result = 3;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.ReadTreeResponse)
  return target;
}

size_t ReadTreeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.ReadTreeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hashdb.v1.KeyValue key_value = 1;
  total_size += 1UL * this->_internal_key_value_size();
  for (const auto& msg : this->_impl_.key_value_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .hashdb.v1.HashValueGL hash_value = 2;
  total_size += 1UL * this->_internal_hash_value_size();
  for (const auto& msg : this->_impl_.hash_value_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .hashdb.v1.ResultCode result = 3;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadTreeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadTreeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadTreeResponse::GetClassData() const { return &_class_data_; }


void ReadTreeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadTreeResponse*>(&to_msg);
  auto& from = static_cast<const ReadTreeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.ReadTreeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.key_value_.MergeFrom(from._impl_.key_value_);
  _this->_impl_.hash_value_.MergeFrom(from._impl_.hash_value_);
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadTreeResponse::CopyFrom(const ReadTreeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.ReadTreeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadTreeResponse::IsInitialized() const {
  return true;
}

void ReadTreeResponse::InternalSwap(ReadTreeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.key_value_.InternalSwap(&other->_impl_.key_value_);
  _impl_.hash_value_.InternalSwap(&other->_impl_.hash_value_);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadTreeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[34]);
}

// ===================================================================

class CancelBatchResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const CancelBatchResponse* msg);
};

const ::hashdb::v1::ResultCode&
CancelBatchResponse::_Internal::result(const CancelBatchResponse* msg) {
  return *msg->_impl_.result_;
}
CancelBatchResponse::CancelBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.CancelBatchResponse)
}
CancelBatchResponse::CancelBatchResponse(const CancelBatchResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CancelBatchResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.CancelBatchResponse)
}

inline void CancelBatchResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CancelBatchResponse::~CancelBatchResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.CancelBatchResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CancelBatchResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.result_;
}

void CancelBatchResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CancelBatchResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.CancelBatchResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CancelBatchResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.ResultCode result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CancelBatchResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.CancelBatchResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.CancelBatchResponse)
  return target;
}

size_t CancelBatchResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.CancelBatchResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CancelBatchResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CancelBatchResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CancelBatchResponse::GetClassData() const { return &_class_data_; }


void CancelBatchResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CancelBatchResponse*>(&to_msg);
  auto& from = static_cast<const CancelBatchResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.CancelBatchResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CancelBatchResponse::CopyFrom(const CancelBatchResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.CancelBatchResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelBatchResponse::IsInitialized() const {
  return true;
}

void CancelBatchResponse::InternalSwap(CancelBatchResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CancelBatchResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[35]);
}

// ===================================================================

class ResetDBResponse::_Internal {
 public:
  static const ::hashdb::v1::ResultCode& result(const ResetDBResponse* msg);
};

const ::hashdb::v1::ResultCode&
ResetDBResponse::_Internal::result(const ResetDBResponse* msg) {
  return *msg->_impl_.result_;
}
ResetDBResponse::ResetDBResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.ResetDBResponse)
}
ResetDBResponse::ResetDBResponse(const ResetDBResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResetDBResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::hashdb::v1::ResultCode(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.ResetDBResponse)
}

inline void ResetDBResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResetDBResponse::~ResetDBResponse() {
  // @@protoc_insertion_point(destructor:hashdb.v1.ResetDBResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetDBResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.result_;
}

void ResetDBResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResetDBResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.ResetDBResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResetDBResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.ResultCode result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetDBResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.ResetDBResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.ResetDBResponse)
  return target;
}

size_t ResetDBResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.ResetDBResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode result = 1;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResetDBResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResetDBResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResetDBResponse::GetClassData() const { return &_class_data_; }


void ResetDBResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResetDBResponse*>(&to_msg);
  auto& from = static_cast<const ResetDBResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.ResetDBResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::hashdb::v1::ResultCode::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResetDBResponse::CopyFrom(const ResetDBResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.ResetDBResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetDBResponse::IsInitialized() const {
  return true;
}

void ResetDBResponse::InternalSwap(ResetDBResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResetDBResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[36]);
}

// ===================================================================

class Fea::_Internal {
 public:
};

Fea::Fea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.Fea)
}
Fea::Fea(const Fea& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Fea* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fe0_){}
    , decltype(_impl_.fe1_){}
    , decltype(_impl_.fe2_){}
    , decltype(_impl_.fe3_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.fe0_, &from._impl_.fe0_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fe3_) -
    reinterpret_cast<char*>(&_impl_.fe0_)) + sizeof(_impl_.fe3_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.Fea)
}

inline void Fea::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fe0_){uint64_t{0u}}
    , decltype(_impl_.fe1_){uint64_t{0u}}
    , decltype(_impl_.fe2_){uint64_t{0u}}
    , decltype(_impl_.fe3_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Fea::~Fea() {
  // @@protoc_insertion_point(destructor:hashdb.v1.Fea)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fea::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fea::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fea::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.Fea)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.fe0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fe3_) -
      reinterpret_cast<char*>(&_impl_.fe0_)) + sizeof(_impl_.fe3_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fea::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 fe0 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.fe0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.fe1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fe2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.fe3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fea::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.Fea)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 fe0 = 1;
  if (this->_internal_fe0() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_fe0(), target);
  }

  // uint64 fe1 = 2;
  if (this->_internal_fe1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_fe1(), target);
  }

  // uint64 fe2 = 3;
  if (this->_internal_fe2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_fe2(), target);
  }

  // uint64 fe3 = 4;
  if (this->_internal_fe3() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_fe3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.Fea)
  return target;
}

size_t Fea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.Fea)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 fe0 = 1;
  if (this->_internal_fe0() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe0());
  }

  // uint64 fe1 = 2;
  if (this->_internal_fe1() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe1());
  }

  // uint64 fe2 = 3;
  if (this->_internal_fe2() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe2());
  }

  // uint64 fe3 = 4;
  if (this->_internal_fe3() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe3());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fea::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Fea::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fea::GetClassData() const { return &_class_data_; }


void Fea::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Fea*>(&to_msg);
  auto& from = static_cast<const Fea&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.Fea)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_fe0() != 0) {
    _this->_internal_set_fe0(from._internal_fe0());
  }
  if (from._internal_fe1() != 0) {
    _this->_internal_set_fe1(from._internal_fe1());
  }
  if (from._internal_fe2() != 0) {
    _this->_internal_set_fe2(from._internal_fe2());
  }
  if (from._internal_fe3() != 0) {
    _this->_internal_set_fe3(from._internal_fe3());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fea::CopyFrom(const Fea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.Fea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fea::IsInitialized() const {
  return true;
}

void Fea::InternalSwap(Fea* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fea, _impl_.fe3_)
      + sizeof(Fea::_impl_.fe3_)
      - PROTOBUF_FIELD_OFFSET(Fea, _impl_.fe0_)>(
          reinterpret_cast<char*>(&_impl_.fe0_),
          reinterpret_cast<char*>(&other->_impl_.fe0_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Fea::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[37]);
}

// ===================================================================

class Fea12::_Internal {
 public:
};

Fea12::Fea12(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.Fea12)
}
Fea12::Fea12(const Fea12& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Fea12* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fe0_){}
    , decltype(_impl_.fe1_){}
    , decltype(_impl_.fe2_){}
    , decltype(_impl_.fe3_){}
    , decltype(_impl_.fe4_){}
    , decltype(_impl_.fe5_){}
    , decltype(_impl_.fe6_){}
    , decltype(_impl_.fe7_){}
    , decltype(_impl_.fe8_){}
    , decltype(_impl_.fe9_){}
    , decltype(_impl_.fe10_){}
    , decltype(_impl_.fe11_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.fe0_, &from._impl_.fe0_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fe11_) -
    reinterpret_cast<char*>(&_impl_.fe0_)) + sizeof(_impl_.fe11_));
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.Fea12)
}

inline void Fea12::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fe0_){uint64_t{0u}}
    , decltype(_impl_.fe1_){uint64_t{0u}}
    , decltype(_impl_.fe2_){uint64_t{0u}}
    , decltype(_impl_.fe3_){uint64_t{0u}}
    , decltype(_impl_.fe4_){uint64_t{0u}}
    , decltype(_impl_.fe5_){uint64_t{0u}}
    , decltype(_impl_.fe6_){uint64_t{0u}}
    , decltype(_impl_.fe7_){uint64_t{0u}}
    , decltype(_impl_.fe8_){uint64_t{0u}}
    , decltype(_impl_.fe9_){uint64_t{0u}}
    , decltype(_impl_.fe10_){uint64_t{0u}}
    , decltype(_impl_.fe11_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Fea12::~Fea12() {
  // @@protoc_insertion_point(destructor:hashdb.v1.Fea12)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fea12::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fea12::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fea12::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.Fea12)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.fe0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fe11_) -
      reinterpret_cast<char*>(&_impl_.fe0_)) + sizeof(_impl_.fe11_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Fea12::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 fe0 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.fe0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.fe1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fe2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.fe3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe4 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.fe4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe5 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.fe5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe6 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.fe6_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe7 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.fe7_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe8 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.fe8_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe9 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.fe9_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe10 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.fe10_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 fe11 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.fe11_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fea12::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.Fea12)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 fe0 = 1;
  if (this->_internal_fe0() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_fe0(), target);
  }

  // uint64 fe1 = 2;
  if (this->_internal_fe1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_fe1(), target);
  }

  // uint64 fe2 = 3;
  if (this->_internal_fe2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_fe2(), target);
  }

  // uint64 fe3 = 4;
  if (this->_internal_fe3() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_fe3(), target);
  }

  // uint64 fe4 = 5;
  if (this->_internal_fe4() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_fe4(), target);
  }

  // uint64 fe5 = 6;
  if (this->_internal_fe5() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_fe5(), target);
  }

  // uint64 fe6 = 7;
  if (this->_internal_fe6() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_fe6(), target);
  }

  // uint64 fe7 = 8;
  if (this->_internal_fe7() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_fe7(), target);
  }

  // uint64 fe8 = 9;
  if (this->_internal_fe8() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_fe8(), target);
  }

  // uint64 fe9 = 10;
  if (this->_internal_fe9() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_fe9(), target);
  }

  // uint64 fe10 = 11;
  if (this->_internal_fe10() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_fe10(), target);
  }

  // uint64 fe11 = 12;
  if (this->_internal_fe11() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_fe11(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.Fea12)
  return target;
}

size_t Fea12::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.Fea12)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 fe0 = 1;
  if (this->_internal_fe0() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe0());
  }

  // uint64 fe1 = 2;
  if (this->_internal_fe1() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe1());
  }

  // uint64 fe2 = 3;
  if (this->_internal_fe2() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe2());
  }

  // uint64 fe3 = 4;
  if (this->_internal_fe3() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe3());
  }

  // uint64 fe4 = 5;
  if (this->_internal_fe4() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe4());
  }

  // uint64 fe5 = 6;
  if (this->_internal_fe5() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe5());
  }

  // uint64 fe6 = 7;
  if (this->_internal_fe6() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe6());
  }

  // uint64 fe7 = 8;
  if (this->_internal_fe7() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe7());
  }

  // uint64 fe8 = 9;
  if (this->_internal_fe8() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe8());
  }

  // uint64 fe9 = 10;
  if (this->_internal_fe9() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe9());
  }

  // uint64 fe10 = 11;
  if (this->_internal_fe10() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe10());
  }

  // uint64 fe11 = 12;
  if (this->_internal_fe11() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fe11());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Fea12::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Fea12::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Fea12::GetClassData() const { return &_class_data_; }


void Fea12::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Fea12*>(&to_msg);
  auto& from = static_cast<const Fea12&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.Fea12)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_fe0() != 0) {
    _this->_internal_set_fe0(from._internal_fe0());
  }
  if (from._internal_fe1() != 0) {
    _this->_internal_set_fe1(from._internal_fe1());
  }
  if (from._internal_fe2() != 0) {
    _this->_internal_set_fe2(from._internal_fe2());
  }
  if (from._internal_fe3() != 0) {
    _this->_internal_set_fe3(from._internal_fe3());
  }
  if (from._internal_fe4() != 0) {
    _this->_internal_set_fe4(from._internal_fe4());
  }
  if (from._internal_fe5() != 0) {
    _this->_internal_set_fe5(from._internal_fe5());
  }
  if (from._internal_fe6() != 0) {
    _this->_internal_set_fe6(from._internal_fe6());
  }
  if (from._internal_fe7() != 0) {
    _this->_internal_set_fe7(from._internal_fe7());
  }
  if (from._internal_fe8() != 0) {
    _this->_internal_set_fe8(from._internal_fe8());
  }
  if (from._internal_fe9() != 0) {
    _this->_internal_set_fe9(from._internal_fe9());
  }
  if (from._internal_fe10() != 0) {
    _this->_internal_set_fe10(from._internal_fe10());
  }
  if (from._internal_fe11() != 0) {
    _this->_internal_set_fe11(from._internal_fe11());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Fea12::CopyFrom(const Fea12& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.Fea12)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fea12::IsInitialized() const {
  return true;
}

void Fea12::InternalSwap(Fea12* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fea12, _impl_.fe11_)
      + sizeof(Fea12::_impl_.fe11_)
      - PROTOBUF_FIELD_OFFSET(Fea12, _impl_.fe0_)>(
          reinterpret_cast<char*>(&_impl_.fe0_),
          reinterpret_cast<char*>(&other->_impl_.fe0_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Fea12::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[38]);
}

// ===================================================================

class HashValueGL::_Internal {
 public:
  static const ::hashdb::v1::Fea& hash(const HashValueGL* msg);
  static const ::hashdb::v1::Fea12& value(const HashValueGL* msg);
};

const ::hashdb::v1::Fea&
HashValueGL::_Internal::hash(const HashValueGL* msg) {
  return *msg->_impl_.hash_;
}
const ::hashdb::v1::Fea12&
HashValueGL::_Internal::value(const HashValueGL* msg) {
  return *msg->_impl_.value_;
}
HashValueGL::HashValueGL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.HashValueGL)
}
HashValueGL::HashValueGL(const HashValueGL& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HashValueGL* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_hash()) {
    _this->_impl_.hash_ = new ::hashdb::v1::Fea(*from._impl_.hash_);
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::hashdb::v1::Fea12(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.HashValueGL)
}

inline void HashValueGL::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HashValueGL::~HashValueGL() {
  // @@protoc_insertion_point(destructor:hashdb.v1.HashValueGL)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HashValueGL::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.hash_;
  if (this != internal_default_instance()) delete _impl_.value_;
}

void HashValueGL::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HashValueGL::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.HashValueGL)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.hash_ != nullptr) {
    delete _impl_.hash_;
  }
  _impl_.hash_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HashValueGL::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_hash(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .hashdb.v1.Fea12 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HashValueGL::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.HashValueGL)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea hash = 1;
  if (this->_internal_has_hash()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::hash(this),
        _Internal::hash(this).GetCachedSize(), target, stream);
  }

  // .hashdb.v1.Fea12 value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.HashValueGL)
  return target;
}

size_t HashValueGL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.HashValueGL)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.Fea hash = 1;
  if (this->_internal_has_hash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.hash_);
  }

  // .hashdb.v1.Fea12 value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashValueGL::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HashValueGL::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashValueGL::GetClassData() const { return &_class_data_; }


void HashValueGL::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HashValueGL*>(&to_msg);
  auto& from = static_cast<const HashValueGL&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.HashValueGL)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hash()) {
    _this->_internal_mutable_hash()->::hashdb::v1::Fea::MergeFrom(
        from._internal_hash());
  }
  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::hashdb::v1::Fea12::MergeFrom(
        from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HashValueGL::CopyFrom(const HashValueGL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.HashValueGL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashValueGL::IsInitialized() const {
  return true;
}

void HashValueGL::InternalSwap(HashValueGL* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashValueGL, _impl_.value_)
      + sizeof(HashValueGL::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(HashValueGL, _impl_.hash_)>(
          reinterpret_cast<char*>(&_impl_.hash_),
          reinterpret_cast<char*>(&other->_impl_.hash_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HashValueGL::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[39]);
}

// ===================================================================

class KeyValue::_Internal {
 public:
  static const ::hashdb::v1::Fea& key(const KeyValue* msg);
};

const ::hashdb::v1::Fea&
KeyValue::_Internal::key(const KeyValue* msg) {
  return *msg->_impl_.key_;
}
KeyValue::KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.KeyValue)
}
KeyValue::KeyValue(const KeyValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.key_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hashdb::v1::Fea(*from._impl_.key_);
  }
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.KeyValue)
}

inline void KeyValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.key_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyValue::~KeyValue() {
  // @@protoc_insertion_point(destructor:hashdb.v1.KeyValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.key_;
}

void KeyValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyValue::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.KeyValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.Fea key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "hashdb.v1.KeyValue.value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.KeyValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.Fea key = 1;
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "hashdb.v1.KeyValue.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.KeyValue)
  return target;
}

size_t KeyValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.KeyValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // .hashdb.v1.Fea key = 1;
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyValue::GetClassData() const { return &_class_data_; }


void KeyValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyValue*>(&to_msg);
  auto& from = static_cast<const KeyValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.KeyValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::hashdb::v1::Fea::MergeFrom(
        from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyValue::CopyFrom(const KeyValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.KeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyValue::IsInitialized() const {
  return true;
}

void KeyValue::InternalSwap(KeyValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.key_, other->_impl_.key_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[40]);
}

// ===================================================================

class FeList::_Internal {
 public:
};

FeList::FeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.FeList)
}
FeList::FeList(const FeList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fe_){from._impl_.fe_}
    , /*decltype(_impl_._fe_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.FeList)
}

inline void FeList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fe_){arena}
    , /*decltype(_impl_._fe_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FeList::~FeList() {
  // @@protoc_insertion_point(destructor:hashdb.v1.FeList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fe_.~RepeatedField();
}

void FeList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeList::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.FeList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fe_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 fe = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_fe(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_fe(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.FeList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 fe = 1;
  {
    int byte_size = _impl_._fe_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_fe(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.FeList)
  return target;
}

size_t FeList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.FeList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 fe = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.fe_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._fe_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeList::GetClassData() const { return &_class_data_; }


void FeList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeList*>(&to_msg);
  auto& from = static_cast<const FeList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.FeList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fe_.MergeFrom(from._impl_.fe_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeList::CopyFrom(const FeList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.FeList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeList::IsInitialized() const {
  return true;
}

void FeList::InternalSwap(FeList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fe_.InternalSwap(&other->_impl_.fe_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[41]);
}

// ===================================================================

class SiblingList::_Internal {
 public:
};

SiblingList::SiblingList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.SiblingList)
}
SiblingList::SiblingList(const SiblingList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SiblingList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sibling_){from._impl_.sibling_}
    , /*decltype(_impl_._sibling_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.SiblingList)
}

inline void SiblingList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sibling_){arena}
    , /*decltype(_impl_._sibling_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SiblingList::~SiblingList() {
  // @@protoc_insertion_point(destructor:hashdb.v1.SiblingList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SiblingList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sibling_.~RepeatedField();
}

void SiblingList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SiblingList::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.SiblingList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sibling_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SiblingList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 sibling = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_sibling(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_sibling(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SiblingList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.SiblingList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 sibling = 1;
  {
    int byte_size = _impl_._sibling_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_sibling(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.SiblingList)
  return target;
}

size_t SiblingList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.SiblingList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 sibling = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.sibling_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._sibling_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SiblingList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SiblingList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SiblingList::GetClassData() const { return &_class_data_; }


void SiblingList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SiblingList*>(&to_msg);
  auto& from = static_cast<const SiblingList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.SiblingList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sibling_.MergeFrom(from._impl_.sibling_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SiblingList::CopyFrom(const SiblingList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.SiblingList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SiblingList::IsInitialized() const {
  return true;
}

void SiblingList::InternalSwap(SiblingList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.sibling_.InternalSwap(&other->_impl_.sibling_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SiblingList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[42]);
}

// ===================================================================

class ResultCode::_Internal {
 public:
};

ResultCode::ResultCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hashdb.v1.ResultCode)
}
ResultCode::ResultCode(const ResultCode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResultCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.code_ = from._impl_.code_;
  // @@protoc_insertion_point(copy_constructor:hashdb.v1.ResultCode)
}

inline void ResultCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResultCode::~ResultCode() {
  // @@protoc_insertion_point(destructor:hashdb.v1.ResultCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResultCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResultCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResultCode::Clear() {
// @@protoc_insertion_point(message_clear_start:hashdb.v1.ResultCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.code_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResultCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .hashdb.v1.ResultCode.Code code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_code(static_cast<::hashdb::v1::ResultCode_Code>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResultCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hashdb.v1.ResultCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode.Code code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hashdb.v1.ResultCode)
  return target;
}

size_t ResultCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hashdb.v1.ResultCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .hashdb.v1.ResultCode.Code code = 1;
  if (this->_internal_code() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResultCode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResultCode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResultCode::GetClassData() const { return &_class_data_; }


void ResultCode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResultCode*>(&to_msg);
  auto& from = static_cast<const ResultCode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hashdb.v1.ResultCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResultCode::CopyFrom(const ResultCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hashdb.v1.ResultCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResultCode::IsInitialized() const {
  return true;
}

void ResultCode::InternalSwap(ResultCode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.code_, other->_impl_.code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResultCode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_hashdb_2eproto_getter, &descriptor_table_hashdb_2eproto_once,
      file_level_metadata_hashdb_2eproto[43]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace hashdb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::hashdb::v1::Version*
Arena::CreateMaybeMessage< ::hashdb::v1::Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::Version >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::SetRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::SetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::SetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::GetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::SetProgramRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::SetProgramRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::SetProgramRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetProgramRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::GetProgramRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetProgramRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::LoadDBRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::LoadDBRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::LoadDBRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::LoadProgramDBRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::LoadProgramDBRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::LoadProgramDBRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::FlushRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::FlushRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::FlushRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::FinishTxRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::FinishTxRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::FinishTxRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::StartBlockRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::StartBlockRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::StartBlockRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::FinishBlockRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::FinishBlockRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::FinishBlockRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetFlushDataRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::GetFlushDataRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetFlushDataRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::ConsolidateStateRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::ConsolidateStateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::ConsolidateStateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::PurgeRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::PurgeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::PurgeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::ReadTreeRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::ReadTreeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::ReadTreeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::CancelBatchRequest*
Arena::CreateMaybeMessage< ::hashdb::v1::CancelBatchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::CancelBatchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetLatestStateRootResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetLatestStateRootResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetLatestStateRootResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::SetResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::SetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::SetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::SetProgramResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::SetProgramResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::SetProgramResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetProgramResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetProgramResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetProgramResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::FlushResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::FlushResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::FlushResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetFlushStatusResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetFlushStatusResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetFlushStatusResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::GetFlushDataResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::GetFlushDataResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::GetFlushDataResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::ConsolidateStateResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::ConsolidateStateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::ConsolidateStateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::PurgeResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::PurgeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::PurgeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::ReadTreeResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::ReadTreeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::ReadTreeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::CancelBatchResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::CancelBatchResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::CancelBatchResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::ResetDBResponse*
Arena::CreateMaybeMessage< ::hashdb::v1::ResetDBResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::ResetDBResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::Fea*
Arena::CreateMaybeMessage< ::hashdb::v1::Fea >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::Fea >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::Fea12*
Arena::CreateMaybeMessage< ::hashdb::v1::Fea12 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::Fea12 >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::HashValueGL*
Arena::CreateMaybeMessage< ::hashdb::v1::HashValueGL >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::HashValueGL >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::KeyValue*
Arena::CreateMaybeMessage< ::hashdb::v1::KeyValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::KeyValue >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::FeList*
Arena::CreateMaybeMessage< ::hashdb::v1::FeList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::FeList >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::SiblingList*
Arena::CreateMaybeMessage< ::hashdb::v1::SiblingList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::SiblingList >(arena);
}
template<> PROTOBUF_NOINLINE ::hashdb::v1::ResultCode*
Arena::CreateMaybeMessage< ::hashdb::v1::ResultCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hashdb::v1::ResultCode >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
